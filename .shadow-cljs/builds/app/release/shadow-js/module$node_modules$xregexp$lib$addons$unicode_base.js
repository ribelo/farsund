["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/xregexp/lib/addons/unicode-base.js"],"~:js","shadow$provide.module$node_modules$xregexp$lib$addons$unicode_base=function(b,e,a,f,c,m){Object.defineProperty(c,\"__esModule\",{value:!0});c.default=void 0;c.default=function(a){function b(a){return a.replace(/[- _]+/g,\"\").toLowerCase()}function c(a){var b=/^\\\\[xu](.+)/.exec(a);return b?f(b[1]):a.charCodeAt(\"\\\\\"===a[0]?1:0)}function d(b){var d=\"\",e=-1;a.forEach(b,/(\\\\x..|\\\\u....|\\\\?[\\s\\S])(?:-(\\\\x..|\\\\u....|\\\\?[\\s\\S]))?/,function(a){var b=c(a[1]);b>e+1&&(d+=\"\\\\u\".concat(g(q(e+1))),b>e+2&&(d+=\"-\\\\u\".concat(g(q(b-\n1)))));e=c(a[2]||a[1])});65535>e&&(d+=\"\\\\u\".concat(g(q(e+1))),65534>e&&(d+=\"-\\\\uFFFF\"));return d}var e={},f=a._dec,q=a._hex,g=a._pad4;a.addToken(/\\\\([pP])(?:{(\\^?)([^}]*)}|([A-Za-z]))/,function(a,c,g){var f=\"P\"===a[1]||!!a[2],h=-1!==g.indexOf(\"A\");g=b(a[4]||a[3]);var k=e[g];if(\"P\"===a[1]&&a[2])throw new SyntaxError(\"Invalid double negation \"+a[0]);if(!e.hasOwnProperty(g))throw new SyntaxError(\"Unknown Unicode token \"+a[0]);if(k.inverseOf){g=b(k.inverseOf);if(!e.hasOwnProperty(g))throw new ReferenceError(\"\".concat(\"Unicode token missing data \"+\na[0],\" -\\x3e \").concat(k.inverseOf));k=e[g];f=!f}if(!k.bmp&&!h)throw new SyntaxError(\"Astral mode required for Unicode token \"+a[0]);if(h){if(\"class\"===c)throw new SyntaxError(\"Astral mode does not support Unicode tokens within character classes\");a=f?\"a!\":\"a\\x3d\";(c=e[g][a])||(c=e[g],g=e[g],h=\"\",g.bmp&&!g.isBmpLast&&(h=\"[\".concat(g.bmp,\"]\").concat(g.astral?\"|\":\"\")),g.astral&&(h+=g.astral),g.isBmpLast&&g.bmp&&(h+=\"\".concat(g.astral?\"|\":\"\",\"[\").concat(g.bmp,\"]\")),f=f?\"(?:(?!\".concat(h,\")(?:[\\ud800-\\udbff][\\udc00-\\udfff]|[\\x00-ï¿¿]))\"):\n\"(?:\".concat(h,\")\"),c=c[a]=f);return c}return\"class\"===c?f?e[g][\"b!\"]||(e[g][\"b!\"]=d(e[g].bmp)):k.bmp:\"\".concat((f?\"[^\":\"[\")+k.bmp,\"]\")},{scope:\"all\",optionalFlags:\"A\",leadChar:\"\\\\\"});a.addUnicodeData=function(c){var d=!0,g=!1,f=void 0;try{for(var h=c[Symbol.iterator](),k;!(d=(k=h.next()).done);d=!0){var l=k.value;if(!l.name)throw Error(\"Unicode token requires name\");if(!(l.inverseOf||l.bmp||l.astral))throw Error(\"Unicode token has no character data \"+l.name);e[b(l.name)]=l;l.alias&&(e[b(l.alias)]=\nl)}}catch(z){g=!0,f=z}finally{try{d||null==h.return||h.return()}finally{if(g)throw f;}}a.cache.flush(\"patterns\")};a._getUnicodeProperty=function(a){a=b(a);return e[a]}};f.exports=c[\"default\"]}","~:source","shadow$provide[\"module$node_modules$xregexp$lib$addons$unicode_base\"] = function(global,process,require,module,exports,shadow$shims) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\n/*!\n * XRegExp Unicode Base 4.2.0\n * <xregexp.com>\n * Steven Levithan (c) 2008-present MIT License\n */\nvar _default = function _default(XRegExp) {\n  /**\n   * Adds base support for Unicode matching:\n   * - Adds syntax `\\p{..}` for matching Unicode tokens. Tokens can be inverted using `\\P{..}` or\n   *   `\\p{^..}`. Token names ignore case, spaces, hyphens, and underscores. You can omit the\n   *   braces for token names that are a single letter (e.g. `\\pL` or `PL`).\n   * - Adds flag A (astral), which enables 21-bit Unicode support.\n   * - Adds the `XRegExp.addUnicodeData` method used by other addons to provide character data.\n   *\n   * Unicode Base relies on externally provided Unicode character data. Official addons are\n   * available to provide data for Unicode categories, scripts, blocks, and properties.\n   *\n   * @requires XRegExp\n   */\n  // ==--------------------------==\n  // Private stuff\n  // ==--------------------------==\n  // Storage for Unicode data\n  var unicode = {}; // Reuse utils\n\n  var dec = XRegExp._dec;\n  var hex = XRegExp._hex;\n  var pad4 = XRegExp._pad4; // Generates a token lookup name: lowercase, with hyphens, spaces, and underscores removed\n\n  function normalize(name) {\n    return name.replace(/[- _]+/g, '').toLowerCase();\n  } // Gets the decimal code of a literal code unit, \\xHH, \\uHHHH, or a backslash-escaped literal\n\n\n  function charCode(chr) {\n    var esc = /^\\\\[xu](.+)/.exec(chr);\n    return esc ? dec(esc[1]) : chr.charCodeAt(chr[0] === '\\\\' ? 1 : 0);\n  } // Inverts a list of ordered BMP characters and ranges\n\n\n  function invertBmp(range) {\n    var output = '';\n    var lastEnd = -1;\n    XRegExp.forEach(range, /(\\\\x..|\\\\u....|\\\\?[\\s\\S])(?:-(\\\\x..|\\\\u....|\\\\?[\\s\\S]))?/, function (m) {\n      var start = charCode(m[1]);\n\n      if (start > lastEnd + 1) {\n        output += \"\\\\u\".concat(pad4(hex(lastEnd + 1)));\n\n        if (start > lastEnd + 2) {\n          output += \"-\\\\u\".concat(pad4(hex(start - 1)));\n        }\n      }\n\n      lastEnd = charCode(m[2] || m[1]);\n    });\n\n    if (lastEnd < 0xFFFF) {\n      output += \"\\\\u\".concat(pad4(hex(lastEnd + 1)));\n\n      if (lastEnd < 0xFFFE) {\n        output += '-\\\\uFFFF';\n      }\n    }\n\n    return output;\n  } // Generates an inverted BMP range on first use\n\n\n  function cacheInvertedBmp(slug) {\n    var prop = 'b!';\n    return unicode[slug][prop] || (unicode[slug][prop] = invertBmp(unicode[slug].bmp));\n  } // Combines and optionally negates BMP and astral data\n\n\n  function buildAstral(slug, isNegated) {\n    var item = unicode[slug];\n    var combined = '';\n\n    if (item.bmp && !item.isBmpLast) {\n      combined = \"[\".concat(item.bmp, \"]\").concat(item.astral ? '|' : '');\n    }\n\n    if (item.astral) {\n      combined += item.astral;\n    }\n\n    if (item.isBmpLast && item.bmp) {\n      combined += \"\".concat(item.astral ? '|' : '', \"[\").concat(item.bmp, \"]\");\n    } // Astral Unicode tokens always match a code point, never a code unit\n\n\n    return isNegated ? \"(?:(?!\".concat(combined, \")(?:[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\0-\\uFFFF]))\") : \"(?:\".concat(combined, \")\");\n  } // Builds a complete astral pattern on first use\n\n\n  function cacheAstral(slug, isNegated) {\n    var prop = isNegated ? 'a!' : 'a=';\n    return unicode[slug][prop] || (unicode[slug][prop] = buildAstral(slug, isNegated));\n  } // ==--------------------------==\n  // Core functionality\n  // ==--------------------------==\n\n  /*\n   * Add astral mode (flag A) and Unicode token syntax: `\\p{..}`, `\\P{..}`, `\\p{^..}`, `\\pC`.\n   */\n\n\n  XRegExp.addToken( // Use `*` instead of `+` to avoid capturing `^` as the token name in `\\p{^}`\n  /\\\\([pP])(?:{(\\^?)([^}]*)}|([A-Za-z]))/, function (match, scope, flags) {\n    var ERR_DOUBLE_NEG = 'Invalid double negation ';\n    var ERR_UNKNOWN_NAME = 'Unknown Unicode token ';\n    var ERR_UNKNOWN_REF = 'Unicode token missing data ';\n    var ERR_ASTRAL_ONLY = 'Astral mode required for Unicode token ';\n    var ERR_ASTRAL_IN_CLASS = 'Astral mode does not support Unicode tokens within character classes'; // Negated via \\P{..} or \\p{^..}\n\n    var isNegated = match[1] === 'P' || !!match[2]; // Switch from BMP (0-FFFF) to astral (0-10FFFF) mode via flag A\n\n    var isAstralMode = flags.indexOf('A') !== -1; // Token lookup name. Check `[4]` first to avoid passing `undefined` via `\\p{}`\n\n    var slug = normalize(match[4] || match[3]); // Token data object\n\n    var item = unicode[slug];\n\n    if (match[1] === 'P' && match[2]) {\n      throw new SyntaxError(ERR_DOUBLE_NEG + match[0]);\n    }\n\n    if (!unicode.hasOwnProperty(slug)) {\n      throw new SyntaxError(ERR_UNKNOWN_NAME + match[0]);\n    } // Switch to the negated form of the referenced Unicode token\n\n\n    if (item.inverseOf) {\n      slug = normalize(item.inverseOf);\n\n      if (!unicode.hasOwnProperty(slug)) {\n        throw new ReferenceError(\"\".concat(ERR_UNKNOWN_REF + match[0], \" -> \").concat(item.inverseOf));\n      }\n\n      item = unicode[slug];\n      isNegated = !isNegated;\n    }\n\n    if (!(item.bmp || isAstralMode)) {\n      throw new SyntaxError(ERR_ASTRAL_ONLY + match[0]);\n    }\n\n    if (isAstralMode) {\n      if (scope === 'class') {\n        throw new SyntaxError(ERR_ASTRAL_IN_CLASS);\n      }\n\n      return cacheAstral(slug, isNegated);\n    }\n\n    return scope === 'class' ? isNegated ? cacheInvertedBmp(slug) : item.bmp : \"\".concat((isNegated ? '[^' : '[') + item.bmp, \"]\");\n  }, {\n    scope: 'all',\n    optionalFlags: 'A',\n    leadChar: '\\\\'\n  });\n  /**\n   * Adds to the list of Unicode tokens that XRegExp regexes can match via `\\p` or `\\P`.\n   *\n   * @memberOf XRegExp\n   * @param {Array} data Objects with named character ranges. Each object may have properties\n   *   `name`, `alias`, `isBmpLast`, `inverseOf`, `bmp`, and `astral`. All but `name` are\n   *   optional, although one of `bmp` or `astral` is required (unless `inverseOf` is set). If\n   *   `astral` is absent, the `bmp` data is used for BMP and astral modes. If `bmp` is absent,\n   *   the name errors in BMP mode but works in astral mode. If both `bmp` and `astral` are\n   *   provided, the `bmp` data only is used in BMP mode, and the combination of `bmp` and\n   *   `astral` data is used in astral mode. `isBmpLast` is needed when a token matches orphan\n   *   high surrogates *and* uses surrogate pairs to match astral code points. The `bmp` and\n   *   `astral` data should be a combination of literal characters and `\\xHH` or `\\uHHHH` escape\n   *   sequences, with hyphens to create ranges. Any regex metacharacters in the data should be\n   *   escaped, apart from range-creating hyphens. The `astral` data can additionally use\n   *   character classes and alternation, and should use surrogate pairs to represent astral code\n   *   points. `inverseOf` can be used to avoid duplicating character data if a Unicode token is\n   *   defined as the exact inverse of another token.\n   * @example\n   *\n   * // Basic use\n   * XRegExp.addUnicodeData([{\n   *   name: 'XDigit',\n   *   alias: 'Hexadecimal',\n   *   bmp: '0-9A-Fa-f'\n   * }]);\n   * XRegExp('\\\\p{XDigit}:\\\\p{Hexadecimal}+').test('0:3D'); // -> true\n   */\n\n  XRegExp.addUnicodeData = function (data) {\n    var ERR_NO_NAME = 'Unicode token requires name';\n    var ERR_NO_DATA = 'Unicode token has no character data ';\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var item = _step.value;\n\n        if (!item.name) {\n          throw new Error(ERR_NO_NAME);\n        }\n\n        if (!(item.inverseOf || item.bmp || item.astral)) {\n          throw new Error(ERR_NO_DATA + item.name);\n        }\n\n        unicode[normalize(item.name)] = item;\n\n        if (item.alias) {\n          unicode[normalize(item.alias)] = item;\n        }\n      } // Reset the pattern cache used by the `XRegExp` constructor, since the same pattern and\n      // flags might now produce different results\n\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    XRegExp.cache.flush('patterns');\n  };\n  /**\n   * @ignore\n   *\n   * Return a reference to the internal Unicode definition structure for the given Unicode\n   * Property if the given name is a legal Unicode Property for use in XRegExp `\\p` or `\\P` regex\n   * constructs.\n   *\n   * @memberOf XRegExp\n   * @param {String} name Name by which the Unicode Property may be recognized (case-insensitive),\n   *   e.g. `'N'` or `'Number'`. The given name is matched against all registered Unicode\n   *   Properties and Property Aliases.\n   * @returns {Object} Reference to definition structure when the name matches a Unicode Property.\n   *\n   * @note\n   * For more info on Unicode Properties, see also http://unicode.org/reports/tr18/#Categories.\n   *\n   * @note\n   * This method is *not* part of the officially documented API and may change or be removed in\n   * the future. It is meant for userland code that wishes to reuse the (large) internal Unicode\n   * structures set up by XRegExp.\n   */\n\n\n  XRegExp._getUnicodeProperty = function (name) {\n    var slug = normalize(name);\n    return unicode[slug];\n  };\n};\n\nexports.default = _default;\nmodule.exports = exports[\"default\"];\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["leadChar","__esModule","optionalFlags","value","scope","addUnicodeData","_getUnicodeProperty","default"]],"~:compiled-at",1537815743225,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$xregexp$lib$addons$unicode_base.js\",\n\"lineCount\":5,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/xregexp/lib/addons/unicode-base.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$xregexp$lib$addons$unicode_base\\\"] = function(global,process,require,module,exports,shadow$shims) {\\n\\\"use strict\\\";\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.default = void 0;\\n\\n/*!\\n * XRegExp Unicode Base 4.2.0\\n * <xregexp.com>\\n * Steven Levithan (c) 2008-present MIT License\\n */\\nvar _default = function _default(XRegExp) {\\n  /**\\n   * Adds base support for Unicode matching:\\n   * - Adds syntax `\\\\p{..}` for matching Unicode tokens. Tokens can be inverted using `\\\\P{..}` or\\n   *   `\\\\p{^..}`. Token names ignore case, spaces, hyphens, and underscores. You can omit the\\n   *   braces for token names that are a single letter (e.g. `\\\\pL` or `PL`).\\n   * - Adds flag A (astral), which enables 21-bit Unicode support.\\n   * - Adds the `XRegExp.addUnicodeData` method used by other addons to provide character data.\\n   *\\n   * Unicode Base relies on externally provided Unicode character data. Official addons are\\n   * available to provide data for Unicode categories, scripts, blocks, and properties.\\n   *\\n   * @requires XRegExp\\n   */\\n  // ==--------------------------==\\n  // Private stuff\\n  // ==--------------------------==\\n  // Storage for Unicode data\\n  var unicode = {}; // Reuse utils\\n\\n  var dec = XRegExp._dec;\\n  var hex = XRegExp._hex;\\n  var pad4 = XRegExp._pad4; // Generates a token lookup name: lowercase, with hyphens, spaces, and underscores removed\\n\\n  function normalize(name) {\\n    return name.replace(/[- _]+/g, '').toLowerCase();\\n  } // Gets the decimal code of a literal code unit, \\\\xHH, \\\\uHHHH, or a backslash-escaped literal\\n\\n\\n  function charCode(chr) {\\n    var esc = /^\\\\\\\\[xu](.+)/.exec(chr);\\n    return esc ? dec(esc[1]) : chr.charCodeAt(chr[0] === '\\\\\\\\' ? 1 : 0);\\n  } // Inverts a list of ordered BMP characters and ranges\\n\\n\\n  function invertBmp(range) {\\n    var output = '';\\n    var lastEnd = -1;\\n    XRegExp.forEach(range, /(\\\\\\\\x..|\\\\\\\\u....|\\\\\\\\?[\\\\s\\\\S])(?:-(\\\\\\\\x..|\\\\\\\\u....|\\\\\\\\?[\\\\s\\\\S]))?/, function (m) {\\n      var start = charCode(m[1]);\\n\\n      if (start > lastEnd + 1) {\\n        output += \\\"\\\\\\\\u\\\".concat(pad4(hex(lastEnd + 1)));\\n\\n        if (start > lastEnd + 2) {\\n          output += \\\"-\\\\\\\\u\\\".concat(pad4(hex(start - 1)));\\n        }\\n      }\\n\\n      lastEnd = charCode(m[2] || m[1]);\\n    });\\n\\n    if (lastEnd < 0xFFFF) {\\n      output += \\\"\\\\\\\\u\\\".concat(pad4(hex(lastEnd + 1)));\\n\\n      if (lastEnd < 0xFFFE) {\\n        output += '-\\\\\\\\uFFFF';\\n      }\\n    }\\n\\n    return output;\\n  } // Generates an inverted BMP range on first use\\n\\n\\n  function cacheInvertedBmp(slug) {\\n    var prop = 'b!';\\n    return unicode[slug][prop] || (unicode[slug][prop] = invertBmp(unicode[slug].bmp));\\n  } // Combines and optionally negates BMP and astral data\\n\\n\\n  function buildAstral(slug, isNegated) {\\n    var item = unicode[slug];\\n    var combined = '';\\n\\n    if (item.bmp && !item.isBmpLast) {\\n      combined = \\\"[\\\".concat(item.bmp, \\\"]\\\").concat(item.astral ? '|' : '');\\n    }\\n\\n    if (item.astral) {\\n      combined += item.astral;\\n    }\\n\\n    if (item.isBmpLast && item.bmp) {\\n      combined += \\\"\\\".concat(item.astral ? '|' : '', \\\"[\\\").concat(item.bmp, \\\"]\\\");\\n    } // Astral Unicode tokens always match a code point, never a code unit\\n\\n\\n    return isNegated ? \\\"(?:(?!\\\".concat(combined, \\\")(?:[\\\\uD800-\\\\uDBFF][\\\\uDC00-\\\\uDFFF]|[\\\\0-\\\\uFFFF]))\\\") : \\\"(?:\\\".concat(combined, \\\")\\\");\\n  } // Builds a complete astral pattern on first use\\n\\n\\n  function cacheAstral(slug, isNegated) {\\n    var prop = isNegated ? 'a!' : 'a=';\\n    return unicode[slug][prop] || (unicode[slug][prop] = buildAstral(slug, isNegated));\\n  } // ==--------------------------==\\n  // Core functionality\\n  // ==--------------------------==\\n\\n  /*\\n   * Add astral mode (flag A) and Unicode token syntax: `\\\\p{..}`, `\\\\P{..}`, `\\\\p{^..}`, `\\\\pC`.\\n   */\\n\\n\\n  XRegExp.addToken( // Use `*` instead of `+` to avoid capturing `^` as the token name in `\\\\p{^}`\\n  /\\\\\\\\([pP])(?:{(\\\\^?)([^}]*)}|([A-Za-z]))/, function (match, scope, flags) {\\n    var ERR_DOUBLE_NEG = 'Invalid double negation ';\\n    var ERR_UNKNOWN_NAME = 'Unknown Unicode token ';\\n    var ERR_UNKNOWN_REF = 'Unicode token missing data ';\\n    var ERR_ASTRAL_ONLY = 'Astral mode required for Unicode token ';\\n    var ERR_ASTRAL_IN_CLASS = 'Astral mode does not support Unicode tokens within character classes'; // Negated via \\\\P{..} or \\\\p{^..}\\n\\n    var isNegated = match[1] === 'P' || !!match[2]; // Switch from BMP (0-FFFF) to astral (0-10FFFF) mode via flag A\\n\\n    var isAstralMode = flags.indexOf('A') !== -1; // Token lookup name. Check `[4]` first to avoid passing `undefined` via `\\\\p{}`\\n\\n    var slug = normalize(match[4] || match[3]); // Token data object\\n\\n    var item = unicode[slug];\\n\\n    if (match[1] === 'P' && match[2]) {\\n      throw new SyntaxError(ERR_DOUBLE_NEG + match[0]);\\n    }\\n\\n    if (!unicode.hasOwnProperty(slug)) {\\n      throw new SyntaxError(ERR_UNKNOWN_NAME + match[0]);\\n    } // Switch to the negated form of the referenced Unicode token\\n\\n\\n    if (item.inverseOf) {\\n      slug = normalize(item.inverseOf);\\n\\n      if (!unicode.hasOwnProperty(slug)) {\\n        throw new ReferenceError(\\\"\\\".concat(ERR_UNKNOWN_REF + match[0], \\\" -> \\\").concat(item.inverseOf));\\n      }\\n\\n      item = unicode[slug];\\n      isNegated = !isNegated;\\n    }\\n\\n    if (!(item.bmp || isAstralMode)) {\\n      throw new SyntaxError(ERR_ASTRAL_ONLY + match[0]);\\n    }\\n\\n    if (isAstralMode) {\\n      if (scope === 'class') {\\n        throw new SyntaxError(ERR_ASTRAL_IN_CLASS);\\n      }\\n\\n      return cacheAstral(slug, isNegated);\\n    }\\n\\n    return scope === 'class' ? isNegated ? cacheInvertedBmp(slug) : item.bmp : \\\"\\\".concat((isNegated ? '[^' : '[') + item.bmp, \\\"]\\\");\\n  }, {\\n    scope: 'all',\\n    optionalFlags: 'A',\\n    leadChar: '\\\\\\\\'\\n  });\\n  /**\\n   * Adds to the list of Unicode tokens that XRegExp regexes can match via `\\\\p` or `\\\\P`.\\n   *\\n   * @memberOf XRegExp\\n   * @param {Array} data Objects with named character ranges. Each object may have properties\\n   *   `name`, `alias`, `isBmpLast`, `inverseOf`, `bmp`, and `astral`. All but `name` are\\n   *   optional, although one of `bmp` or `astral` is required (unless `inverseOf` is set). If\\n   *   `astral` is absent, the `bmp` data is used for BMP and astral modes. If `bmp` is absent,\\n   *   the name errors in BMP mode but works in astral mode. If both `bmp` and `astral` are\\n   *   provided, the `bmp` data only is used in BMP mode, and the combination of `bmp` and\\n   *   `astral` data is used in astral mode. `isBmpLast` is needed when a token matches orphan\\n   *   high surrogates *and* uses surrogate pairs to match astral code points. The `bmp` and\\n   *   `astral` data should be a combination of literal characters and `\\\\xHH` or `\\\\uHHHH` escape\\n   *   sequences, with hyphens to create ranges. Any regex metacharacters in the data should be\\n   *   escaped, apart from range-creating hyphens. The `astral` data can additionally use\\n   *   character classes and alternation, and should use surrogate pairs to represent astral code\\n   *   points. `inverseOf` can be used to avoid duplicating character data if a Unicode token is\\n   *   defined as the exact inverse of another token.\\n   * @example\\n   *\\n   * // Basic use\\n   * XRegExp.addUnicodeData([{\\n   *   name: 'XDigit',\\n   *   alias: 'Hexadecimal',\\n   *   bmp: '0-9A-Fa-f'\\n   * }]);\\n   * XRegExp('\\\\\\\\p{XDigit}:\\\\\\\\p{Hexadecimal}+').test('0:3D'); // -> true\\n   */\\n\\n  XRegExp.addUnicodeData = function (data) {\\n    var ERR_NO_NAME = 'Unicode token requires name';\\n    var ERR_NO_DATA = 'Unicode token has no character data ';\\n    var _iteratorNormalCompletion = true;\\n    var _didIteratorError = false;\\n    var _iteratorError = undefined;\\n\\n    try {\\n      for (var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\\n        var item = _step.value;\\n\\n        if (!item.name) {\\n          throw new Error(ERR_NO_NAME);\\n        }\\n\\n        if (!(item.inverseOf || item.bmp || item.astral)) {\\n          throw new Error(ERR_NO_DATA + item.name);\\n        }\\n\\n        unicode[normalize(item.name)] = item;\\n\\n        if (item.alias) {\\n          unicode[normalize(item.alias)] = item;\\n        }\\n      } // Reset the pattern cache used by the `XRegExp` constructor, since the same pattern and\\n      // flags might now produce different results\\n\\n    } catch (err) {\\n      _didIteratorError = true;\\n      _iteratorError = err;\\n    } finally {\\n      try {\\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\\n          _iterator.return();\\n        }\\n      } finally {\\n        if (_didIteratorError) {\\n          throw _iteratorError;\\n        }\\n      }\\n    }\\n\\n    XRegExp.cache.flush('patterns');\\n  };\\n  /**\\n   * @ignore\\n   *\\n   * Return a reference to the internal Unicode definition structure for the given Unicode\\n   * Property if the given name is a legal Unicode Property for use in XRegExp `\\\\p` or `\\\\P` regex\\n   * constructs.\\n   *\\n   * @memberOf XRegExp\\n   * @param {String} name Name by which the Unicode Property may be recognized (case-insensitive),\\n   *   e.g. `'N'` or `'Number'`. The given name is matched against all registered Unicode\\n   *   Properties and Property Aliases.\\n   * @returns {Object} Reference to definition structure when the name matches a Unicode Property.\\n   *\\n   * @note\\n   * For more info on Unicode Properties, see also http://unicode.org/reports/tr18/#Categories.\\n   *\\n   * @note\\n   * This method is *not* part of the officially documented API and may change or be removed in\\n   * the future. It is meant for userland code that wishes to reuse the (large) internal Unicode\\n   * structures set up by XRegExp.\\n   */\\n\\n\\n  XRegExp._getUnicodeProperty = function (name) {\\n    var slug = normalize(name);\\n    return unicode[slug];\\n  };\\n};\\n\\nexports.default = _default;\\nmodule.exports = exports[\\\"default\\\"];\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"process\",\"require\",\"module\",\"exports\",\"shadow$shims\",\"Object\",\"defineProperty\",\"value\",\"default\",\"_default\",\"XRegExp\",\"normalize\",\"name\",\"replace\",\"toLowerCase\",\"charCode\",\"chr\",\"esc\",\"exec\",\"dec\",\"charCodeAt\",\"invertBmp\",\"range\",\"output\",\"lastEnd\",\"forEach\",\"m\",\"start\",\"concat\",\"pad4\",\"hex\",\"unicode\",\"_dec\",\"_hex\",\"_pad4\",\"addToken\",\"match\",\"scope\",\"flags\",\"isNegated\",\"isAstralMode\",\"indexOf\",\"slug\",\"item\",\"SyntaxError\",\"ERR_DOUBLE_NEG\",\"hasOwnProperty\",\"ERR_UNKNOWN_NAME\",\"inverseOf\",\"ReferenceError\",\"ERR_UNKNOWN_REF\",\"bmp\",\"ERR_ASTRAL_ONLY\",\"ERR_ASTRAL_IN_CLASS\",\"prop\",\"combined\",\"isBmpLast\",\"astral\",\"optionalFlags\",\"leadChar\",\"addUnicodeData\",\"XRegExp.addUnicodeData\",\"data\",\"_iteratorNormalCompletion\",\"_didIteratorError\",\"_iteratorError\",\"undefined\",\"_iterator\",\"Symbol\",\"iterator\",\"_step\",\"done\",\"next\",\"Error\",\"ERR_NO_NAME\",\"ERR_NO_DATA\",\"alias\",\"err\",\"return\",\"cache\",\"flush\",\"_getUnicodeProperty\",\"XRegExp._getUnicodeProperty\"]\n}\n"]