["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/react-virtualized/dist/commonjs/Grid/utils/CellSizeAndPositionManager.js"],"~:js","shadow$provide.module$node_modules$react_virtualized$dist$commonjs$Grid$utils$CellSizeAndPositionManager=function(b,e,a,f,c,m){Object.defineProperty(c,\"__esModule\",{value:!0});var d=(b=a(\"module$node_modules$babel_runtime$helpers$classCallCheck\"))&&b.__esModule?b:{default:b},k=(b=a(\"module$node_modules$babel_runtime$helpers$createClass\"))&&b.__esModule?b:{default:b};a(\"module$node_modules$react_virtualized$dist$commonjs$Grid$types\");a=function(){function a(b){var c=b.cellCount,e=b.cellSizeGetter;\nb=b.estimatedCellSize;(0,d.default)(this,a);this._cellSizeAndPositionData={};this._lastBatchedIndex=this._lastMeasuredIndex=-1;this._cellSizeGetter=e;this._cellCount=c;this._estimatedCellSize=b}(0,k.default)(a,[{key:\"areOffsetsAdjusted\",value:function(){return!1}},{key:\"configure\",value:function(a){var b=a.estimatedCellSize,c=a.cellSizeGetter;this._cellCount=a.cellCount;this._estimatedCellSize=b;this._cellSizeGetter=c}},{key:\"getCellCount\",value:function(){return this._cellCount}},{key:\"getEstimatedCellSize\",\nvalue:function(){return this._estimatedCellSize}},{key:\"getLastMeasuredIndex\",value:function(){return this._lastMeasuredIndex}},{key:\"getOffsetAdjustment\",value:function(){return 0}},{key:\"getSizeAndPositionOfCell\",value:function(a){if(0>a||a>=this._cellCount)throw Error(\"Requested index \"+a+\" is outside of range 0..\"+this._cellCount);if(a>this._lastMeasuredIndex){var b=this.getSizeAndPositionOfLastMeasuredCell();b=b.offset+b.size;for(var c=this._lastMeasuredIndex+1;c<=a;c++){var d=this._cellSizeGetter({index:c});\nif(void 0===d||isNaN(d))throw Error(\"Invalid size returned for cell \"+c+\" of value \"+d);null===d?(this._cellSizeAndPositionData[c]={offset:b,size:0},this._lastBatchedIndex=a):(this._cellSizeAndPositionData[c]={offset:b,size:d},b+=d,this._lastMeasuredIndex=a)}}return this._cellSizeAndPositionData[a]}},{key:\"getSizeAndPositionOfLastMeasuredCell\",value:function(){return 0<=this._lastMeasuredIndex?this._cellSizeAndPositionData[this._lastMeasuredIndex]:{offset:0,size:0}}},{key:\"getTotalSize\",value:function(){var a=\nthis.getSizeAndPositionOfLastMeasuredCell();return a.offset+a.size+(this._cellCount-this._lastMeasuredIndex-1)*this._estimatedCellSize}},{key:\"getUpdatedOffsetForIndex\",value:function(a){var b=a.align,c=void 0===b?\"auto\":b;b=a.containerSize;var d=a.currentOffset;if(0>=b)return 0;a=this.getSizeAndPositionOfCell(a.targetIndex);var e=a.offset,f=e-b+a.size;switch(c){case \"start\":c=e;break;case \"end\":c=f;break;case \"center\":c=e-(b-a.size)/2;break;default:c=Math.max(f,Math.min(e,d))}d=this.getTotalSize();\nreturn Math.max(0,Math.min(d-b,c))}},{key:\"getVisibleCellRange\",value:function(a){var b=a.containerSize;a=a.offset;if(0===this.getTotalSize())return{};b=a+b;var c=this._findNearestCell(a);a=this.getSizeAndPositionOfCell(c);a=a.offset+a.size;for(var d=c;a<b&&d<this._cellCount-1;)d++,a+=this.getSizeAndPositionOfCell(d).size;return{start:c,stop:d}}},{key:\"resetCell\",value:function(a){this._lastMeasuredIndex=Math.min(this._lastMeasuredIndex,a-1)}},{key:\"_binarySearch\",value:function(a,b,c){for(;b<=a;){var d=\nb+Math.floor((a-b)/2),e=this.getSizeAndPositionOfCell(d).offset;if(e===c)return d;e<c?b=d+1:e>c&&(a=d-1)}return 0<b?b-1:0}},{key:\"_exponentialSearch\",value:function(a,b){for(var c=1;a<this._cellCount&&this.getSizeAndPositionOfCell(a).offset<b;)a+=c,c*=2;return this._binarySearch(Math.min(a,this._cellCount-1),Math.floor(a/2),b)}},{key:\"_findNearestCell\",value:function(a){if(isNaN(a))throw Error(\"Invalid offset \"+a+\" specified\");a=Math.max(0,a);var b=this.getSizeAndPositionOfLastMeasuredCell(),c=Math.max(0,\nthis._lastMeasuredIndex);return b.offset>=a?this._binarySearch(c,0,a):this._exponentialSearch(c,a)}}]);return a}();c.default=a}","~:source","shadow$provide[\"module$node_modules$react_virtualized$dist$commonjs$Grid$utils$CellSizeAndPositionManager\"] = function(global,process,require,module,exports,shadow$shims) {\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _types = require('../types');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Just-in-time calculates and caches size and position information for a collection of cells.\n */\n\nvar CellSizeAndPositionManager = function () {\n\n  // Used in deferred mode to track which cells have been queued for measurement.\n\n  // Cache of size and position data for cells, mapped by cell index.\n  // Note that invalid values may exist in this map so only rely on cells up to this._lastMeasuredIndex\n  function CellSizeAndPositionManager(_ref) {\n    var cellCount = _ref.cellCount,\n        cellSizeGetter = _ref.cellSizeGetter,\n        estimatedCellSize = _ref.estimatedCellSize;\n    (0, _classCallCheck3.default)(this, CellSizeAndPositionManager);\n    this._cellSizeAndPositionData = {};\n    this._lastMeasuredIndex = -1;\n    this._lastBatchedIndex = -1;\n\n    this._cellSizeGetter = cellSizeGetter;\n    this._cellCount = cellCount;\n    this._estimatedCellSize = estimatedCellSize;\n  }\n\n  // Measurements for cells up to this index can be trusted; cells afterward should be estimated.\n\n\n  (0, _createClass3.default)(CellSizeAndPositionManager, [{\n    key: 'areOffsetsAdjusted',\n    value: function areOffsetsAdjusted() {\n      return false;\n    }\n  }, {\n    key: 'configure',\n    value: function configure(_ref2) {\n      var cellCount = _ref2.cellCount,\n          estimatedCellSize = _ref2.estimatedCellSize,\n          cellSizeGetter = _ref2.cellSizeGetter;\n\n      this._cellCount = cellCount;\n      this._estimatedCellSize = estimatedCellSize;\n      this._cellSizeGetter = cellSizeGetter;\n    }\n  }, {\n    key: 'getCellCount',\n    value: function getCellCount() {\n      return this._cellCount;\n    }\n  }, {\n    key: 'getEstimatedCellSize',\n    value: function getEstimatedCellSize() {\n      return this._estimatedCellSize;\n    }\n  }, {\n    key: 'getLastMeasuredIndex',\n    value: function getLastMeasuredIndex() {\n      return this._lastMeasuredIndex;\n    }\n  }, {\n    key: 'getOffsetAdjustment',\n    value: function getOffsetAdjustment() {\n      return 0;\n    }\n\n    /**\n     * This method returns the size and position for the cell at the specified index.\n     * It just-in-time calculates (or used cached values) for cells leading up to the index.\n     */\n\n  }, {\n    key: 'getSizeAndPositionOfCell',\n    value: function getSizeAndPositionOfCell(index) {\n      if (index < 0 || index >= this._cellCount) {\n        throw Error('Requested index ' + index + ' is outside of range 0..' + this._cellCount);\n      }\n\n      if (index > this._lastMeasuredIndex) {\n        var lastMeasuredCellSizeAndPosition = this.getSizeAndPositionOfLastMeasuredCell();\n        var _offset = lastMeasuredCellSizeAndPosition.offset + lastMeasuredCellSizeAndPosition.size;\n\n        for (var i = this._lastMeasuredIndex + 1; i <= index; i++) {\n          var _size = this._cellSizeGetter({ index: i });\n\n          // undefined or NaN probably means a logic error in the size getter.\n          // null means we're using CellMeasurer and haven't yet measured a given index.\n          if (_size === undefined || isNaN(_size)) {\n            throw Error('Invalid size returned for cell ' + i + ' of value ' + _size);\n          } else if (_size === null) {\n            this._cellSizeAndPositionData[i] = {\n              offset: _offset,\n              size: 0\n            };\n\n            this._lastBatchedIndex = index;\n          } else {\n            this._cellSizeAndPositionData[i] = {\n              offset: _offset,\n              size: _size\n            };\n\n            _offset += _size;\n\n            this._lastMeasuredIndex = index;\n          }\n        }\n      }\n\n      return this._cellSizeAndPositionData[index];\n    }\n  }, {\n    key: 'getSizeAndPositionOfLastMeasuredCell',\n    value: function getSizeAndPositionOfLastMeasuredCell() {\n      return this._lastMeasuredIndex >= 0 ? this._cellSizeAndPositionData[this._lastMeasuredIndex] : {\n        offset: 0,\n        size: 0\n      };\n    }\n\n    /**\n     * Total size of all cells being measured.\n     * This value will be completely estimated initially.\n     * As cells are measured, the estimate will be updated.\n     */\n\n  }, {\n    key: 'getTotalSize',\n    value: function getTotalSize() {\n      var lastMeasuredCellSizeAndPosition = this.getSizeAndPositionOfLastMeasuredCell();\n      var totalSizeOfMeasuredCells = lastMeasuredCellSizeAndPosition.offset + lastMeasuredCellSizeAndPosition.size;\n      var numUnmeasuredCells = this._cellCount - this._lastMeasuredIndex - 1;\n      var totalSizeOfUnmeasuredCells = numUnmeasuredCells * this._estimatedCellSize;\n      return totalSizeOfMeasuredCells + totalSizeOfUnmeasuredCells;\n    }\n\n    /**\n     * Determines a new offset that ensures a certain cell is visible, given the current offset.\n     * If the cell is already visible then the current offset will be returned.\n     * If the current offset is too great or small, it will be adjusted just enough to ensure the specified index is visible.\n     *\n     * @param align Desired alignment within container; one of \"auto\" (default), \"start\", or \"end\"\n     * @param containerSize Size (width or height) of the container viewport\n     * @param currentOffset Container's current (x or y) offset\n     * @param totalSize Total size (width or height) of all cells\n     * @return Offset to use to ensure the specified cell is visible\n     */\n\n  }, {\n    key: 'getUpdatedOffsetForIndex',\n    value: function getUpdatedOffsetForIndex(_ref3) {\n      var _ref3$align = _ref3.align,\n          align = _ref3$align === undefined ? 'auto' : _ref3$align,\n          containerSize = _ref3.containerSize,\n          currentOffset = _ref3.currentOffset,\n          targetIndex = _ref3.targetIndex;\n\n      if (containerSize <= 0) {\n        return 0;\n      }\n\n      var datum = this.getSizeAndPositionOfCell(targetIndex);\n      var maxOffset = datum.offset;\n      var minOffset = maxOffset - containerSize + datum.size;\n\n      var idealOffset = void 0;\n\n      switch (align) {\n        case 'start':\n          idealOffset = maxOffset;\n          break;\n        case 'end':\n          idealOffset = minOffset;\n          break;\n        case 'center':\n          idealOffset = maxOffset - (containerSize - datum.size) / 2;\n          break;\n        default:\n          idealOffset = Math.max(minOffset, Math.min(maxOffset, currentOffset));\n          break;\n      }\n\n      var totalSize = this.getTotalSize();\n\n      return Math.max(0, Math.min(totalSize - containerSize, idealOffset));\n    }\n  }, {\n    key: 'getVisibleCellRange',\n    value: function getVisibleCellRange(params) {\n      var containerSize = params.containerSize,\n          offset = params.offset;\n\n\n      var totalSize = this.getTotalSize();\n\n      if (totalSize === 0) {\n        return {};\n      }\n\n      var maxOffset = offset + containerSize;\n      var start = this._findNearestCell(offset);\n\n      var datum = this.getSizeAndPositionOfCell(start);\n      offset = datum.offset + datum.size;\n\n      var stop = start;\n\n      while (offset < maxOffset && stop < this._cellCount - 1) {\n        stop++;\n\n        offset += this.getSizeAndPositionOfCell(stop).size;\n      }\n\n      return {\n        start: start,\n        stop: stop\n      };\n    }\n\n    /**\n     * Clear all cached values for cells after the specified index.\n     * This method should be called for any cell that has changed its size.\n     * It will not immediately perform any calculations; they'll be performed the next time getSizeAndPositionOfCell() is called.\n     */\n\n  }, {\n    key: 'resetCell',\n    value: function resetCell(index) {\n      this._lastMeasuredIndex = Math.min(this._lastMeasuredIndex, index - 1);\n    }\n  }, {\n    key: '_binarySearch',\n    value: function _binarySearch(high, low, offset) {\n      while (low <= high) {\n        var middle = low + Math.floor((high - low) / 2);\n        var _currentOffset = this.getSizeAndPositionOfCell(middle).offset;\n\n        if (_currentOffset === offset) {\n          return middle;\n        } else if (_currentOffset < offset) {\n          low = middle + 1;\n        } else if (_currentOffset > offset) {\n          high = middle - 1;\n        }\n      }\n\n      if (low > 0) {\n        return low - 1;\n      } else {\n        return 0;\n      }\n    }\n  }, {\n    key: '_exponentialSearch',\n    value: function _exponentialSearch(index, offset) {\n      var interval = 1;\n\n      while (index < this._cellCount && this.getSizeAndPositionOfCell(index).offset < offset) {\n        index += interval;\n        interval *= 2;\n      }\n\n      return this._binarySearch(Math.min(index, this._cellCount - 1), Math.floor(index / 2), offset);\n    }\n\n    /**\n     * Searches for the cell (index) nearest the specified offset.\n     *\n     * If no exact match is found the next lowest cell index will be returned.\n     * This allows partially visible cells (with offsets just before/above the fold) to be visible.\n     */\n\n  }, {\n    key: '_findNearestCell',\n    value: function _findNearestCell(offset) {\n      if (isNaN(offset)) {\n        throw Error('Invalid offset ' + offset + ' specified');\n      }\n\n      // Our search algorithms find the nearest match at or below the specified offset.\n      // So make sure the offset is at least 0 or no match will be found.\n      offset = Math.max(0, offset);\n\n      var lastMeasuredCellSizeAndPosition = this.getSizeAndPositionOfLastMeasuredCell();\n      var lastMeasuredIndex = Math.max(0, this._lastMeasuredIndex);\n\n      if (lastMeasuredCellSizeAndPosition.offset >= offset) {\n        // If we've already measured cells within this range just use a binary search as it's faster.\n        return this._binarySearch(lastMeasuredIndex, 0, offset);\n      } else {\n        // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n        // The exponential search avoids pre-computing sizes for the full set of cells as a binary search would.\n        // The overall complexity for this approach is O(log n).\n        return this._exponentialSearch(lastMeasuredIndex, offset);\n      }\n    }\n  }]);\n  return CellSizeAndPositionManager;\n}();\n\nexports.default = CellSizeAndPositionManager;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$react_virtualized$dist$commonjs$Grid$types","~$shadow.js","~$module$node_modules$babel_runtime$helpers$classCallCheck","~$module$node_modules$babel_runtime$helpers$createClass"]],"~:properties",["^5",["stop","_cellCount","_cellSizeGetter","index","offset","key","__esModule","_lastBatchedIndex","value","_estimatedCellSize","start","_lastMeasuredIndex","size","default","_cellSizeAndPositionData"]],"~:compiled-at",1537815743248,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$react_virtualized$dist$commonjs$Grid$utils$CellSizeAndPositionManager.js\",\n\"lineCount\":8,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/react-virtualized/dist/commonjs/Grid/utils/CellSizeAndPositionManager.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$react_virtualized$dist$commonjs$Grid$utils$CellSizeAndPositionManager\\\"] = function(global,process,require,module,exports,shadow$shims) {\\n'use strict';\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\n\\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\\n\\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\\n\\nvar _createClass2 = require('babel-runtime/helpers/createClass');\\n\\nvar _createClass3 = _interopRequireDefault(_createClass2);\\n\\nvar _types = require('../types');\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\\n\\n/**\\n * Just-in-time calculates and caches size and position information for a collection of cells.\\n */\\n\\nvar CellSizeAndPositionManager = function () {\\n\\n  // Used in deferred mode to track which cells have been queued for measurement.\\n\\n  // Cache of size and position data for cells, mapped by cell index.\\n  // Note that invalid values may exist in this map so only rely on cells up to this._lastMeasuredIndex\\n  function CellSizeAndPositionManager(_ref) {\\n    var cellCount = _ref.cellCount,\\n        cellSizeGetter = _ref.cellSizeGetter,\\n        estimatedCellSize = _ref.estimatedCellSize;\\n    (0, _classCallCheck3.default)(this, CellSizeAndPositionManager);\\n    this._cellSizeAndPositionData = {};\\n    this._lastMeasuredIndex = -1;\\n    this._lastBatchedIndex = -1;\\n\\n    this._cellSizeGetter = cellSizeGetter;\\n    this._cellCount = cellCount;\\n    this._estimatedCellSize = estimatedCellSize;\\n  }\\n\\n  // Measurements for cells up to this index can be trusted; cells afterward should be estimated.\\n\\n\\n  (0, _createClass3.default)(CellSizeAndPositionManager, [{\\n    key: 'areOffsetsAdjusted',\\n    value: function areOffsetsAdjusted() {\\n      return false;\\n    }\\n  }, {\\n    key: 'configure',\\n    value: function configure(_ref2) {\\n      var cellCount = _ref2.cellCount,\\n          estimatedCellSize = _ref2.estimatedCellSize,\\n          cellSizeGetter = _ref2.cellSizeGetter;\\n\\n      this._cellCount = cellCount;\\n      this._estimatedCellSize = estimatedCellSize;\\n      this._cellSizeGetter = cellSizeGetter;\\n    }\\n  }, {\\n    key: 'getCellCount',\\n    value: function getCellCount() {\\n      return this._cellCount;\\n    }\\n  }, {\\n    key: 'getEstimatedCellSize',\\n    value: function getEstimatedCellSize() {\\n      return this._estimatedCellSize;\\n    }\\n  }, {\\n    key: 'getLastMeasuredIndex',\\n    value: function getLastMeasuredIndex() {\\n      return this._lastMeasuredIndex;\\n    }\\n  }, {\\n    key: 'getOffsetAdjustment',\\n    value: function getOffsetAdjustment() {\\n      return 0;\\n    }\\n\\n    /**\\n     * This method returns the size and position for the cell at the specified index.\\n     * It just-in-time calculates (or used cached values) for cells leading up to the index.\\n     */\\n\\n  }, {\\n    key: 'getSizeAndPositionOfCell',\\n    value: function getSizeAndPositionOfCell(index) {\\n      if (index < 0 || index >= this._cellCount) {\\n        throw Error('Requested index ' + index + ' is outside of range 0..' + this._cellCount);\\n      }\\n\\n      if (index > this._lastMeasuredIndex) {\\n        var lastMeasuredCellSizeAndPosition = this.getSizeAndPositionOfLastMeasuredCell();\\n        var _offset = lastMeasuredCellSizeAndPosition.offset + lastMeasuredCellSizeAndPosition.size;\\n\\n        for (var i = this._lastMeasuredIndex + 1; i <= index; i++) {\\n          var _size = this._cellSizeGetter({ index: i });\\n\\n          // undefined or NaN probably means a logic error in the size getter.\\n          // null means we're using CellMeasurer and haven't yet measured a given index.\\n          if (_size === undefined || isNaN(_size)) {\\n            throw Error('Invalid size returned for cell ' + i + ' of value ' + _size);\\n          } else if (_size === null) {\\n            this._cellSizeAndPositionData[i] = {\\n              offset: _offset,\\n              size: 0\\n            };\\n\\n            this._lastBatchedIndex = index;\\n          } else {\\n            this._cellSizeAndPositionData[i] = {\\n              offset: _offset,\\n              size: _size\\n            };\\n\\n            _offset += _size;\\n\\n            this._lastMeasuredIndex = index;\\n          }\\n        }\\n      }\\n\\n      return this._cellSizeAndPositionData[index];\\n    }\\n  }, {\\n    key: 'getSizeAndPositionOfLastMeasuredCell',\\n    value: function getSizeAndPositionOfLastMeasuredCell() {\\n      return this._lastMeasuredIndex >= 0 ? this._cellSizeAndPositionData[this._lastMeasuredIndex] : {\\n        offset: 0,\\n        size: 0\\n      };\\n    }\\n\\n    /**\\n     * Total size of all cells being measured.\\n     * This value will be completely estimated initially.\\n     * As cells are measured, the estimate will be updated.\\n     */\\n\\n  }, {\\n    key: 'getTotalSize',\\n    value: function getTotalSize() {\\n      var lastMeasuredCellSizeAndPosition = this.getSizeAndPositionOfLastMeasuredCell();\\n      var totalSizeOfMeasuredCells = lastMeasuredCellSizeAndPosition.offset + lastMeasuredCellSizeAndPosition.size;\\n      var numUnmeasuredCells = this._cellCount - this._lastMeasuredIndex - 1;\\n      var totalSizeOfUnmeasuredCells = numUnmeasuredCells * this._estimatedCellSize;\\n      return totalSizeOfMeasuredCells + totalSizeOfUnmeasuredCells;\\n    }\\n\\n    /**\\n     * Determines a new offset that ensures a certain cell is visible, given the current offset.\\n     * If the cell is already visible then the current offset will be returned.\\n     * If the current offset is too great or small, it will be adjusted just enough to ensure the specified index is visible.\\n     *\\n     * @param align Desired alignment within container; one of \\\"auto\\\" (default), \\\"start\\\", or \\\"end\\\"\\n     * @param containerSize Size (width or height) of the container viewport\\n     * @param currentOffset Container's current (x or y) offset\\n     * @param totalSize Total size (width or height) of all cells\\n     * @return Offset to use to ensure the specified cell is visible\\n     */\\n\\n  }, {\\n    key: 'getUpdatedOffsetForIndex',\\n    value: function getUpdatedOffsetForIndex(_ref3) {\\n      var _ref3$align = _ref3.align,\\n          align = _ref3$align === undefined ? 'auto' : _ref3$align,\\n          containerSize = _ref3.containerSize,\\n          currentOffset = _ref3.currentOffset,\\n          targetIndex = _ref3.targetIndex;\\n\\n      if (containerSize <= 0) {\\n        return 0;\\n      }\\n\\n      var datum = this.getSizeAndPositionOfCell(targetIndex);\\n      var maxOffset = datum.offset;\\n      var minOffset = maxOffset - containerSize + datum.size;\\n\\n      var idealOffset = void 0;\\n\\n      switch (align) {\\n        case 'start':\\n          idealOffset = maxOffset;\\n          break;\\n        case 'end':\\n          idealOffset = minOffset;\\n          break;\\n        case 'center':\\n          idealOffset = maxOffset - (containerSize - datum.size) / 2;\\n          break;\\n        default:\\n          idealOffset = Math.max(minOffset, Math.min(maxOffset, currentOffset));\\n          break;\\n      }\\n\\n      var totalSize = this.getTotalSize();\\n\\n      return Math.max(0, Math.min(totalSize - containerSize, idealOffset));\\n    }\\n  }, {\\n    key: 'getVisibleCellRange',\\n    value: function getVisibleCellRange(params) {\\n      var containerSize = params.containerSize,\\n          offset = params.offset;\\n\\n\\n      var totalSize = this.getTotalSize();\\n\\n      if (totalSize === 0) {\\n        return {};\\n      }\\n\\n      var maxOffset = offset + containerSize;\\n      var start = this._findNearestCell(offset);\\n\\n      var datum = this.getSizeAndPositionOfCell(start);\\n      offset = datum.offset + datum.size;\\n\\n      var stop = start;\\n\\n      while (offset < maxOffset && stop < this._cellCount - 1) {\\n        stop++;\\n\\n        offset += this.getSizeAndPositionOfCell(stop).size;\\n      }\\n\\n      return {\\n        start: start,\\n        stop: stop\\n      };\\n    }\\n\\n    /**\\n     * Clear all cached values for cells after the specified index.\\n     * This method should be called for any cell that has changed its size.\\n     * It will not immediately perform any calculations; they'll be performed the next time getSizeAndPositionOfCell() is called.\\n     */\\n\\n  }, {\\n    key: 'resetCell',\\n    value: function resetCell(index) {\\n      this._lastMeasuredIndex = Math.min(this._lastMeasuredIndex, index - 1);\\n    }\\n  }, {\\n    key: '_binarySearch',\\n    value: function _binarySearch(high, low, offset) {\\n      while (low <= high) {\\n        var middle = low + Math.floor((high - low) / 2);\\n        var _currentOffset = this.getSizeAndPositionOfCell(middle).offset;\\n\\n        if (_currentOffset === offset) {\\n          return middle;\\n        } else if (_currentOffset < offset) {\\n          low = middle + 1;\\n        } else if (_currentOffset > offset) {\\n          high = middle - 1;\\n        }\\n      }\\n\\n      if (low > 0) {\\n        return low - 1;\\n      } else {\\n        return 0;\\n      }\\n    }\\n  }, {\\n    key: '_exponentialSearch',\\n    value: function _exponentialSearch(index, offset) {\\n      var interval = 1;\\n\\n      while (index < this._cellCount && this.getSizeAndPositionOfCell(index).offset < offset) {\\n        index += interval;\\n        interval *= 2;\\n      }\\n\\n      return this._binarySearch(Math.min(index, this._cellCount - 1), Math.floor(index / 2), offset);\\n    }\\n\\n    /**\\n     * Searches for the cell (index) nearest the specified offset.\\n     *\\n     * If no exact match is found the next lowest cell index will be returned.\\n     * This allows partially visible cells (with offsets just before/above the fold) to be visible.\\n     */\\n\\n  }, {\\n    key: '_findNearestCell',\\n    value: function _findNearestCell(offset) {\\n      if (isNaN(offset)) {\\n        throw Error('Invalid offset ' + offset + ' specified');\\n      }\\n\\n      // Our search algorithms find the nearest match at or below the specified offset.\\n      // So make sure the offset is at least 0 or no match will be found.\\n      offset = Math.max(0, offset);\\n\\n      var lastMeasuredCellSizeAndPosition = this.getSizeAndPositionOfLastMeasuredCell();\\n      var lastMeasuredIndex = Math.max(0, this._lastMeasuredIndex);\\n\\n      if (lastMeasuredCellSizeAndPosition.offset >= offset) {\\n        // If we've already measured cells within this range just use a binary search as it's faster.\\n        return this._binarySearch(lastMeasuredIndex, 0, offset);\\n      } else {\\n        // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\\n        // The exponential search avoids pre-computing sizes for the full set of cells as a binary search would.\\n        // The overall complexity for this approach is O(log n).\\n        return this._exponentialSearch(lastMeasuredIndex, offset);\\n      }\\n    }\\n  }]);\\n  return CellSizeAndPositionManager;\\n}();\\n\\nexports.default = CellSizeAndPositionManager;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"process\",\"require\",\"module\",\"exports\",\"shadow$shims\",\"Object\",\"defineProperty\",\"value\",\"_classCallCheck3\",\"_classCallCheck2\",\"__esModule\",\"default\",\"_createClass3\",\"_createClass2\",\"CellSizeAndPositionManager\",\"_ref\",\"cellCount\",\"cellSizeGetter\",\"estimatedCellSize\",\"_cellSizeAndPositionData\",\"_lastBatchedIndex\",\"_lastMeasuredIndex\",\"_cellSizeGetter\",\"_cellCount\",\"_estimatedCellSize\",\"key\",\"areOffsetsAdjusted\",\"configure\",\"_ref2\",\"getCellCount\",\"getEstimatedCellSize\",\"getLastMeasuredIndex\",\"getOffsetAdjustment\",\"getSizeAndPositionOfCell\",\"index\",\"Error\",\"lastMeasuredCellSizeAndPosition\",\"getSizeAndPositionOfLastMeasuredCell\",\"_offset\",\"offset\",\"size\",\"i\",\"_size\",\"undefined\",\"isNaN\",\"getTotalSize\",\"getUpdatedOffsetForIndex\",\"_ref3\",\"_ref3$align\",\"align\",\"containerSize\",\"currentOffset\",\"datum\",\"targetIndex\",\"maxOffset\",\"minOffset\",\"idealOffset\",\"Math\",\"max\",\"min\",\"totalSize\",\"getVisibleCellRange\",\"params\",\"start\",\"_findNearestCell\",\"stop\",\"resetCell\",\"_binarySearch\",\"high\",\"low\",\"middle\",\"floor\",\"_currentOffset\",\"_exponentialSearch\",\"interval\",\"lastMeasuredIndex\"]\n}\n"]