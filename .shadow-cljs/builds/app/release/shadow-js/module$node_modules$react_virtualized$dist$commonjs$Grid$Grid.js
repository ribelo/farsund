["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/react-virtualized/dist/commonjs/Grid/Grid.js"],"~:js","shadow$provide.module$node_modules$react_virtualized$dist$commonjs$Grid$Grid=function(b,e,a,f,c,m){function d(a){return a&&a.__esModule?a:{default:a}}Object.defineProperty(c,\"__esModule\",{value:!0});c.DEFAULT_SCROLLING_RESET_TIME_INTERVAL=void 0;b=a(\"module$node_modules$babel_runtime$core_js$object$assign\");var k=d(b);b=a(\"module$node_modules$babel_runtime$helpers$extends\");var l=d(b);b=a(\"module$node_modules$babel_runtime$core_js$object$get_prototype_of\");var h=d(b);b=a(\"module$node_modules$babel_runtime$helpers$classCallCheck\");\nvar p=d(b);b=a(\"module$node_modules$babel_runtime$helpers$createClass\");var r=d(b);b=a(\"module$node_modules$babel_runtime$helpers$possibleConstructorReturn\");var q=d(b);b=a(\"module$node_modules$babel_runtime$helpers$inherits\");var g=d(b),n=function(a){if(a&&a.__esModule)return a;var b={};if(null!=a)for(var c in a)Object.prototype.hasOwnProperty.call(a,c)&&(b[c]=a[c]);b.default=a;return b}(a(\"module$node_modules$react$index\"));b=a(\"module$node_modules$classnames$index\");var v=d(b);b=a(\"module$node_modules$react_virtualized$dist$commonjs$Grid$utils$calculateSizeAndPositionDataAndUpdateScrollOffset\");\nvar y=d(b);b=a(\"module$node_modules$react_virtualized$dist$commonjs$Grid$utils$ScalingCellSizeAndPositionManager\");var w=d(b);b=a(\"module$node_modules$react_virtualized$dist$commonjs$utils$createCallbackMemoizer\");var x=d(b),u=a(\"module$node_modules$react_virtualized$dist$commonjs$Grid$defaultOverscanIndicesGetter\");b=d(u);e=a(\"module$node_modules$react_virtualized$dist$commonjs$Grid$utils$updateScrollIndexHelper\");var t=d(e);e=a(\"module$node_modules$react_virtualized$dist$commonjs$Grid$defaultCellRangeRenderer\");\ne=d(e);f=a(\"module$node_modules$dom_helpers$util$scrollbarSize\");f=d(f);m=a(\"module$node_modules$react_lifecycles_compat$react_lifecycles_compat_cjs\");var z=a(\"module$node_modules$react_virtualized$dist$commonjs$utils$requestAnimationTimeout\");a(\"module$node_modules$react_virtualized$dist$commonjs$Grid$types\");a=a(\"module$node_modules$prop_types$index\");d(a);a=c.DEFAULT_SCROLLING_RESET_TIME_INTERVAL=150;var A=function(a){function b(a){(0,p.default)(this,b);var c=(0,q.default)(this,(b.__proto__||(0,\nh.default)(b)).call(this,a));c._onGridRenderedMemoizer=(0,x.default)();c._onScrollMemoizer=(0,x.default)(!1);c._deferredInvalidateColumnIndex=null;c._deferredInvalidateRowIndex=null;c._recomputeScrollLeftFlag=!1;c._recomputeScrollTopFlag=!1;c._horizontalScrollBarSize=0;c._verticalScrollBarSize=0;c._scrollbarPresenceChanged=!1;c._renderedColumnStartIndex=0;c._renderedColumnStopIndex=0;c._renderedRowStartIndex=0;c._renderedRowStopIndex=0;c._styleCache={};c._cellCache={};c._debounceScrollEndedCallback=\nfunction(){c._disablePointerEventsTimeoutId=null;c.setState({isScrolling:!1,needToResetStyleCache:!1})};c._invokeOnGridRenderedHelper=function(){c._onGridRenderedMemoizer({callback:c.props.onSectionRendered,indices:{columnOverscanStartIndex:c._columnStartIndex,columnOverscanStopIndex:c._columnStopIndex,columnStartIndex:c._renderedColumnStartIndex,columnStopIndex:c._renderedColumnStopIndex,rowOverscanStartIndex:c._rowStartIndex,rowOverscanStopIndex:c._rowStopIndex,rowStartIndex:c._renderedRowStartIndex,\nrowStopIndex:c._renderedRowStopIndex}})};c._setScrollingContainerRef=function(a){c._scrollingContainer=a};c._onScroll=function(a){a.target===c._scrollingContainer&&c.handleScrollEvent(a.target)};var d=new w.default({cellCount:a.columnCount,cellSizeGetter:function(c){return b._wrapSizeGetter(a.columnWidth)(c)},estimatedCellSize:b._getEstimatedColumnSize(a)}),e=new w.default({cellCount:a.rowCount,cellSizeGetter:function(c){return b._wrapSizeGetter(a.rowHeight)(c)},estimatedCellSize:b._getEstimatedRowSize(a)});\nc.state={instanceProps:{columnSizeAndPositionManager:d,rowSizeAndPositionManager:e,prevColumnWidth:a.columnWidth,prevRowHeight:a.rowHeight,prevColumnCount:a.columnCount,prevRowCount:a.rowCount,prevIsScrolling:!0===a.isScrolling,prevScrollToColumn:a.scrollToColumn,prevScrollToRow:a.scrollToRow,scrollbarSize:0,scrollbarSizeMeasured:!1},isScrolling:!1,scrollDirectionHorizontal:u.SCROLL_DIRECTION_FORWARD,scrollDirectionVertical:u.SCROLL_DIRECTION_FORWARD,scrollLeft:0,scrollTop:0,scrollPositionChangeReason:null,\nneedToResetStyleCache:!1};0<a.scrollToRow&&(c._initialScrollTop=c._getCalculatedScrollTop(a,c.state));0<a.scrollToColumn&&(c._initialScrollLeft=c._getCalculatedScrollLeft(a,c.state));return c}(0,g.default)(b,a);(0,r.default)(b,[{key:\"getOffsetForCell\",value:function(){var a=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},b=a.alignment;b=void 0===b?this.props.scrollToAlignment:b;var c=a.columnIndex;c=void 0===c?this.props.scrollToColumn:c;a=a.rowIndex;a=void 0===a?this.props.scrollToRow:\na;b=(0,l.default)({},this.props,{scrollToAlignment:b,scrollToColumn:c,scrollToRow:a});return{scrollLeft:this._getCalculatedScrollLeft(b),scrollTop:this._getCalculatedScrollTop(b)}}},{key:\"getTotalRowsHeight\",value:function(){return this.state.instanceProps.rowSizeAndPositionManager.getTotalSize()}},{key:\"getTotalColumnsWidth\",value:function(){return this.state.instanceProps.columnSizeAndPositionManager.getTotalSize()}},{key:\"handleScrollEvent\",value:function(a){var b=a.scrollLeft,c=void 0===b?0:b;\na=a.scrollTop;var d=void 0===a?0:a;if(!(0>d)){this._debounceScrollEnded();var e=this.props;a=e.autoHeight;b=e.autoWidth;var g=e.height,f=e.width,h=this.state.instanceProps,k=h.scrollbarSize;e=h.rowSizeAndPositionManager.getTotalSize();h=h.columnSizeAndPositionManager.getTotalSize();c=Math.min(Math.max(0,h-f+k),c);d=Math.min(Math.max(0,e-g+k),d);if(this.state.scrollLeft!==c||this.state.scrollTop!==d)g={isScrolling:!0,scrollDirectionHorizontal:c!==this.state.scrollLeft?c>this.state.scrollLeft?u.SCROLL_DIRECTION_FORWARD:\nu.SCROLL_DIRECTION_BACKWARD:this.state.scrollDirectionHorizontal,scrollDirectionVertical:d!==this.state.scrollTop?d>this.state.scrollTop?u.SCROLL_DIRECTION_FORWARD:u.SCROLL_DIRECTION_BACKWARD:this.state.scrollDirectionVertical,scrollPositionChangeReason:\"observed\"},a||(g.scrollTop=d),b||(g.scrollLeft=c),g.needToResetStyleCache=!1,this.setState(g);this._invokeOnScrollMemoizer({scrollLeft:c,scrollTop:d,totalColumnsWidth:h,totalRowsHeight:e})}}},{key:\"invalidateCellSizeAfterRender\",value:function(a){var b=\na.columnIndex;a=a.rowIndex;this._deferredInvalidateColumnIndex=\"number\"===typeof this._deferredInvalidateColumnIndex?Math.min(this._deferredInvalidateColumnIndex,b):b;this._deferredInvalidateRowIndex=\"number\"===typeof this._deferredInvalidateRowIndex?Math.min(this._deferredInvalidateRowIndex,a):a}},{key:\"measureAllCells\",value:function(){var a=this.props,b=a.rowCount,c=this.state.instanceProps;c.columnSizeAndPositionManager.getSizeAndPositionOfCell(a.columnCount-1);c.rowSizeAndPositionManager.getSizeAndPositionOfCell(b-\n1)}},{key:\"recomputeGridSize\",value:function(){var a=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},b=a.columnIndex;b=void 0===b?0:b;a=a.rowIndex;a=void 0===a?0:a;var c=this.props,d=c.scrollToColumn;c=c.scrollToRow;var e=this.state.instanceProps;e.columnSizeAndPositionManager.resetCell(b);e.rowSizeAndPositionManager.resetCell(a);this._recomputeScrollLeftFlag=0<=d&&(this.state.scrollDirectionHorizontal===u.SCROLL_DIRECTION_FORWARD?b<=d:b>=d);this._recomputeScrollTopFlag=0<=c&&(this.state.scrollDirectionVertical===\nu.SCROLL_DIRECTION_FORWARD?a<=c:a>=c);this._styleCache={};this._cellCache={};this.forceUpdate()}},{key:\"scrollToCell\",value:function(a){var b=a.columnIndex;a=a.rowIndex;var c=this.props;1<this.props.columnCount&&void 0!==b&&this._updateScrollLeftForScrollToColumn((0,l.default)({},c,{scrollToColumn:b}));void 0!==a&&this._updateScrollTopForScrollToRow((0,l.default)({},c,{scrollToRow:a}))}},{key:\"componentDidMount\",value:function(){var a=this.props,c=a.getScrollbarSize,d=a.height,e=a.scrollLeft,g=a.scrollToColumn,\nf=a.scrollTop,h=a.scrollToRow,k=a.width;a=this.state.instanceProps;this._initialScrollLeft=this._initialScrollTop=0;this._handleInvalidatedGridSize();a.scrollbarSizeMeasured||this.setState(function(a){a=(0,l.default)({},a,{needToResetStyleCache:!1});a.instanceProps.scrollbarSize=c();a.instanceProps.scrollbarSizeMeasured=!0;return a});if(\"number\"===typeof e&&0<=e||\"number\"===typeof f&&0<=f){var t=b._getScrollToPositionStateUpdate({prevState:this.state,scrollLeft:e,scrollTop:f});t&&(t.needToResetStyleCache=\n!1,this.setState(t))}this._scrollingContainer&&(this._scrollingContainer.scrollLeft!==this.state.scrollLeft&&(this._scrollingContainer.scrollLeft=this.state.scrollLeft),this._scrollingContainer.scrollTop!==this.state.scrollTop&&(this._scrollingContainer.scrollTop=this.state.scrollTop));d=0<d&&0<k;0<=g&&d&&this._updateScrollLeftForScrollToColumn();0<=h&&d&&this._updateScrollTopForScrollToRow();this._invokeOnGridRenderedHelper();this._invokeOnScrollMemoizer({scrollLeft:e||0,scrollTop:f||0,totalColumnsWidth:a.columnSizeAndPositionManager.getTotalSize(),\ntotalRowsHeight:a.rowSizeAndPositionManager.getTotalSize()});this._maybeCallOnScrollbarPresenceChange()}},{key:\"componentDidUpdate\",value:function(a,b){var c=this,d=this.props,e=d.autoHeight,g=d.autoWidth,f=d.columnCount,h=d.height,k=d.rowCount,l=d.scrollToAlignment,m=d.scrollToColumn,n=d.scrollToRow,q=d.width,p=this.state;d=p.scrollLeft;var r=p.scrollPositionChangeReason,u=p.scrollTop;p=p.instanceProps;this._handleInvalidatedGridSize();f=0<f&&0===a.columnCount||0<k&&0===a.rowCount;\"requested\"===\nr&&(!g&&0<=d&&(d!==this._scrollingContainer.scrollLeft||f)&&(this._scrollingContainer.scrollLeft=d),!e&&0<=u&&(u!==this._scrollingContainer.scrollTop||f)&&(this._scrollingContainer.scrollTop=u));e=(0===a.width||0===a.height)&&0<h&&0<q;this._recomputeScrollLeftFlag?(this._recomputeScrollLeftFlag=!1,this._updateScrollLeftForScrollToColumn(this.props)):(0,t.default)({cellSizeAndPositionManager:p.columnSizeAndPositionManager,previousCellsCount:a.columnCount,previousCellSize:a.columnWidth,previousScrollToAlignment:a.scrollToAlignment,\npreviousScrollToIndex:a.scrollToColumn,previousSize:a.width,scrollOffset:d,scrollToAlignment:l,scrollToIndex:m,size:q,sizeJustIncreasedFromZero:e,updateScrollIndexCallback:function(){return c._updateScrollLeftForScrollToColumn(c.props)}});this._recomputeScrollTopFlag?(this._recomputeScrollTopFlag=!1,this._updateScrollTopForScrollToRow(this.props)):(0,t.default)({cellSizeAndPositionManager:p.rowSizeAndPositionManager,previousCellsCount:a.rowCount,previousCellSize:a.rowHeight,previousScrollToAlignment:a.scrollToAlignment,\npreviousScrollToIndex:a.scrollToRow,previousSize:a.height,scrollOffset:u,scrollToAlignment:l,scrollToIndex:n,size:h,sizeJustIncreasedFromZero:e,updateScrollIndexCallback:function(){return c._updateScrollTopForScrollToRow(c.props)}});this._invokeOnGridRenderedHelper();if(d!==b.scrollLeft||u!==b.scrollTop)a=p.rowSizeAndPositionManager.getTotalSize(),b=p.columnSizeAndPositionManager.getTotalSize(),this._invokeOnScrollMemoizer({scrollLeft:d,scrollTop:u,totalColumnsWidth:b,totalRowsHeight:a});this._maybeCallOnScrollbarPresenceChange()}},\n{key:\"componentWillUnmount\",value:function(){this._disablePointerEventsTimeoutId&&(0,z.cancelAnimationTimeout)(this._disablePointerEventsTimeoutId)}},{key:\"render\",value:function(){var a=this.props,b=a.autoContainerWidth,c=a.autoHeight,d=a.autoWidth,e=a.className,g=a.containerProps,f=a.containerRole,h=a.containerStyle,k=a.height,t=a.id,m=a.noContentRenderer,q=a.role,p=a.style,r=a.tabIndex;a=a.width;var u=this.state,z=u.instanceProps,A=u.needToResetStyleCache;u=this._isScrolling();c={boxSizing:\"border-box\",\ndirection:\"ltr\",height:c?\"auto\":k,position:\"relative\",width:d?\"auto\":a,WebkitOverflowScrolling:\"touch\",willChange:\"transform\"};A&&(this._styleCache={});this.state.isScrolling||this._resetStyleCache();this._calculateChildrenToRender(this.props,this.state);d=z.columnSizeAndPositionManager.getTotalSize();A=z.rowSizeAndPositionManager.getTotalSize();var x=A>k?z.scrollbarSize:0;z=d>a?z.scrollbarSize:0;if(z!==this._horizontalScrollBarSize||x!==this._verticalScrollBarSize)this._horizontalScrollBarSize=z,\nthis._verticalScrollBarSize=x,this._scrollbarPresenceChanged=!0;c.overflowX=d+x<=a?\"hidden\":\"auto\";c.overflowY=A+z<=k?\"hidden\":\"auto\";z=this._childrenToDisplay;k=0===z.length&&0<k&&0<a;return n.createElement(\"div\",(0,l.default)({ref:this._setScrollingContainerRef},g,{\"aria-label\":this.props[\"aria-label\"],\"aria-readonly\":this.props[\"aria-readonly\"],className:(0,v.default)(\"ReactVirtualized__Grid\",e),id:t,onScroll:this._onScroll,role:q,style:(0,l.default)({},c,p),tabIndex:r}),0<z.length&&n.createElement(\"div\",\n{className:\"ReactVirtualized__Grid__innerScrollContainer\",role:f,style:(0,l.default)({width:b?\"auto\":d,height:A,maxWidth:d,maxHeight:A,overflow:\"hidden\",pointerEvents:u?\"none\":\"\",position:\"relative\"},h)},z),k&&m())}},{key:\"_calculateChildrenToRender\",value:function(){var a=0<arguments.length&&void 0!==arguments[0]?arguments[0]:this.props,b=1<arguments.length&&void 0!==arguments[1]?arguments[1]:this.state,c=a.cellRenderer,d=a.cellRangeRenderer,e=a.columnCount,g=a.deferredMeasurementCache,f=a.height,\nh=a.overscanColumnCount,k=a.overscanIndicesGetter,l=a.overscanRowCount,t=a.rowCount,m=a.width,n=a.isScrollingOptOut,q=b.scrollDirectionHorizontal,p=b.scrollDirectionVertical,r=b.instanceProps,u=0<this._initialScrollTop?this._initialScrollTop:b.scrollTop,z=0<this._initialScrollLeft?this._initialScrollLeft:b.scrollLeft;a=this._isScrolling(a,b);this._childrenToDisplay=[];if(0<f&&0<m){b=r.columnSizeAndPositionManager.getVisibleCellRange({containerSize:m,offset:z});var A=r.rowSizeAndPositionManager.getVisibleCellRange({containerSize:f,\noffset:u});m=r.columnSizeAndPositionManager.getOffsetAdjustment({containerSize:m,offset:z});f=r.rowSizeAndPositionManager.getOffsetAdjustment({containerSize:f,offset:u});this._renderedColumnStartIndex=b.start;this._renderedColumnStopIndex=b.stop;this._renderedRowStartIndex=A.start;this._renderedRowStopIndex=A.stop;h=k({direction:\"horizontal\",cellCount:e,overscanCellsCount:h,scrollDirection:q,startIndex:\"number\"===typeof b.start?b.start:0,stopIndex:\"number\"===typeof b.stop?b.stop:-1});q=k({direction:\"vertical\",\ncellCount:t,overscanCellsCount:l,scrollDirection:p,startIndex:\"number\"===typeof A.start?A.start:0,stopIndex:\"number\"===typeof A.stop?A.stop:-1});k=h.overscanStartIndex;l=h.overscanStopIndex;p=q.overscanStartIndex;h=q.overscanStopIndex;if(g){if(!g.hasFixedHeight())for(q=p;q<=h;q++)if(!g.has(q,0)){k=0;l=e-1;break}if(!g.hasFixedWidth())for(e=k;e<=l;e++)if(!g.has(0,e)){p=0;h=t-1;break}}this._childrenToDisplay=d({cellCache:this._cellCache,cellRenderer:c,columnSizeAndPositionManager:r.columnSizeAndPositionManager,\ncolumnStartIndex:k,columnStopIndex:l,deferredMeasurementCache:g,horizontalOffsetAdjustment:m,isScrolling:a,isScrollingOptOut:n,parent:this,rowSizeAndPositionManager:r.rowSizeAndPositionManager,rowStartIndex:p,rowStopIndex:h,scrollLeft:z,scrollTop:u,styleCache:this._styleCache,verticalOffsetAdjustment:f,visibleColumnIndices:b,visibleRowIndices:A});this._columnStartIndex=k;this._columnStopIndex=l;this._rowStartIndex=p;this._rowStopIndex=h}}},{key:\"_debounceScrollEnded\",value:function(){var a=this.props.scrollingResetTimeInterval;\nthis._disablePointerEventsTimeoutId&&(0,z.cancelAnimationTimeout)(this._disablePointerEventsTimeoutId);this._disablePointerEventsTimeoutId=(0,z.requestAnimationTimeout)(this._debounceScrollEndedCallback,a)}},{key:\"_handleInvalidatedGridSize\",value:function(){if(\"number\"===typeof this._deferredInvalidateColumnIndex&&\"number\"===typeof this._deferredInvalidateRowIndex){var a=this._deferredInvalidateColumnIndex,b=this._deferredInvalidateRowIndex;this._deferredInvalidateRowIndex=this._deferredInvalidateColumnIndex=\nnull;this.recomputeGridSize({columnIndex:a,rowIndex:b})}}},{key:\"_invokeOnScrollMemoizer\",value:function(a){var b=this,c=a.totalColumnsWidth,d=a.totalRowsHeight;this._onScrollMemoizer({callback:function(a){var e=b.props,g=e.onScroll;g({clientHeight:e.height,clientWidth:e.width,scrollHeight:d,scrollLeft:a.scrollLeft,scrollTop:a.scrollTop,scrollWidth:c})},indices:{scrollLeft:a.scrollLeft,scrollTop:a.scrollTop}})}},{key:\"_isScrolling\",value:function(){var a=0<arguments.length&&void 0!==arguments[0]?\narguments[0]:this.props,b=1<arguments.length&&void 0!==arguments[1]?arguments[1]:this.state;return Object.hasOwnProperty.call(a,\"isScrolling\")?!!a.isScrolling:!!b.isScrolling}},{key:\"_maybeCallOnScrollbarPresenceChange\",value:function(){if(this._scrollbarPresenceChanged){var a=this.props.onScrollbarPresenceChange;this._scrollbarPresenceChanged=!1;a({horizontal:0<this._horizontalScrollBarSize,size:this.state.instanceProps.scrollbarSize,vertical:0<this._verticalScrollBarSize})}}},{key:\"scrollToPosition\",\nvalue:function(a){if(a=b._getScrollToPositionStateUpdate({prevState:this.state,scrollLeft:a.scrollLeft,scrollTop:a.scrollTop}))a.needToResetStyleCache=!1,this.setState(a)}},{key:\"_getCalculatedScrollLeft\",value:function(){return b._getCalculatedScrollLeft(0<arguments.length&&void 0!==arguments[0]?arguments[0]:this.props,1<arguments.length&&void 0!==arguments[1]?arguments[1]:this.state)}},{key:\"_updateScrollLeftForScrollToColumn\",value:function(){var a=b._getScrollLeftForScrollToColumnStateUpdate(0<\narguments.length&&void 0!==arguments[0]?arguments[0]:this.props,1<arguments.length&&void 0!==arguments[1]?arguments[1]:this.state);a&&(a.needToResetStyleCache=!1,this.setState(a))}},{key:\"_getCalculatedScrollTop\",value:function(){return b._getCalculatedScrollTop(0<arguments.length&&void 0!==arguments[0]?arguments[0]:this.props,1<arguments.length&&void 0!==arguments[1]?arguments[1]:this.state)}},{key:\"_resetStyleCache\",value:function(){var a=this._styleCache,b=this._cellCache,c=this.props.isScrollingOptOut;\nthis._cellCache={};this._styleCache={};for(var d=this._rowStartIndex;d<=this._rowStopIndex;d++)for(var e=this._columnStartIndex;e<=this._columnStopIndex;e++){var g=d+\"-\"+e;this._styleCache[g]=a[g];c&&(this._cellCache[g]=b[g])}}},{key:\"_updateScrollTopForScrollToRow\",value:function(){var a=b._getScrollTopForScrollToRowStateUpdate(0<arguments.length&&void 0!==arguments[0]?arguments[0]:this.props,1<arguments.length&&void 0!==arguments[1]?arguments[1]:this.state);a&&(a.needToResetStyleCache=!1,this.setState(a))}}],\n[{key:\"getDerivedStateFromProps\",value:function(a,c){var d={};0===a.columnCount&&0!==c.scrollLeft||0===a.rowCount&&0!==c.scrollTop?(d.scrollLeft=0,d.scrollTop=0):(a.scrollLeft!==c.scrollLeft&&0>a.scrollToColumn||a.scrollTop!==c.scrollTop&&0>a.scrollToRow)&&(0,k.default)(d,b._getScrollToPositionStateUpdate({prevState:c,scrollLeft:a.scrollLeft,scrollTop:a.scrollTop}));var e=c.instanceProps;d.needToResetStyleCache=!1;if(a.columnWidth!==e.prevColumnWidth||a.rowHeight!==e.prevRowHeight)d.needToResetStyleCache=\n!0;e.columnSizeAndPositionManager.configure({cellCount:a.columnCount,estimatedCellSize:b._getEstimatedColumnSize(a),cellSizeGetter:b._wrapSizeGetter(a.columnWidth)});e.rowSizeAndPositionManager.configure({cellCount:a.rowCount,estimatedCellSize:b._getEstimatedRowSize(a),cellSizeGetter:b._wrapSizeGetter(a.rowHeight)});if(0===e.prevColumnCount||0===e.prevRowCount)e.prevColumnCount=0,e.prevRowCount=0;a.autoHeight&&!1===a.isScrolling&&!0===e.prevIsScrolling&&(0,k.default)(d,{isScrolling:!1});var g=void 0,\nf=void 0;(0,y.default)({cellCount:e.prevColumnCount,cellSize:\"number\"===typeof e.prevColumnWidth?e.prevColumnWidth:null,computeMetadataCallback:function(){return e.columnSizeAndPositionManager.resetCell(0)},computeMetadataCallbackProps:a,nextCellsCount:a.columnCount,nextCellSize:\"number\"===typeof a.columnWidth?a.columnWidth:null,nextScrollToIndex:a.scrollToColumn,scrollToIndex:e.prevScrollToColumn,updateScrollOffsetForScrollToIndex:function(){g=b._getScrollLeftForScrollToColumnStateUpdate(a,c)}});\n(0,y.default)({cellCount:e.prevRowCount,cellSize:\"number\"===typeof e.prevRowHeight?e.prevRowHeight:null,computeMetadataCallback:function(){return e.rowSizeAndPositionManager.resetCell(0)},computeMetadataCallbackProps:a,nextCellsCount:a.rowCount,nextCellSize:\"number\"===typeof a.rowHeight?a.rowHeight:null,nextScrollToIndex:a.scrollToRow,scrollToIndex:e.prevScrollToRow,updateScrollOffsetForScrollToIndex:function(){f=b._getScrollTopForScrollToRowStateUpdate(a,c)}});e.prevColumnCount=a.columnCount;e.prevColumnWidth=\na.columnWidth;e.prevIsScrolling=!0===a.isScrolling;e.prevRowCount=a.rowCount;e.prevRowHeight=a.rowHeight;e.prevScrollToColumn=a.scrollToColumn;e.prevScrollToRow=a.scrollToRow;e.scrollbarSize=a.getScrollbarSize();void 0===e.scrollbarSize?(e.scrollbarSizeMeasured=!1,e.scrollbarSize=0):e.scrollbarSizeMeasured=!0;d.instanceProps=e;return(0,l.default)({},d,g,f)}},{key:\"_getEstimatedColumnSize\",value:function(a){return\"number\"===typeof a.columnWidth?a.columnWidth:a.estimatedColumnSize}},{key:\"_getEstimatedRowSize\",\nvalue:function(a){return\"number\"===typeof a.rowHeight?a.rowHeight:a.estimatedRowSize}},{key:\"_getScrollToPositionStateUpdate\",value:function(a){var b=a.prevState,c=a.scrollLeft;a=a.scrollTop;var d={scrollPositionChangeReason:\"requested\"};\"number\"===typeof c&&0<=c&&(d.scrollDirectionHorizontal=c>b.scrollLeft?u.SCROLL_DIRECTION_FORWARD:u.SCROLL_DIRECTION_BACKWARD,d.scrollLeft=c);\"number\"===typeof a&&0<=a&&(d.scrollDirectionVertical=a>b.scrollTop?u.SCROLL_DIRECTION_FORWARD:u.SCROLL_DIRECTION_BACKWARD,\nd.scrollTop=a);return\"number\"===typeof c&&0<=c&&c!==b.scrollLeft||\"number\"===typeof a&&0<=a&&a!==b.scrollTop?d:null}},{key:\"_wrapSizeGetter\",value:function(a){return\"function\"===typeof a?a:function(){return a}}},{key:\"_getCalculatedScrollLeft\",value:function(a,b){var c=a.columnCount,d=a.height,e=a.scrollToAlignment,g=a.scrollToColumn;a=a.width;var f=b.scrollLeft;b=b.instanceProps;return 0<c?(--c,g=0>g?c:Math.min(c,g),c=b.rowSizeAndPositionManager.getTotalSize(),b.columnSizeAndPositionManager.getUpdatedOffsetForIndex({align:e,\ncontainerSize:a-(b.scrollbarSizeMeasured&&c>d?b.scrollbarSize:0),currentOffset:f,targetIndex:g})):0}},{key:\"_getScrollLeftForScrollToColumnStateUpdate\",value:function(a,c){var d=c.scrollLeft;a=b._getCalculatedScrollLeft(a,c);return\"number\"===typeof a&&0<=a&&d!==a?b._getScrollToPositionStateUpdate({prevState:c,scrollLeft:a,scrollTop:-1}):null}},{key:\"_getCalculatedScrollTop\",value:function(a,b){var c=a.height,d=a.rowCount,e=a.scrollToAlignment,g=a.scrollToRow;a=a.width;var f=b.scrollTop;b=b.instanceProps;\nreturn 0<d?(--d,g=0>g?d:Math.min(d,g),d=b.columnSizeAndPositionManager.getTotalSize(),b.rowSizeAndPositionManager.getUpdatedOffsetForIndex({align:e,containerSize:c-(b.scrollbarSizeMeasured&&d>a?b.scrollbarSize:0),currentOffset:f,targetIndex:g})):0}},{key:\"_getScrollTopForScrollToRowStateUpdate\",value:function(a,c){var d=c.scrollTop;a=b._getCalculatedScrollTop(a,c);return\"number\"===typeof a&&0<=a&&d!==a?b._getScrollToPositionStateUpdate({prevState:c,scrollLeft:-1,scrollTop:a}):null}}]);return b}(n.PureComponent);\nA.defaultProps={\"aria-label\":\"grid\",\"aria-readonly\":!0,autoContainerWidth:!1,autoHeight:!1,autoWidth:!1,cellRangeRenderer:e.default,containerRole:\"rowgroup\",containerStyle:{},estimatedColumnSize:100,estimatedRowSize:30,getScrollbarSize:f.default,noContentRenderer:function(){return null},onScroll:function(){},onScrollbarPresenceChange:function(){},onSectionRendered:function(){},overscanColumnCount:0,overscanIndicesGetter:b.default,overscanRowCount:10,role:\"grid\",scrollingResetTimeInterval:a,scrollToAlignment:\"auto\",\nscrollToColumn:-1,scrollToRow:-1,style:{},tabIndex:0,isScrollingOptOut:!1};A.propTypes=null;(0,m.polyfill)(A);c.default=A}","~:source","shadow$provide[\"module$node_modules$react_virtualized$dist$commonjs$Grid$Grid\"] = function(global,process,require,module,exports,shadow$shims) {\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DEFAULT_SCROLLING_RESET_TIME_INTERVAL = undefined;\n\nvar _assign = require('babel-runtime/core-js/object/assign');\n\nvar _assign2 = _interopRequireDefault(_assign);\n\nvar _extends2 = require('babel-runtime/helpers/extends');\n\nvar _extends3 = _interopRequireDefault(_extends2);\n\nvar _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = require('babel-runtime/helpers/inherits');\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _react = require('react');\n\nvar React = _interopRequireWildcard(_react);\n\nvar _classnames = require('classnames');\n\nvar _classnames2 = _interopRequireDefault(_classnames);\n\nvar _calculateSizeAndPositionDataAndUpdateScrollOffset = require('./utils/calculateSizeAndPositionDataAndUpdateScrollOffset');\n\nvar _calculateSizeAndPositionDataAndUpdateScrollOffset2 = _interopRequireDefault(_calculateSizeAndPositionDataAndUpdateScrollOffset);\n\nvar _ScalingCellSizeAndPositionManager = require('./utils/ScalingCellSizeAndPositionManager');\n\nvar _ScalingCellSizeAndPositionManager2 = _interopRequireDefault(_ScalingCellSizeAndPositionManager);\n\nvar _createCallbackMemoizer = require('../utils/createCallbackMemoizer');\n\nvar _createCallbackMemoizer2 = _interopRequireDefault(_createCallbackMemoizer);\n\nvar _defaultOverscanIndicesGetter = require('./defaultOverscanIndicesGetter');\n\nvar _defaultOverscanIndicesGetter2 = _interopRequireDefault(_defaultOverscanIndicesGetter);\n\nvar _updateScrollIndexHelper = require('./utils/updateScrollIndexHelper');\n\nvar _updateScrollIndexHelper2 = _interopRequireDefault(_updateScrollIndexHelper);\n\nvar _defaultCellRangeRenderer = require('./defaultCellRangeRenderer');\n\nvar _defaultCellRangeRenderer2 = _interopRequireDefault(_defaultCellRangeRenderer);\n\nvar _scrollbarSize = require('dom-helpers/util/scrollbarSize');\n\nvar _scrollbarSize2 = _interopRequireDefault(_scrollbarSize);\n\nvar _reactLifecyclesCompat = require('react-lifecycles-compat');\n\nvar _requestAnimationTimeout = require('../utils/requestAnimationTimeout');\n\nvar _types = require('./types');\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Specifies the number of milliseconds during which to disable pointer events while a scroll is in progress.\n * This improves performance and makes scrolling smoother.\n */\nvar DEFAULT_SCROLLING_RESET_TIME_INTERVAL = exports.DEFAULT_SCROLLING_RESET_TIME_INTERVAL = 150;\n\n/**\n * Controls whether the Grid updates the DOM element's scrollLeft/scrollTop based on the current state or just observes it.\n * This prevents Grid from interrupting mouse-wheel animations (see issue #2).\n */\n\n\nvar SCROLL_POSITION_CHANGE_REASONS = {\n  OBSERVED: 'observed',\n  REQUESTED: 'requested'\n};\n\nvar renderNull = function renderNull() {\n  return null;\n};\n\n/**\n * Renders tabular data with virtualization along the vertical and horizontal axes.\n * Row heights and column widths must be known ahead of time and specified as properties.\n */\nvar Grid = function (_React$PureComponent) {\n  (0, _inherits3.default)(Grid, _React$PureComponent);\n\n  // Invokes onSectionRendered callback only when start/stop row or column indices change\n  function Grid(props) {\n    (0, _classCallCheck3.default)(this, Grid);\n\n    var _this = (0, _possibleConstructorReturn3.default)(this, (Grid.__proto__ || (0, _getPrototypeOf2.default)(Grid)).call(this, props));\n\n    _this._onGridRenderedMemoizer = (0, _createCallbackMemoizer2.default)();\n    _this._onScrollMemoizer = (0, _createCallbackMemoizer2.default)(false);\n    _this._deferredInvalidateColumnIndex = null;\n    _this._deferredInvalidateRowIndex = null;\n    _this._recomputeScrollLeftFlag = false;\n    _this._recomputeScrollTopFlag = false;\n    _this._horizontalScrollBarSize = 0;\n    _this._verticalScrollBarSize = 0;\n    _this._scrollbarPresenceChanged = false;\n    _this._renderedColumnStartIndex = 0;\n    _this._renderedColumnStopIndex = 0;\n    _this._renderedRowStartIndex = 0;\n    _this._renderedRowStopIndex = 0;\n    _this._styleCache = {};\n    _this._cellCache = {};\n\n    _this._debounceScrollEndedCallback = function () {\n      _this._disablePointerEventsTimeoutId = null;\n      // isScrolling is used to determine if we reset styleCache\n      _this.setState({\n        isScrolling: false,\n        needToResetStyleCache: false\n      });\n    };\n\n    _this._invokeOnGridRenderedHelper = function () {\n      var onSectionRendered = _this.props.onSectionRendered;\n\n\n      _this._onGridRenderedMemoizer({\n        callback: onSectionRendered,\n        indices: {\n          columnOverscanStartIndex: _this._columnStartIndex,\n          columnOverscanStopIndex: _this._columnStopIndex,\n          columnStartIndex: _this._renderedColumnStartIndex,\n          columnStopIndex: _this._renderedColumnStopIndex,\n          rowOverscanStartIndex: _this._rowStartIndex,\n          rowOverscanStopIndex: _this._rowStopIndex,\n          rowStartIndex: _this._renderedRowStartIndex,\n          rowStopIndex: _this._renderedRowStopIndex\n        }\n      });\n    };\n\n    _this._setScrollingContainerRef = function (ref) {\n      _this._scrollingContainer = ref;\n    };\n\n    _this._onScroll = function (event) {\n      // In certain edge-cases React dispatches an onScroll event with an invalid target.scrollLeft / target.scrollTop.\n      // This invalid event can be detected by comparing event.target to this component's scrollable DOM element.\n      // See issue #404 for more information.\n      if (event.target === _this._scrollingContainer) {\n        _this.handleScrollEvent(event.target);\n      }\n    };\n\n    var columnSizeAndPositionManager = new _ScalingCellSizeAndPositionManager2.default({\n      cellCount: props.columnCount,\n      cellSizeGetter: function cellSizeGetter(params) {\n        return Grid._wrapSizeGetter(props.columnWidth)(params);\n      },\n      estimatedCellSize: Grid._getEstimatedColumnSize(props)\n    });\n    var rowSizeAndPositionManager = new _ScalingCellSizeAndPositionManager2.default({\n      cellCount: props.rowCount,\n      cellSizeGetter: function cellSizeGetter(params) {\n        return Grid._wrapSizeGetter(props.rowHeight)(params);\n      },\n      estimatedCellSize: Grid._getEstimatedRowSize(props)\n    });\n\n    _this.state = {\n      instanceProps: {\n        columnSizeAndPositionManager: columnSizeAndPositionManager,\n        rowSizeAndPositionManager: rowSizeAndPositionManager,\n\n        prevColumnWidth: props.columnWidth,\n        prevRowHeight: props.rowHeight,\n        prevColumnCount: props.columnCount,\n        prevRowCount: props.rowCount,\n        prevIsScrolling: props.isScrolling === true,\n        prevScrollToColumn: props.scrollToColumn,\n        prevScrollToRow: props.scrollToRow,\n\n        scrollbarSize: 0,\n        scrollbarSizeMeasured: false\n      },\n      isScrolling: false,\n      scrollDirectionHorizontal: _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD,\n      scrollDirectionVertical: _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD,\n      scrollLeft: 0,\n      scrollTop: 0,\n      scrollPositionChangeReason: null,\n\n      needToResetStyleCache: false\n    };\n\n    if (props.scrollToRow > 0) {\n      _this._initialScrollTop = _this._getCalculatedScrollTop(props, _this.state);\n    }\n    if (props.scrollToColumn > 0) {\n      _this._initialScrollLeft = _this._getCalculatedScrollLeft(props, _this.state);\n    }\n    return _this;\n  }\n\n  /**\n   * Gets offsets for a given cell and alignment.\n   */\n\n\n  (0, _createClass3.default)(Grid, [{\n    key: 'getOffsetForCell',\n    value: function getOffsetForCell() {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref$alignment = _ref.alignment,\n          alignment = _ref$alignment === undefined ? this.props.scrollToAlignment : _ref$alignment,\n          _ref$columnIndex = _ref.columnIndex,\n          columnIndex = _ref$columnIndex === undefined ? this.props.scrollToColumn : _ref$columnIndex,\n          _ref$rowIndex = _ref.rowIndex,\n          rowIndex = _ref$rowIndex === undefined ? this.props.scrollToRow : _ref$rowIndex;\n\n      var offsetProps = (0, _extends3.default)({}, this.props, {\n        scrollToAlignment: alignment,\n        scrollToColumn: columnIndex,\n        scrollToRow: rowIndex\n      });\n\n      return {\n        scrollLeft: this._getCalculatedScrollLeft(offsetProps),\n        scrollTop: this._getCalculatedScrollTop(offsetProps)\n      };\n    }\n\n    /**\n     * Gets estimated total rows' height.\n     */\n\n  }, {\n    key: 'getTotalRowsHeight',\n    value: function getTotalRowsHeight() {\n      return this.state.instanceProps.rowSizeAndPositionManager.getTotalSize();\n    }\n\n    /**\n     * Gets estimated total columns' width.\n     */\n\n  }, {\n    key: 'getTotalColumnsWidth',\n    value: function getTotalColumnsWidth() {\n      return this.state.instanceProps.columnSizeAndPositionManager.getTotalSize();\n    }\n\n    /**\n     * This method handles a scroll event originating from an external scroll control.\n     * It's an advanced method and should probably not be used unless you're implementing a custom scroll-bar solution.\n     */\n\n  }, {\n    key: 'handleScrollEvent',\n    value: function handleScrollEvent(_ref2) {\n      var _ref2$scrollLeft = _ref2.scrollLeft,\n          scrollLeftParam = _ref2$scrollLeft === undefined ? 0 : _ref2$scrollLeft,\n          _ref2$scrollTop = _ref2.scrollTop,\n          scrollTopParam = _ref2$scrollTop === undefined ? 0 : _ref2$scrollTop;\n\n      // On iOS, we can arrive at negative offsets by swiping past the start.\n      // To prevent flicker here, we make playing in the negative offset zone cause nothing to happen.\n      if (scrollTopParam < 0) {\n        return;\n      }\n\n      // Prevent pointer events from interrupting a smooth scroll\n      this._debounceScrollEnded();\n\n      var _props = this.props,\n          autoHeight = _props.autoHeight,\n          autoWidth = _props.autoWidth,\n          height = _props.height,\n          width = _props.width;\n      var instanceProps = this.state.instanceProps;\n\n      // When this component is shrunk drastically, React dispatches a series of back-to-back scroll events,\n      // Gradually converging on a scrollTop that is within the bounds of the new, smaller height.\n      // This causes a series of rapid renders that is slow for long lists.\n      // We can avoid that by doing some simple bounds checking to ensure that scroll offsets never exceed their bounds.\n\n      var scrollbarSize = instanceProps.scrollbarSize;\n      var totalRowsHeight = instanceProps.rowSizeAndPositionManager.getTotalSize();\n      var totalColumnsWidth = instanceProps.columnSizeAndPositionManager.getTotalSize();\n      var scrollLeft = Math.min(Math.max(0, totalColumnsWidth - width + scrollbarSize), scrollLeftParam);\n      var scrollTop = Math.min(Math.max(0, totalRowsHeight - height + scrollbarSize), scrollTopParam);\n\n      // Certain devices (like Apple touchpad) rapid-fire duplicate events.\n      // Don't force a re-render if this is the case.\n      // The mouse may move faster then the animation frame does.\n      // Use requestAnimationFrame to avoid over-updating.\n      if (this.state.scrollLeft !== scrollLeft || this.state.scrollTop !== scrollTop) {\n        // Track scrolling direction so we can more efficiently overscan rows to reduce empty space around the edges while scrolling.\n        // Don't change direction for an axis unless scroll offset has changed.\n        var _scrollDirectionHorizontal = scrollLeft !== this.state.scrollLeft ? scrollLeft > this.state.scrollLeft ? _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD : _defaultOverscanIndicesGetter.SCROLL_DIRECTION_BACKWARD : this.state.scrollDirectionHorizontal;\n        var _scrollDirectionVertical = scrollTop !== this.state.scrollTop ? scrollTop > this.state.scrollTop ? _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD : _defaultOverscanIndicesGetter.SCROLL_DIRECTION_BACKWARD : this.state.scrollDirectionVertical;\n\n        var newState = {\n          isScrolling: true,\n          scrollDirectionHorizontal: _scrollDirectionHorizontal,\n          scrollDirectionVertical: _scrollDirectionVertical,\n          scrollPositionChangeReason: SCROLL_POSITION_CHANGE_REASONS.OBSERVED\n        };\n\n        if (!autoHeight) {\n          newState.scrollTop = scrollTop;\n        }\n\n        if (!autoWidth) {\n          newState.scrollLeft = scrollLeft;\n        }\n\n        newState.needToResetStyleCache = false;\n        this.setState(newState);\n      }\n\n      this._invokeOnScrollMemoizer({\n        scrollLeft: scrollLeft,\n        scrollTop: scrollTop,\n        totalColumnsWidth: totalColumnsWidth,\n        totalRowsHeight: totalRowsHeight\n      });\n    }\n\n    /**\n     * Invalidate Grid size and recompute visible cells.\n     * This is a deferred wrapper for recomputeGridSize().\n     * It sets a flag to be evaluated on cDM/cDU to avoid unnecessary renders.\n     * This method is intended for advanced use-cases like CellMeasurer.\n     */\n    // @TODO (bvaughn) Add automated test coverage for this.\n\n  }, {\n    key: 'invalidateCellSizeAfterRender',\n    value: function invalidateCellSizeAfterRender(_ref3) {\n      var columnIndex = _ref3.columnIndex,\n          rowIndex = _ref3.rowIndex;\n\n      this._deferredInvalidateColumnIndex = typeof this._deferredInvalidateColumnIndex === 'number' ? Math.min(this._deferredInvalidateColumnIndex, columnIndex) : columnIndex;\n      this._deferredInvalidateRowIndex = typeof this._deferredInvalidateRowIndex === 'number' ? Math.min(this._deferredInvalidateRowIndex, rowIndex) : rowIndex;\n    }\n\n    /**\n     * Pre-measure all columns and rows in a Grid.\n     * Typically cells are only measured as needed and estimated sizes are used for cells that have not yet been measured.\n     * This method ensures that the next call to getTotalSize() returns an exact size (as opposed to just an estimated one).\n     */\n\n  }, {\n    key: 'measureAllCells',\n    value: function measureAllCells() {\n      var _props2 = this.props,\n          columnCount = _props2.columnCount,\n          rowCount = _props2.rowCount;\n      var instanceProps = this.state.instanceProps;\n\n      instanceProps.columnSizeAndPositionManager.getSizeAndPositionOfCell(columnCount - 1);\n      instanceProps.rowSizeAndPositionManager.getSizeAndPositionOfCell(rowCount - 1);\n    }\n\n    /**\n     * Forced recompute of row heights and column widths.\n     * This function should be called if dynamic column or row sizes have changed but nothing else has.\n     * Since Grid only receives :columnCount and :rowCount it has no way of detecting when the underlying data changes.\n     */\n\n  }, {\n    key: 'recomputeGridSize',\n    value: function recomputeGridSize() {\n      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref4$columnIndex = _ref4.columnIndex,\n          columnIndex = _ref4$columnIndex === undefined ? 0 : _ref4$columnIndex,\n          _ref4$rowIndex = _ref4.rowIndex,\n          rowIndex = _ref4$rowIndex === undefined ? 0 : _ref4$rowIndex;\n\n      var _props3 = this.props,\n          scrollToColumn = _props3.scrollToColumn,\n          scrollToRow = _props3.scrollToRow;\n      var instanceProps = this.state.instanceProps;\n\n\n      instanceProps.columnSizeAndPositionManager.resetCell(columnIndex);\n      instanceProps.rowSizeAndPositionManager.resetCell(rowIndex);\n\n      // Cell sizes may be determined by a function property.\n      // In this case the cDU handler can't know if they changed.\n      // Store this flag to let the next cDU pass know it needs to recompute the scroll offset.\n      this._recomputeScrollLeftFlag = scrollToColumn >= 0 && (this.state.scrollDirectionHorizontal === _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD ? columnIndex <= scrollToColumn : columnIndex >= scrollToColumn);\n      this._recomputeScrollTopFlag = scrollToRow >= 0 && (this.state.scrollDirectionVertical === _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD ? rowIndex <= scrollToRow : rowIndex >= scrollToRow);\n\n      // Clear cell cache in case we are scrolling;\n      // Invalid row heights likely mean invalid cached content as well.\n      this._styleCache = {};\n      this._cellCache = {};\n\n      this.forceUpdate();\n    }\n\n    /**\n     * Ensure column and row are visible.\n     */\n\n  }, {\n    key: 'scrollToCell',\n    value: function scrollToCell(_ref5) {\n      var columnIndex = _ref5.columnIndex,\n          rowIndex = _ref5.rowIndex;\n      var columnCount = this.props.columnCount;\n\n\n      var props = this.props;\n\n      // Don't adjust scroll offset for single-column grids (eg List, Table).\n      // This can cause a funky scroll offset because of the vertical scrollbar width.\n      if (columnCount > 1 && columnIndex !== undefined) {\n        this._updateScrollLeftForScrollToColumn((0, _extends3.default)({}, props, {\n          scrollToColumn: columnIndex\n        }));\n      }\n\n      if (rowIndex !== undefined) {\n        this._updateScrollTopForScrollToRow((0, _extends3.default)({}, props, {\n          scrollToRow: rowIndex\n        }));\n      }\n    }\n  }, {\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      var _props4 = this.props,\n          getScrollbarSize = _props4.getScrollbarSize,\n          height = _props4.height,\n          scrollLeft = _props4.scrollLeft,\n          scrollToColumn = _props4.scrollToColumn,\n          scrollTop = _props4.scrollTop,\n          scrollToRow = _props4.scrollToRow,\n          width = _props4.width;\n      var instanceProps = this.state.instanceProps;\n\n      // Reset initial offsets to be ignored in browser\n\n      this._initialScrollTop = 0;\n      this._initialScrollLeft = 0;\n\n      // If cell sizes have been invalidated (eg we are using CellMeasurer) then reset cached positions.\n      // We must do this at the start of the method as we may calculate and update scroll position below.\n      this._handleInvalidatedGridSize();\n\n      // If this component was first rendered server-side, scrollbar size will be undefined.\n      // In that event we need to remeasure.\n      if (!instanceProps.scrollbarSizeMeasured) {\n        this.setState(function (prevState) {\n          var stateUpdate = (0, _extends3.default)({}, prevState, { needToResetStyleCache: false });\n          stateUpdate.instanceProps.scrollbarSize = getScrollbarSize();\n          stateUpdate.instanceProps.scrollbarSizeMeasured = true;\n          return stateUpdate;\n        });\n      }\n\n      if (typeof scrollLeft === 'number' && scrollLeft >= 0 || typeof scrollTop === 'number' && scrollTop >= 0) {\n        var stateUpdate = Grid._getScrollToPositionStateUpdate({\n          prevState: this.state,\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop\n        });\n        if (stateUpdate) {\n          stateUpdate.needToResetStyleCache = false;\n          this.setState(stateUpdate);\n        }\n      }\n\n      // refs don't work in `react-test-renderer`\n      if (this._scrollingContainer) {\n        // setting the ref's scrollLeft and scrollTop.\n        // Somehow in MultiGrid the main grid doesn't trigger a update on mount.\n        if (this._scrollingContainer.scrollLeft !== this.state.scrollLeft) {\n          this._scrollingContainer.scrollLeft = this.state.scrollLeft;\n        }\n        if (this._scrollingContainer.scrollTop !== this.state.scrollTop) {\n          this._scrollingContainer.scrollTop = this.state.scrollTop;\n        }\n      }\n\n      // Don't update scroll offset if the size is 0; we don't render any cells in this case.\n      // Setting a state may cause us to later thing we've updated the offce when we haven't.\n      var sizeIsBiggerThanZero = height > 0 && width > 0;\n      if (scrollToColumn >= 0 && sizeIsBiggerThanZero) {\n        this._updateScrollLeftForScrollToColumn();\n      }\n      if (scrollToRow >= 0 && sizeIsBiggerThanZero) {\n        this._updateScrollTopForScrollToRow();\n      }\n\n      // Update onRowsRendered callback\n      this._invokeOnGridRenderedHelper();\n\n      // Initialize onScroll callback\n      this._invokeOnScrollMemoizer({\n        scrollLeft: scrollLeft || 0,\n        scrollTop: scrollTop || 0,\n        totalColumnsWidth: instanceProps.columnSizeAndPositionManager.getTotalSize(),\n        totalRowsHeight: instanceProps.rowSizeAndPositionManager.getTotalSize()\n      });\n\n      this._maybeCallOnScrollbarPresenceChange();\n    }\n\n    /**\n     * @private\n     * This method updates scrollLeft/scrollTop in state for the following conditions:\n     * 1) New scroll-to-cell props have been set\n     */\n\n  }, {\n    key: 'componentDidUpdate',\n    value: function componentDidUpdate(prevProps, prevState) {\n      var _this2 = this;\n\n      var _props5 = this.props,\n          autoHeight = _props5.autoHeight,\n          autoWidth = _props5.autoWidth,\n          columnCount = _props5.columnCount,\n          height = _props5.height,\n          rowCount = _props5.rowCount,\n          scrollToAlignment = _props5.scrollToAlignment,\n          scrollToColumn = _props5.scrollToColumn,\n          scrollToRow = _props5.scrollToRow,\n          width = _props5.width;\n      var _state = this.state,\n          scrollLeft = _state.scrollLeft,\n          scrollPositionChangeReason = _state.scrollPositionChangeReason,\n          scrollTop = _state.scrollTop,\n          instanceProps = _state.instanceProps;\n      // If cell sizes have been invalidated (eg we are using CellMeasurer) then reset cached positions.\n      // We must do this at the start of the method as we may calculate and update scroll position below.\n\n      this._handleInvalidatedGridSize();\n\n      // Handle edge case where column or row count has only just increased over 0.\n      // In this case we may have to restore a previously-specified scroll offset.\n      // For more info see bvaughn/react-virtualized/issues/218\n      var columnOrRowCountJustIncreasedFromZero = columnCount > 0 && prevProps.columnCount === 0 || rowCount > 0 && prevProps.rowCount === 0;\n\n      // Make sure requested changes to :scrollLeft or :scrollTop get applied.\n      // Assigning to scrollLeft/scrollTop tells the browser to interrupt any running scroll animations,\n      // And to discard any pending async changes to the scroll position that may have happened in the meantime (e.g. on a separate scrolling thread).\n      // So we only set these when we require an adjustment of the scroll position.\n      // See issue #2 for more information.\n      if (scrollPositionChangeReason === SCROLL_POSITION_CHANGE_REASONS.REQUESTED) {\n        // @TRICKY :autoHeight and :autoWidth properties instructs Grid to leave :scrollTop and :scrollLeft management to an external HOC (eg WindowScroller).\n        // In this case we should avoid checking scrollingContainer.scrollTop and scrollingContainer.scrollLeft since it forces layout/flow.\n        if (!autoWidth && scrollLeft >= 0 && (scrollLeft !== this._scrollingContainer.scrollLeft || columnOrRowCountJustIncreasedFromZero)) {\n          this._scrollingContainer.scrollLeft = scrollLeft;\n        }\n        if (!autoHeight && scrollTop >= 0 && (scrollTop !== this._scrollingContainer.scrollTop || columnOrRowCountJustIncreasedFromZero)) {\n          this._scrollingContainer.scrollTop = scrollTop;\n        }\n      }\n\n      // Special case where the previous size was 0:\n      // In this case we don't show any windowed cells at all.\n      // So we should always recalculate offset afterwards.\n      var sizeJustIncreasedFromZero = (prevProps.width === 0 || prevProps.height === 0) && height > 0 && width > 0;\n\n      // Update scroll offsets if the current :scrollToColumn or :scrollToRow values requires it\n      // @TODO Do we also need this check or can the one in componentWillUpdate() suffice?\n      if (this._recomputeScrollLeftFlag) {\n        this._recomputeScrollLeftFlag = false;\n        this._updateScrollLeftForScrollToColumn(this.props);\n      } else {\n        (0, _updateScrollIndexHelper2.default)({\n          cellSizeAndPositionManager: instanceProps.columnSizeAndPositionManager,\n          previousCellsCount: prevProps.columnCount,\n          previousCellSize: prevProps.columnWidth,\n          previousScrollToAlignment: prevProps.scrollToAlignment,\n          previousScrollToIndex: prevProps.scrollToColumn,\n          previousSize: prevProps.width,\n          scrollOffset: scrollLeft,\n          scrollToAlignment: scrollToAlignment,\n          scrollToIndex: scrollToColumn,\n          size: width,\n          sizeJustIncreasedFromZero: sizeJustIncreasedFromZero,\n          updateScrollIndexCallback: function updateScrollIndexCallback() {\n            return _this2._updateScrollLeftForScrollToColumn(_this2.props);\n          }\n        });\n      }\n\n      if (this._recomputeScrollTopFlag) {\n        this._recomputeScrollTopFlag = false;\n        this._updateScrollTopForScrollToRow(this.props);\n      } else {\n        (0, _updateScrollIndexHelper2.default)({\n          cellSizeAndPositionManager: instanceProps.rowSizeAndPositionManager,\n          previousCellsCount: prevProps.rowCount,\n          previousCellSize: prevProps.rowHeight,\n          previousScrollToAlignment: prevProps.scrollToAlignment,\n          previousScrollToIndex: prevProps.scrollToRow,\n          previousSize: prevProps.height,\n          scrollOffset: scrollTop,\n          scrollToAlignment: scrollToAlignment,\n          scrollToIndex: scrollToRow,\n          size: height,\n          sizeJustIncreasedFromZero: sizeJustIncreasedFromZero,\n          updateScrollIndexCallback: function updateScrollIndexCallback() {\n            return _this2._updateScrollTopForScrollToRow(_this2.props);\n          }\n        });\n      }\n\n      // Update onRowsRendered callback if start/stop indices have changed\n      this._invokeOnGridRenderedHelper();\n\n      // Changes to :scrollLeft or :scrollTop should also notify :onScroll listeners\n      if (scrollLeft !== prevState.scrollLeft || scrollTop !== prevState.scrollTop) {\n        var totalRowsHeight = instanceProps.rowSizeAndPositionManager.getTotalSize();\n        var totalColumnsWidth = instanceProps.columnSizeAndPositionManager.getTotalSize();\n\n        this._invokeOnScrollMemoizer({\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          totalColumnsWidth: totalColumnsWidth,\n          totalRowsHeight: totalRowsHeight\n        });\n      }\n\n      this._maybeCallOnScrollbarPresenceChange();\n    }\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      if (this._disablePointerEventsTimeoutId) {\n        (0, _requestAnimationTimeout.cancelAnimationTimeout)(this._disablePointerEventsTimeoutId);\n      }\n    }\n\n    /**\n     * This method updates scrollLeft/scrollTop in state for the following conditions:\n     * 1) Empty content (0 rows or columns)\n     * 2) New scroll props overriding the current state\n     * 3) Cells-count or cells-size has changed, making previous scroll offsets invalid\n     */\n\n  }, {\n    key: 'render',\n    value: function render() {\n      var _props6 = this.props,\n          autoContainerWidth = _props6.autoContainerWidth,\n          autoHeight = _props6.autoHeight,\n          autoWidth = _props6.autoWidth,\n          className = _props6.className,\n          containerProps = _props6.containerProps,\n          containerRole = _props6.containerRole,\n          containerStyle = _props6.containerStyle,\n          height = _props6.height,\n          id = _props6.id,\n          noContentRenderer = _props6.noContentRenderer,\n          role = _props6.role,\n          style = _props6.style,\n          tabIndex = _props6.tabIndex,\n          width = _props6.width;\n      var _state2 = this.state,\n          instanceProps = _state2.instanceProps,\n          needToResetStyleCache = _state2.needToResetStyleCache;\n\n\n      var isScrolling = this._isScrolling();\n\n      var gridStyle = {\n        boxSizing: 'border-box',\n        direction: 'ltr',\n        height: autoHeight ? 'auto' : height,\n        position: 'relative',\n        width: autoWidth ? 'auto' : width,\n        WebkitOverflowScrolling: 'touch',\n        willChange: 'transform'\n      };\n\n      if (needToResetStyleCache) {\n        this._styleCache = {};\n      }\n\n      // calculate _styleCache here\n      // if state.isScrolling (not from _isScrolling) then reset\n      if (!this.state.isScrolling) {\n        this._resetStyleCache();\n      }\n\n      // calculate children to render here\n      this._calculateChildrenToRender(this.props, this.state);\n\n      var totalColumnsWidth = instanceProps.columnSizeAndPositionManager.getTotalSize();\n      var totalRowsHeight = instanceProps.rowSizeAndPositionManager.getTotalSize();\n\n      // Force browser to hide scrollbars when we know they aren't necessary.\n      // Otherwise once scrollbars appear they may not disappear again.\n      // For more info see issue #116\n      var verticalScrollBarSize = totalRowsHeight > height ? instanceProps.scrollbarSize : 0;\n      var horizontalScrollBarSize = totalColumnsWidth > width ? instanceProps.scrollbarSize : 0;\n\n      if (horizontalScrollBarSize !== this._horizontalScrollBarSize || verticalScrollBarSize !== this._verticalScrollBarSize) {\n        this._horizontalScrollBarSize = horizontalScrollBarSize;\n        this._verticalScrollBarSize = verticalScrollBarSize;\n        this._scrollbarPresenceChanged = true;\n      }\n\n      // Also explicitly init styles to 'auto' if scrollbars are required.\n      // This works around an obscure edge case where external CSS styles have not yet been loaded,\n      // But an initial scroll index of offset is set as an external prop.\n      // Without this style, Grid would render the correct range of cells but would NOT update its internal offset.\n      // This was originally reported via clauderic/react-infinite-calendar/issues/23\n      gridStyle.overflowX = totalColumnsWidth + verticalScrollBarSize <= width ? 'hidden' : 'auto';\n      gridStyle.overflowY = totalRowsHeight + horizontalScrollBarSize <= height ? 'hidden' : 'auto';\n\n      var childrenToDisplay = this._childrenToDisplay;\n\n      var showNoContentRenderer = childrenToDisplay.length === 0 && height > 0 && width > 0;\n\n      return React.createElement(\n        'div',\n        (0, _extends3.default)({\n          ref: this._setScrollingContainerRef\n        }, containerProps, {\n          'aria-label': this.props['aria-label'],\n          'aria-readonly': this.props['aria-readonly'],\n          className: (0, _classnames2.default)('ReactVirtualized__Grid', className),\n          id: id,\n          onScroll: this._onScroll,\n          role: role,\n          style: (0, _extends3.default)({}, gridStyle, style),\n          tabIndex: tabIndex }),\n        childrenToDisplay.length > 0 && React.createElement(\n          'div',\n          {\n            className: 'ReactVirtualized__Grid__innerScrollContainer',\n            role: containerRole,\n            style: (0, _extends3.default)({\n              width: autoContainerWidth ? 'auto' : totalColumnsWidth,\n              height: totalRowsHeight,\n              maxWidth: totalColumnsWidth,\n              maxHeight: totalRowsHeight,\n              overflow: 'hidden',\n              pointerEvents: isScrolling ? 'none' : '',\n              position: 'relative'\n            }, containerStyle) },\n          childrenToDisplay\n        ),\n        showNoContentRenderer && noContentRenderer()\n      );\n    }\n\n    /* ---------------------------- Helper methods ---------------------------- */\n\n  }, {\n    key: '_calculateChildrenToRender',\n    value: function _calculateChildrenToRender() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;\n      var cellRenderer = props.cellRenderer,\n          cellRangeRenderer = props.cellRangeRenderer,\n          columnCount = props.columnCount,\n          deferredMeasurementCache = props.deferredMeasurementCache,\n          height = props.height,\n          overscanColumnCount = props.overscanColumnCount,\n          overscanIndicesGetter = props.overscanIndicesGetter,\n          overscanRowCount = props.overscanRowCount,\n          rowCount = props.rowCount,\n          width = props.width,\n          isScrollingOptOut = props.isScrollingOptOut;\n      var scrollDirectionHorizontal = state.scrollDirectionHorizontal,\n          scrollDirectionVertical = state.scrollDirectionVertical,\n          instanceProps = state.instanceProps;\n\n\n      var scrollTop = this._initialScrollTop > 0 ? this._initialScrollTop : state.scrollTop;\n      var scrollLeft = this._initialScrollLeft > 0 ? this._initialScrollLeft : state.scrollLeft;\n\n      var isScrolling = this._isScrolling(props, state);\n\n      this._childrenToDisplay = [];\n\n      // Render only enough columns and rows to cover the visible area of the grid.\n      if (height > 0 && width > 0) {\n        var visibleColumnIndices = instanceProps.columnSizeAndPositionManager.getVisibleCellRange({\n          containerSize: width,\n          offset: scrollLeft\n        });\n        var visibleRowIndices = instanceProps.rowSizeAndPositionManager.getVisibleCellRange({\n          containerSize: height,\n          offset: scrollTop\n        });\n\n        var horizontalOffsetAdjustment = instanceProps.columnSizeAndPositionManager.getOffsetAdjustment({\n          containerSize: width,\n          offset: scrollLeft\n        });\n        var verticalOffsetAdjustment = instanceProps.rowSizeAndPositionManager.getOffsetAdjustment({\n          containerSize: height,\n          offset: scrollTop\n        });\n\n        // Store for _invokeOnGridRenderedHelper()\n        this._renderedColumnStartIndex = visibleColumnIndices.start;\n        this._renderedColumnStopIndex = visibleColumnIndices.stop;\n        this._renderedRowStartIndex = visibleRowIndices.start;\n        this._renderedRowStopIndex = visibleRowIndices.stop;\n\n        var overscanColumnIndices = overscanIndicesGetter({\n          direction: 'horizontal',\n          cellCount: columnCount,\n          overscanCellsCount: overscanColumnCount,\n          scrollDirection: scrollDirectionHorizontal,\n          startIndex: typeof visibleColumnIndices.start === 'number' ? visibleColumnIndices.start : 0,\n          stopIndex: typeof visibleColumnIndices.stop === 'number' ? visibleColumnIndices.stop : -1\n        });\n\n        var overscanRowIndices = overscanIndicesGetter({\n          direction: 'vertical',\n          cellCount: rowCount,\n          overscanCellsCount: overscanRowCount,\n          scrollDirection: scrollDirectionVertical,\n          startIndex: typeof visibleRowIndices.start === 'number' ? visibleRowIndices.start : 0,\n          stopIndex: typeof visibleRowIndices.stop === 'number' ? visibleRowIndices.stop : -1\n        });\n\n        // Store for _invokeOnGridRenderedHelper()\n        var columnStartIndex = overscanColumnIndices.overscanStartIndex;\n        var columnStopIndex = overscanColumnIndices.overscanStopIndex;\n        var rowStartIndex = overscanRowIndices.overscanStartIndex;\n        var rowStopIndex = overscanRowIndices.overscanStopIndex;\n\n        // Advanced use-cases (eg CellMeasurer) require batched measurements to determine accurate sizes.\n        if (deferredMeasurementCache) {\n          // If rows have a dynamic height, scan the rows we are about to render.\n          // If any have not yet been measured, then we need to render all columns initially,\n          // Because the height of the row is equal to the tallest cell within that row,\n          // (And so we can't know the height without measuring all column-cells first).\n          if (!deferredMeasurementCache.hasFixedHeight()) {\n            for (var rowIndex = rowStartIndex; rowIndex <= rowStopIndex; rowIndex++) {\n              if (!deferredMeasurementCache.has(rowIndex, 0)) {\n                columnStartIndex = 0;\n                columnStopIndex = columnCount - 1;\n                break;\n              }\n            }\n          }\n\n          // If columns have a dynamic width, scan the columns we are about to render.\n          // If any have not yet been measured, then we need to render all rows initially,\n          // Because the width of the column is equal to the widest cell within that column,\n          // (And so we can't know the width without measuring all row-cells first).\n          if (!deferredMeasurementCache.hasFixedWidth()) {\n            for (var columnIndex = columnStartIndex; columnIndex <= columnStopIndex; columnIndex++) {\n              if (!deferredMeasurementCache.has(0, columnIndex)) {\n                rowStartIndex = 0;\n                rowStopIndex = rowCount - 1;\n                break;\n              }\n            }\n          }\n        }\n\n        this._childrenToDisplay = cellRangeRenderer({\n          cellCache: this._cellCache,\n          cellRenderer: cellRenderer,\n          columnSizeAndPositionManager: instanceProps.columnSizeAndPositionManager,\n          columnStartIndex: columnStartIndex,\n          columnStopIndex: columnStopIndex,\n          deferredMeasurementCache: deferredMeasurementCache,\n          horizontalOffsetAdjustment: horizontalOffsetAdjustment,\n          isScrolling: isScrolling,\n          isScrollingOptOut: isScrollingOptOut,\n          parent: this,\n          rowSizeAndPositionManager: instanceProps.rowSizeAndPositionManager,\n          rowStartIndex: rowStartIndex,\n          rowStopIndex: rowStopIndex,\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          styleCache: this._styleCache,\n          verticalOffsetAdjustment: verticalOffsetAdjustment,\n          visibleColumnIndices: visibleColumnIndices,\n          visibleRowIndices: visibleRowIndices\n        });\n\n        // update the indices\n        this._columnStartIndex = columnStartIndex;\n        this._columnStopIndex = columnStopIndex;\n        this._rowStartIndex = rowStartIndex;\n        this._rowStopIndex = rowStopIndex;\n      }\n    }\n\n    /**\n     * Sets an :isScrolling flag for a small window of time.\n     * This flag is used to disable pointer events on the scrollable portion of the Grid.\n     * This prevents jerky/stuttery mouse-wheel scrolling.\n     */\n\n  }, {\n    key: '_debounceScrollEnded',\n    value: function _debounceScrollEnded() {\n      var scrollingResetTimeInterval = this.props.scrollingResetTimeInterval;\n\n\n      if (this._disablePointerEventsTimeoutId) {\n        (0, _requestAnimationTimeout.cancelAnimationTimeout)(this._disablePointerEventsTimeoutId);\n      }\n\n      this._disablePointerEventsTimeoutId = (0, _requestAnimationTimeout.requestAnimationTimeout)(this._debounceScrollEndedCallback, scrollingResetTimeInterval);\n    }\n  }, {\n    key: '_handleInvalidatedGridSize',\n\n\n    /**\n     * Check for batched CellMeasurer size invalidations.\n     * This will occur the first time one or more previously unmeasured cells are rendered.\n     */\n    value: function _handleInvalidatedGridSize() {\n      if (typeof this._deferredInvalidateColumnIndex === 'number' && typeof this._deferredInvalidateRowIndex === 'number') {\n        var columnIndex = this._deferredInvalidateColumnIndex;\n        var rowIndex = this._deferredInvalidateRowIndex;\n\n        this._deferredInvalidateColumnIndex = null;\n        this._deferredInvalidateRowIndex = null;\n\n        this.recomputeGridSize({ columnIndex: columnIndex, rowIndex: rowIndex });\n      }\n    }\n  }, {\n    key: '_invokeOnScrollMemoizer',\n    value: function _invokeOnScrollMemoizer(_ref6) {\n      var _this3 = this;\n\n      var scrollLeft = _ref6.scrollLeft,\n          scrollTop = _ref6.scrollTop,\n          totalColumnsWidth = _ref6.totalColumnsWidth,\n          totalRowsHeight = _ref6.totalRowsHeight;\n\n      this._onScrollMemoizer({\n        callback: function callback(_ref7) {\n          var scrollLeft = _ref7.scrollLeft,\n              scrollTop = _ref7.scrollTop;\n          var _props7 = _this3.props,\n              height = _props7.height,\n              onScroll = _props7.onScroll,\n              width = _props7.width;\n\n\n          onScroll({\n            clientHeight: height,\n            clientWidth: width,\n            scrollHeight: totalRowsHeight,\n            scrollLeft: scrollLeft,\n            scrollTop: scrollTop,\n            scrollWidth: totalColumnsWidth\n          });\n        },\n        indices: {\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop\n        }\n      });\n    }\n  }, {\n    key: '_isScrolling',\n    value: function _isScrolling() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;\n\n      // If isScrolling is defined in props, use it to override the value in state\n      // This is a performance optimization for WindowScroller + Grid\n      return Object.hasOwnProperty.call(props, 'isScrolling') ? Boolean(props.isScrolling) : Boolean(state.isScrolling);\n    }\n  }, {\n    key: '_maybeCallOnScrollbarPresenceChange',\n    value: function _maybeCallOnScrollbarPresenceChange() {\n      if (this._scrollbarPresenceChanged) {\n        var _onScrollbarPresenceChange = this.props.onScrollbarPresenceChange;\n\n\n        this._scrollbarPresenceChanged = false;\n\n        _onScrollbarPresenceChange({\n          horizontal: this._horizontalScrollBarSize > 0,\n          size: this.state.instanceProps.scrollbarSize,\n          vertical: this._verticalScrollBarSize > 0\n        });\n      }\n    }\n  }, {\n    key: 'scrollToPosition',\n\n\n    /**\n     * Scroll to the specified offset(s).\n     * Useful for animating position changes.\n     */\n    value: function scrollToPosition(_ref8) {\n      var scrollLeft = _ref8.scrollLeft,\n          scrollTop = _ref8.scrollTop;\n\n      var stateUpdate = Grid._getScrollToPositionStateUpdate({\n        prevState: this.state,\n        scrollLeft: scrollLeft,\n        scrollTop: scrollTop\n      });\n\n      if (stateUpdate) {\n        stateUpdate.needToResetStyleCache = false;\n        this.setState(stateUpdate);\n      }\n    }\n  }, {\n    key: '_getCalculatedScrollLeft',\n    value: function _getCalculatedScrollLeft() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;\n\n      return Grid._getCalculatedScrollLeft(props, state);\n    }\n  }, {\n    key: '_updateScrollLeftForScrollToColumn',\n    value: function _updateScrollLeftForScrollToColumn() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;\n\n      var stateUpdate = Grid._getScrollLeftForScrollToColumnStateUpdate(props, state);\n      if (stateUpdate) {\n        stateUpdate.needToResetStyleCache = false;\n        this.setState(stateUpdate);\n      }\n    }\n  }, {\n    key: '_getCalculatedScrollTop',\n    value: function _getCalculatedScrollTop() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;\n\n      return Grid._getCalculatedScrollTop(props, state);\n    }\n  }, {\n    key: '_resetStyleCache',\n    value: function _resetStyleCache() {\n      var styleCache = this._styleCache;\n      var cellCache = this._cellCache;\n      var isScrollingOptOut = this.props.isScrollingOptOut;\n\n      // Reset cell and style caches once scrolling stops.\n      // This makes Grid simpler to use (since cells commonly change).\n      // And it keeps the caches from growing too large.\n      // Performance is most sensitive when a user is scrolling.\n      // Don't clear visible cells from cellCache if isScrollingOptOut is specified.\n      // This keeps the cellCache to a resonable size.\n\n      this._cellCache = {};\n      this._styleCache = {};\n\n      // Copy over the visible cell styles so avoid unnecessary re-render.\n      for (var rowIndex = this._rowStartIndex; rowIndex <= this._rowStopIndex; rowIndex++) {\n        for (var columnIndex = this._columnStartIndex; columnIndex <= this._columnStopIndex; columnIndex++) {\n          var key = rowIndex + '-' + columnIndex;\n          this._styleCache[key] = styleCache[key];\n\n          if (isScrollingOptOut) {\n            this._cellCache[key] = cellCache[key];\n          }\n        }\n      }\n    }\n  }, {\n    key: '_updateScrollTopForScrollToRow',\n    value: function _updateScrollTopForScrollToRow() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;\n\n      var stateUpdate = Grid._getScrollTopForScrollToRowStateUpdate(props, state);\n      if (stateUpdate) {\n        stateUpdate.needToResetStyleCache = false;\n        this.setState(stateUpdate);\n      }\n    }\n  }], [{\n    key: 'getDerivedStateFromProps',\n    value: function getDerivedStateFromProps(nextProps, prevState) {\n      var newState = {};\n\n      if (nextProps.columnCount === 0 && prevState.scrollLeft !== 0 || nextProps.rowCount === 0 && prevState.scrollTop !== 0) {\n        newState.scrollLeft = 0;\n        newState.scrollTop = 0;\n\n        // only use scroll{Left,Top} from props if scrollTo{Column,Row} isn't specified\n        // scrollTo{Column,Row} should override scroll{Left,Top}\n      } else if (nextProps.scrollLeft !== prevState.scrollLeft && nextProps.scrollToColumn < 0 || nextProps.scrollTop !== prevState.scrollTop && nextProps.scrollToRow < 0) {\n        (0, _assign2.default)(newState, Grid._getScrollToPositionStateUpdate({\n          prevState: prevState,\n          scrollLeft: nextProps.scrollLeft,\n          scrollTop: nextProps.scrollTop\n        }));\n      }\n\n      var instanceProps = prevState.instanceProps;\n\n      // Initially we should not clearStyleCache\n\n      newState.needToResetStyleCache = false;\n      if (nextProps.columnWidth !== instanceProps.prevColumnWidth || nextProps.rowHeight !== instanceProps.prevRowHeight) {\n        // Reset cache. set it to {} in render\n        newState.needToResetStyleCache = true;\n      }\n\n      instanceProps.columnSizeAndPositionManager.configure({\n        cellCount: nextProps.columnCount,\n        estimatedCellSize: Grid._getEstimatedColumnSize(nextProps),\n        cellSizeGetter: Grid._wrapSizeGetter(nextProps.columnWidth)\n      });\n\n      instanceProps.rowSizeAndPositionManager.configure({\n        cellCount: nextProps.rowCount,\n        estimatedCellSize: Grid._getEstimatedRowSize(nextProps),\n        cellSizeGetter: Grid._wrapSizeGetter(nextProps.rowHeight)\n      });\n\n      if (instanceProps.prevColumnCount === 0 || instanceProps.prevRowCount === 0) {\n        instanceProps.prevColumnCount = 0;\n        instanceProps.prevRowCount = 0;\n      }\n\n      // If scrolling is controlled outside this component, clear cache when scrolling stops\n      if (nextProps.autoHeight && nextProps.isScrolling === false && instanceProps.prevIsScrolling === true) {\n        (0, _assign2.default)(newState, {\n          isScrolling: false\n        });\n      }\n\n      var maybeStateA = void 0;\n      var maybeStateB = void 0;\n\n      (0, _calculateSizeAndPositionDataAndUpdateScrollOffset2.default)({\n        cellCount: instanceProps.prevColumnCount,\n        cellSize: typeof instanceProps.prevColumnWidth === 'number' ? instanceProps.prevColumnWidth : null,\n        computeMetadataCallback: function computeMetadataCallback() {\n          return instanceProps.columnSizeAndPositionManager.resetCell(0);\n        },\n        computeMetadataCallbackProps: nextProps,\n        nextCellsCount: nextProps.columnCount,\n        nextCellSize: typeof nextProps.columnWidth === 'number' ? nextProps.columnWidth : null,\n        nextScrollToIndex: nextProps.scrollToColumn,\n        scrollToIndex: instanceProps.prevScrollToColumn,\n        updateScrollOffsetForScrollToIndex: function updateScrollOffsetForScrollToIndex() {\n          maybeStateA = Grid._getScrollLeftForScrollToColumnStateUpdate(nextProps, prevState);\n        }\n      });\n      (0, _calculateSizeAndPositionDataAndUpdateScrollOffset2.default)({\n        cellCount: instanceProps.prevRowCount,\n        cellSize: typeof instanceProps.prevRowHeight === 'number' ? instanceProps.prevRowHeight : null,\n        computeMetadataCallback: function computeMetadataCallback() {\n          return instanceProps.rowSizeAndPositionManager.resetCell(0);\n        },\n        computeMetadataCallbackProps: nextProps,\n        nextCellsCount: nextProps.rowCount,\n        nextCellSize: typeof nextProps.rowHeight === 'number' ? nextProps.rowHeight : null,\n        nextScrollToIndex: nextProps.scrollToRow,\n        scrollToIndex: instanceProps.prevScrollToRow,\n        updateScrollOffsetForScrollToIndex: function updateScrollOffsetForScrollToIndex() {\n          maybeStateB = Grid._getScrollTopForScrollToRowStateUpdate(nextProps, prevState);\n        }\n      });\n\n      instanceProps.prevColumnCount = nextProps.columnCount;\n      instanceProps.prevColumnWidth = nextProps.columnWidth;\n      instanceProps.prevIsScrolling = nextProps.isScrolling === true;\n      instanceProps.prevRowCount = nextProps.rowCount;\n      instanceProps.prevRowHeight = nextProps.rowHeight;\n      instanceProps.prevScrollToColumn = nextProps.scrollToColumn;\n      instanceProps.prevScrollToRow = nextProps.scrollToRow;\n\n      // getting scrollBarSize (moved from componentWillMount)\n      instanceProps.scrollbarSize = nextProps.getScrollbarSize();\n      if (instanceProps.scrollbarSize === undefined) {\n        instanceProps.scrollbarSizeMeasured = false;\n        instanceProps.scrollbarSize = 0;\n      } else {\n        instanceProps.scrollbarSizeMeasured = true;\n      }\n\n      newState.instanceProps = instanceProps;\n\n      return (0, _extends3.default)({}, newState, maybeStateA, maybeStateB);\n    }\n  }, {\n    key: '_getEstimatedColumnSize',\n    value: function _getEstimatedColumnSize(props) {\n      return typeof props.columnWidth === 'number' ? props.columnWidth : props.estimatedColumnSize;\n    }\n  }, {\n    key: '_getEstimatedRowSize',\n    value: function _getEstimatedRowSize(props) {\n      return typeof props.rowHeight === 'number' ? props.rowHeight : props.estimatedRowSize;\n    }\n  }, {\n    key: '_getScrollToPositionStateUpdate',\n\n\n    /**\n     * Get the updated state after scrolling to\n     * scrollLeft and scrollTop\n     */\n    value: function _getScrollToPositionStateUpdate(_ref9) {\n      var prevState = _ref9.prevState,\n          scrollLeft = _ref9.scrollLeft,\n          scrollTop = _ref9.scrollTop;\n\n      var newState = {\n        scrollPositionChangeReason: SCROLL_POSITION_CHANGE_REASONS.REQUESTED\n      };\n\n      if (typeof scrollLeft === 'number' && scrollLeft >= 0) {\n        newState.scrollDirectionHorizontal = scrollLeft > prevState.scrollLeft ? _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD : _defaultOverscanIndicesGetter.SCROLL_DIRECTION_BACKWARD;\n        newState.scrollLeft = scrollLeft;\n      }\n\n      if (typeof scrollTop === 'number' && scrollTop >= 0) {\n        newState.scrollDirectionVertical = scrollTop > prevState.scrollTop ? _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD : _defaultOverscanIndicesGetter.SCROLL_DIRECTION_BACKWARD;\n        newState.scrollTop = scrollTop;\n      }\n\n      if (typeof scrollLeft === 'number' && scrollLeft >= 0 && scrollLeft !== prevState.scrollLeft || typeof scrollTop === 'number' && scrollTop >= 0 && scrollTop !== prevState.scrollTop) {\n        return newState;\n      }\n      return null;\n    }\n  }, {\n    key: '_wrapSizeGetter',\n    value: function _wrapSizeGetter(value) {\n      return typeof value === 'function' ? value : function () {\n        return value;\n      };\n    }\n  }, {\n    key: '_getCalculatedScrollLeft',\n    value: function _getCalculatedScrollLeft(nextProps, prevState) {\n      var columnCount = nextProps.columnCount,\n          height = nextProps.height,\n          scrollToAlignment = nextProps.scrollToAlignment,\n          scrollToColumn = nextProps.scrollToColumn,\n          width = nextProps.width;\n      var scrollLeft = prevState.scrollLeft,\n          instanceProps = prevState.instanceProps;\n\n\n      if (columnCount > 0) {\n        var finalColumn = columnCount - 1;\n        var targetIndex = scrollToColumn < 0 ? finalColumn : Math.min(finalColumn, scrollToColumn);\n        var totalRowsHeight = instanceProps.rowSizeAndPositionManager.getTotalSize();\n        var scrollBarSize = instanceProps.scrollbarSizeMeasured && totalRowsHeight > height ? instanceProps.scrollbarSize : 0;\n\n        return instanceProps.columnSizeAndPositionManager.getUpdatedOffsetForIndex({\n          align: scrollToAlignment,\n          containerSize: width - scrollBarSize,\n          currentOffset: scrollLeft,\n          targetIndex: targetIndex\n        });\n      }\n      return 0;\n    }\n  }, {\n    key: '_getScrollLeftForScrollToColumnStateUpdate',\n    value: function _getScrollLeftForScrollToColumnStateUpdate(nextProps, prevState) {\n      var scrollLeft = prevState.scrollLeft;\n\n      var calculatedScrollLeft = Grid._getCalculatedScrollLeft(nextProps, prevState);\n\n      if (typeof calculatedScrollLeft === 'number' && calculatedScrollLeft >= 0 && scrollLeft !== calculatedScrollLeft) {\n        return Grid._getScrollToPositionStateUpdate({\n          prevState: prevState,\n          scrollLeft: calculatedScrollLeft,\n          scrollTop: -1\n        });\n      }\n      return null;\n    }\n  }, {\n    key: '_getCalculatedScrollTop',\n    value: function _getCalculatedScrollTop(nextProps, prevState) {\n      var height = nextProps.height,\n          rowCount = nextProps.rowCount,\n          scrollToAlignment = nextProps.scrollToAlignment,\n          scrollToRow = nextProps.scrollToRow,\n          width = nextProps.width;\n      var scrollTop = prevState.scrollTop,\n          instanceProps = prevState.instanceProps;\n\n\n      if (rowCount > 0) {\n        var finalRow = rowCount - 1;\n        var targetIndex = scrollToRow < 0 ? finalRow : Math.min(finalRow, scrollToRow);\n        var totalColumnsWidth = instanceProps.columnSizeAndPositionManager.getTotalSize();\n        var scrollBarSize = instanceProps.scrollbarSizeMeasured && totalColumnsWidth > width ? instanceProps.scrollbarSize : 0;\n\n        return instanceProps.rowSizeAndPositionManager.getUpdatedOffsetForIndex({\n          align: scrollToAlignment,\n          containerSize: height - scrollBarSize,\n          currentOffset: scrollTop,\n          targetIndex: targetIndex\n        });\n      }\n      return 0;\n    }\n  }, {\n    key: '_getScrollTopForScrollToRowStateUpdate',\n    value: function _getScrollTopForScrollToRowStateUpdate(nextProps, prevState) {\n      var scrollTop = prevState.scrollTop;\n\n      var calculatedScrollTop = Grid._getCalculatedScrollTop(nextProps, prevState);\n\n      if (typeof calculatedScrollTop === 'number' && calculatedScrollTop >= 0 && scrollTop !== calculatedScrollTop) {\n        return Grid._getScrollToPositionStateUpdate({\n          prevState: prevState,\n          scrollLeft: -1,\n          scrollTop: calculatedScrollTop\n        });\n      }\n      return null;\n    }\n  }]);\n  return Grid;\n}(React.PureComponent);\n\nGrid.defaultProps = {\n  'aria-label': 'grid',\n  'aria-readonly': true,\n  autoContainerWidth: false,\n  autoHeight: false,\n  autoWidth: false,\n  cellRangeRenderer: _defaultCellRangeRenderer2.default,\n  containerRole: 'rowgroup',\n  containerStyle: {},\n  estimatedColumnSize: 100,\n  estimatedRowSize: 30,\n  getScrollbarSize: _scrollbarSize2.default,\n  noContentRenderer: renderNull,\n  onScroll: function onScroll() {},\n  onScrollbarPresenceChange: function onScrollbarPresenceChange() {},\n  onSectionRendered: function onSectionRendered() {},\n  overscanColumnCount: 0,\n  overscanIndicesGetter: _defaultOverscanIndicesGetter2.default,\n  overscanRowCount: 10,\n  role: 'grid',\n  scrollingResetTimeInterval: DEFAULT_SCROLLING_RESET_TIME_INTERVAL,\n  scrollToAlignment: 'auto',\n  scrollToColumn: -1,\n  scrollToRow: -1,\n  style: {},\n  tabIndex: 0,\n  isScrollingOptOut: false\n};\nGrid.propTypes = process.env.NODE_ENV === 'production' ? null : {\n  \"aria-label\": _propTypes2.default.string.isRequired,\n  \"aria-readonly\": _propTypes2.default.bool,\n\n\n  /**\n   * Set the width of the inner scrollable container to 'auto'.\n   * This is useful for single-column Grids to ensure that the column doesn't extend below a vertical scrollbar.\n   */\n  autoContainerWidth: _propTypes2.default.bool.isRequired,\n\n\n  /**\n   * Removes fixed height from the scrollingContainer so that the total height of rows can stretch the window.\n   * Intended for use with WindowScroller\n   */\n  autoHeight: _propTypes2.default.bool.isRequired,\n\n\n  /**\n   * Removes fixed width from the scrollingContainer so that the total width of rows can stretch the window.\n   * Intended for use with WindowScroller\n   */\n  autoWidth: _propTypes2.default.bool.isRequired,\n\n\n  /** Responsible for rendering a cell given an row and column index.  */\n  cellRenderer: function cellRenderer() {\n    return (typeof _types.bpfrpt_proptype_CellRenderer === 'function' ? _types.bpfrpt_proptype_CellRenderer.isRequired ? _types.bpfrpt_proptype_CellRenderer.isRequired : _types.bpfrpt_proptype_CellRenderer : _propTypes2.default.shape(_types.bpfrpt_proptype_CellRenderer).isRequired).apply(this, arguments);\n  },\n\n\n  /** Responsible for rendering a group of cells given their index ranges.  */\n  cellRangeRenderer: function cellRangeRenderer() {\n    return (typeof _types.bpfrpt_proptype_CellRangeRenderer === 'function' ? _types.bpfrpt_proptype_CellRangeRenderer.isRequired ? _types.bpfrpt_proptype_CellRangeRenderer.isRequired : _types.bpfrpt_proptype_CellRangeRenderer : _propTypes2.default.shape(_types.bpfrpt_proptype_CellRangeRenderer).isRequired).apply(this, arguments);\n  },\n\n\n  /** Optional custom CSS class name to attach to root Grid element.  */\n  className: _propTypes2.default.string,\n\n\n  /** Number of columns in grid.  */\n  columnCount: _propTypes2.default.number.isRequired,\n\n\n  /** Either a fixed column width (number) or a function that returns the width of a column given its index.  */\n  columnWidth: function columnWidth() {\n    return (typeof _types.bpfrpt_proptype_CellSize === 'function' ? _types.bpfrpt_proptype_CellSize.isRequired ? _types.bpfrpt_proptype_CellSize.isRequired : _types.bpfrpt_proptype_CellSize : _propTypes2.default.shape(_types.bpfrpt_proptype_CellSize).isRequired).apply(this, arguments);\n  },\n\n\n  /** Unfiltered props for the Grid container. */\n  containerProps: _propTypes2.default.object,\n\n\n  /** ARIA role for the cell-container.  */\n  containerRole: _propTypes2.default.string.isRequired,\n\n\n  /** Optional inline style applied to inner cell-container */\n  containerStyle: _propTypes2.default.object.isRequired,\n\n\n  /**\n   * If CellMeasurer is used to measure this Grid's children, this should be a pointer to its CellMeasurerCache.\n   * A shared CellMeasurerCache reference enables Grid and CellMeasurer to share measurement data.\n   */\n  deferredMeasurementCache: _propTypes2.default.object,\n\n\n  /**\n   * Used to estimate the total width of a Grid before all of its columns have actually been measured.\n   * The estimated total width is adjusted as columns are rendered.\n   */\n  estimatedColumnSize: _propTypes2.default.number.isRequired,\n\n\n  /**\n   * Used to estimate the total height of a Grid before all of its rows have actually been measured.\n   * The estimated total height is adjusted as rows are rendered.\n   */\n  estimatedRowSize: _propTypes2.default.number.isRequired,\n\n\n  /** Exposed for testing purposes only.  */\n  getScrollbarSize: _propTypes2.default.func.isRequired,\n\n\n  /** Height of Grid; this property determines the number of visible (vs virtualized) rows.  */\n  height: _propTypes2.default.number.isRequired,\n\n\n  /** Optional custom id to attach to root Grid element.  */\n  id: _propTypes2.default.string,\n\n\n  /**\n   * Override internal is-scrolling state tracking.\n   * This property is primarily intended for use with the WindowScroller component.\n   */\n  isScrolling: _propTypes2.default.bool,\n\n\n  /**\n   * Opt-out of isScrolling param passed to cellRangeRenderer.\n   * To avoid the extra render when scroll stops.\n   */\n  isScrollingOptOut: _propTypes2.default.bool.isRequired,\n\n\n  /** Optional renderer to be used in place of rows when either :rowCount or :columnCount is 0.  */\n  noContentRenderer: function noContentRenderer() {\n    return (typeof _types.bpfrpt_proptype_NoContentRenderer === 'function' ? _types.bpfrpt_proptype_NoContentRenderer.isRequired ? _types.bpfrpt_proptype_NoContentRenderer.isRequired : _types.bpfrpt_proptype_NoContentRenderer : _propTypes2.default.shape(_types.bpfrpt_proptype_NoContentRenderer).isRequired).apply(this, arguments);\n  },\n\n\n  /**\n   * Callback invoked whenever the scroll offset changes within the inner scrollable region.\n   * This callback can be used to sync scrolling between lists, tables, or grids.\n   */\n  onScroll: _propTypes2.default.func.isRequired,\n\n\n  /**\n   * Called whenever a horizontal or vertical scrollbar is added or removed.\n   * This prop is not intended for end-user use;\n   * It is used by MultiGrid to support fixed-row/fixed-column scroll syncing.\n   */\n  onScrollbarPresenceChange: _propTypes2.default.func.isRequired,\n\n\n  /** Callback invoked with information about the section of the Grid that was just rendered.  */\n  onSectionRendered: _propTypes2.default.func.isRequired,\n\n\n  /**\n   * Number of columns to render before/after the visible section of the grid.\n   * These columns can help for smoother scrolling on touch devices or browsers that send scroll events infrequently.\n   */\n  overscanColumnCount: _propTypes2.default.number.isRequired,\n\n\n  /**\n   * Calculates the number of cells to overscan before and after a specified range.\n   * This function ensures that overscanning doesn't exceed the available cells.\n   */\n  overscanIndicesGetter: function overscanIndicesGetter() {\n    return (typeof _types.bpfrpt_proptype_OverscanIndicesGetter === 'function' ? _types.bpfrpt_proptype_OverscanIndicesGetter.isRequired ? _types.bpfrpt_proptype_OverscanIndicesGetter.isRequired : _types.bpfrpt_proptype_OverscanIndicesGetter : _propTypes2.default.shape(_types.bpfrpt_proptype_OverscanIndicesGetter).isRequired).apply(this, arguments);\n  },\n\n\n  /**\n   * Number of rows to render above/below the visible section of the grid.\n   * These rows can help for smoother scrolling on touch devices or browsers that send scroll events infrequently.\n   */\n  overscanRowCount: _propTypes2.default.number.isRequired,\n\n\n  /** ARIA role for the grid element.  */\n  role: _propTypes2.default.string.isRequired,\n\n\n  /**\n   * Either a fixed row height (number) or a function that returns the height of a row given its index.\n   * Should implement the following interface: ({ index: number }): number\n   */\n  rowHeight: function rowHeight() {\n    return (typeof _types.bpfrpt_proptype_CellSize === 'function' ? _types.bpfrpt_proptype_CellSize.isRequired ? _types.bpfrpt_proptype_CellSize.isRequired : _types.bpfrpt_proptype_CellSize : _propTypes2.default.shape(_types.bpfrpt_proptype_CellSize).isRequired).apply(this, arguments);\n  },\n\n\n  /** Number of rows in grid.  */\n  rowCount: _propTypes2.default.number.isRequired,\n\n\n  /** Wait this amount of time after the last scroll event before resetting Grid `pointer-events`. */\n  scrollingResetTimeInterval: _propTypes2.default.number.isRequired,\n\n\n  /** Horizontal offset. */\n  scrollLeft: _propTypes2.default.number,\n\n\n  /**\n   * Controls scroll-to-cell behavior of the Grid.\n   * The default (\"auto\") scrolls the least amount possible to ensure that the specified cell is fully visible.\n   * Use \"start\" to align cells to the top/left of the Grid and \"end\" to align bottom/right.\n   */\n  scrollToAlignment: function scrollToAlignment() {\n    return (typeof _types.bpfrpt_proptype_Alignment === 'function' ? _types.bpfrpt_proptype_Alignment.isRequired ? _types.bpfrpt_proptype_Alignment.isRequired : _types.bpfrpt_proptype_Alignment : _propTypes2.default.shape(_types.bpfrpt_proptype_Alignment).isRequired).apply(this, arguments);\n  },\n\n\n  /** Column index to ensure visible (by forcefully scrolling if necessary) */\n  scrollToColumn: _propTypes2.default.number.isRequired,\n\n\n  /** Vertical offset. */\n  scrollTop: _propTypes2.default.number,\n\n\n  /** Row index to ensure visible (by forcefully scrolling if necessary) */\n  scrollToRow: _propTypes2.default.number.isRequired,\n\n\n  /** Optional inline style */\n  style: _propTypes2.default.object.isRequired,\n\n\n  /** Tab index for focus */\n  tabIndex: _propTypes2.default.number,\n\n\n  /** Width of Grid; this property determines the number of visible (vs virtualized) columns.  */\n  width: _propTypes2.default.number.isRequired\n};\n\n\n(0, _reactLifecyclesCompat.polyfill)(Grid);\nexports.default = Grid;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$react_virtualized$dist$commonjs$utils$requestAnimationTimeout","~$module$node_modules$react_virtualized$dist$commonjs$Grid$types","~$module$node_modules$react_virtualized$dist$commonjs$utils$createCallbackMemoizer","~$module$node_modules$react_lifecycles_compat$react_lifecycles_compat_cjs","~$module$node_modules$react_virtualized$dist$commonjs$Grid$defaultOverscanIndicesGetter","~$module$node_modules$babel_runtime$helpers$possibleConstructorReturn","~$module$node_modules$react_virtualized$dist$commonjs$Grid$defaultCellRangeRenderer","~$module$node_modules$react$index","~$module$node_modules$prop_types$index","~$module$node_modules$babel_runtime$core_js$object$assign","~$shadow.js","~$module$node_modules$babel_runtime$helpers$inherits","~$module$node_modules$babel_runtime$core_js$object$get_prototype_of","~$module$node_modules$react_virtualized$dist$commonjs$Grid$utils$calculateSizeAndPositionDataAndUpdateScrollOffset","~$module$node_modules$classnames$index","~$module$node_modules$react_virtualized$dist$commonjs$Grid$utils$updateScrollIndexHelper","~$module$node_modules$dom_helpers$util$scrollbarSize","~$module$node_modules$babel_runtime$helpers$extends","~$module$node_modules$babel_runtime$helpers$classCallCheck","~$module$node_modules$react_virtualized$dist$commonjs$Grid$utils$ScalingCellSizeAndPositionManager","~$module$node_modules$babel_runtime$helpers$createClass"]],"~:properties",["^5",["nextScrollToIndex","_deferredInvalidateRowIndex","overscanIndicesGetter","scrollWidth","scrollbarSizeMeasured","overflowX","callback","scrollbarSize","startIndex","role","updateScrollOffsetForScrollToIndex","columnIndex","autoContainerWidth","width","verticalOffsetAdjustment","scrollPositionChangeReason","align","autoHeight","_recomputeScrollLeftFlag","nextCellsCount","columnSizeAndPositionManager","targetIndex","clientHeight","estimatedRowSize","cellRangeRenderer","offset","totalRowsHeight","scrollToColumn","height","_verticalScrollBarSize","tabIndex","overflowY","_setScrollingContainerRef","isScrollingOptOut","_renderedColumnStartIndex","prevRowCount","willChange","prevRowHeight","scrollLeft","previousCellSize","className","_debounceScrollEndedCallback","prevColumnCount","autoWidth","key","parent","scrollToAlignment","scrollToRow","__esModule","instanceProps","isScrolling","overscanColumnCount","vertical","id","maxHeight","prevScrollToColumn","containerSize","propTypes","scrollToIndex","rowStopIndex","rowOverscanStopIndex","rowStartIndex","updateScrollIndexCallback","previousScrollToAlignment","previousSize","columnOverscanStopIndex","position","styleCache","columnOverscanStartIndex","_horizontalScrollBarSize","cellRenderer","prevScrollToRow","style","value","prevIsScrolling","rowOverscanStartIndex","_renderedColumnStopIndex","boxSizing","_invokeOnGridRenderedHelper","direction","_onScroll","_renderedRowStopIndex","sizeJustIncreasedFromZero","computeMetadataCallbackProps","deferredMeasurementCache","_onGridRenderedMemoizer","overscanCellsCount","stopIndex","_cellCache","_renderedRowStartIndex","DEFAULT_SCROLLING_RESET_TIME_INTERVAL","totalColumnsWidth","onSectionRendered","onScrollbarPresenceChange","cellSize","cellCache","estimatedColumnSize","visibleRowIndices","defaultProps","clientWidth","scrollDirectionHorizontal","_recomputeScrollTopFlag","_onScrollMemoizer","overflow","cellCount","columnStopIndex","horizontal","previousCellsCount","scrollOffset","computeMetadataCallback","_childrenToDisplay","state","ref","containerStyle","_columnStopIndex","rowIndex","currentOffset","_initialScrollTop","nextCellSize","getScrollbarSize","scrollDirection","columnStartIndex","_rowStartIndex","_scrollingContainer","previousScrollToIndex","prevState","_styleCache","prevColumnWidth","_disablePointerEventsTimeoutId","maxWidth","size","_deferredInvalidateColumnIndex","scrollDirectionVertical","onScroll","_scrollbarPresenceChanged","_columnStartIndex","containerRole","scrollingResetTimeInterval","_rowStopIndex","scrollTop","rowSizeAndPositionManager","scrollHeight","visibleColumnIndices","noContentRenderer","default","WebkitOverflowScrolling","needToResetStyleCache","pointerEvents","_initialScrollLeft","estimatedCellSize","indices","cellSizeAndPositionManager","cellSizeGetter","horizontalOffsetAdjustment","overscanRowCount"]],"~:compiled-at",1537815743261,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$react_virtualized$dist$commonjs$Grid$Grid.js\",\n\"lineCount\":46,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/react-virtualized/dist/commonjs/Grid/Grid.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$react_virtualized$dist$commonjs$Grid$Grid\\\"] = function(global,process,require,module,exports,shadow$shims) {\\n'use strict';\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.DEFAULT_SCROLLING_RESET_TIME_INTERVAL = undefined;\\n\\nvar _assign = require('babel-runtime/core-js/object/assign');\\n\\nvar _assign2 = _interopRequireDefault(_assign);\\n\\nvar _extends2 = require('babel-runtime/helpers/extends');\\n\\nvar _extends3 = _interopRequireDefault(_extends2);\\n\\nvar _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');\\n\\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\\n\\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\\n\\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\\n\\nvar _createClass2 = require('babel-runtime/helpers/createClass');\\n\\nvar _createClass3 = _interopRequireDefault(_createClass2);\\n\\nvar _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');\\n\\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\\n\\nvar _inherits2 = require('babel-runtime/helpers/inherits');\\n\\nvar _inherits3 = _interopRequireDefault(_inherits2);\\n\\nvar _react = require('react');\\n\\nvar React = _interopRequireWildcard(_react);\\n\\nvar _classnames = require('classnames');\\n\\nvar _classnames2 = _interopRequireDefault(_classnames);\\n\\nvar _calculateSizeAndPositionDataAndUpdateScrollOffset = require('./utils/calculateSizeAndPositionDataAndUpdateScrollOffset');\\n\\nvar _calculateSizeAndPositionDataAndUpdateScrollOffset2 = _interopRequireDefault(_calculateSizeAndPositionDataAndUpdateScrollOffset);\\n\\nvar _ScalingCellSizeAndPositionManager = require('./utils/ScalingCellSizeAndPositionManager');\\n\\nvar _ScalingCellSizeAndPositionManager2 = _interopRequireDefault(_ScalingCellSizeAndPositionManager);\\n\\nvar _createCallbackMemoizer = require('../utils/createCallbackMemoizer');\\n\\nvar _createCallbackMemoizer2 = _interopRequireDefault(_createCallbackMemoizer);\\n\\nvar _defaultOverscanIndicesGetter = require('./defaultOverscanIndicesGetter');\\n\\nvar _defaultOverscanIndicesGetter2 = _interopRequireDefault(_defaultOverscanIndicesGetter);\\n\\nvar _updateScrollIndexHelper = require('./utils/updateScrollIndexHelper');\\n\\nvar _updateScrollIndexHelper2 = _interopRequireDefault(_updateScrollIndexHelper);\\n\\nvar _defaultCellRangeRenderer = require('./defaultCellRangeRenderer');\\n\\nvar _defaultCellRangeRenderer2 = _interopRequireDefault(_defaultCellRangeRenderer);\\n\\nvar _scrollbarSize = require('dom-helpers/util/scrollbarSize');\\n\\nvar _scrollbarSize2 = _interopRequireDefault(_scrollbarSize);\\n\\nvar _reactLifecyclesCompat = require('react-lifecycles-compat');\\n\\nvar _requestAnimationTimeout = require('../utils/requestAnimationTimeout');\\n\\nvar _types = require('./types');\\n\\nvar _propTypes = require('prop-types');\\n\\nvar _propTypes2 = _interopRequireDefault(_propTypes);\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\\n\\n/**\\n * Specifies the number of milliseconds during which to disable pointer events while a scroll is in progress.\\n * This improves performance and makes scrolling smoother.\\n */\\nvar DEFAULT_SCROLLING_RESET_TIME_INTERVAL = exports.DEFAULT_SCROLLING_RESET_TIME_INTERVAL = 150;\\n\\n/**\\n * Controls whether the Grid updates the DOM element's scrollLeft/scrollTop based on the current state or just observes it.\\n * This prevents Grid from interrupting mouse-wheel animations (see issue #2).\\n */\\n\\n\\nvar SCROLL_POSITION_CHANGE_REASONS = {\\n  OBSERVED: 'observed',\\n  REQUESTED: 'requested'\\n};\\n\\nvar renderNull = function renderNull() {\\n  return null;\\n};\\n\\n/**\\n * Renders tabular data with virtualization along the vertical and horizontal axes.\\n * Row heights and column widths must be known ahead of time and specified as properties.\\n */\\nvar Grid = function (_React$PureComponent) {\\n  (0, _inherits3.default)(Grid, _React$PureComponent);\\n\\n  // Invokes onSectionRendered callback only when start/stop row or column indices change\\n  function Grid(props) {\\n    (0, _classCallCheck3.default)(this, Grid);\\n\\n    var _this = (0, _possibleConstructorReturn3.default)(this, (Grid.__proto__ || (0, _getPrototypeOf2.default)(Grid)).call(this, props));\\n\\n    _this._onGridRenderedMemoizer = (0, _createCallbackMemoizer2.default)();\\n    _this._onScrollMemoizer = (0, _createCallbackMemoizer2.default)(false);\\n    _this._deferredInvalidateColumnIndex = null;\\n    _this._deferredInvalidateRowIndex = null;\\n    _this._recomputeScrollLeftFlag = false;\\n    _this._recomputeScrollTopFlag = false;\\n    _this._horizontalScrollBarSize = 0;\\n    _this._verticalScrollBarSize = 0;\\n    _this._scrollbarPresenceChanged = false;\\n    _this._renderedColumnStartIndex = 0;\\n    _this._renderedColumnStopIndex = 0;\\n    _this._renderedRowStartIndex = 0;\\n    _this._renderedRowStopIndex = 0;\\n    _this._styleCache = {};\\n    _this._cellCache = {};\\n\\n    _this._debounceScrollEndedCallback = function () {\\n      _this._disablePointerEventsTimeoutId = null;\\n      // isScrolling is used to determine if we reset styleCache\\n      _this.setState({\\n        isScrolling: false,\\n        needToResetStyleCache: false\\n      });\\n    };\\n\\n    _this._invokeOnGridRenderedHelper = function () {\\n      var onSectionRendered = _this.props.onSectionRendered;\\n\\n\\n      _this._onGridRenderedMemoizer({\\n        callback: onSectionRendered,\\n        indices: {\\n          columnOverscanStartIndex: _this._columnStartIndex,\\n          columnOverscanStopIndex: _this._columnStopIndex,\\n          columnStartIndex: _this._renderedColumnStartIndex,\\n          columnStopIndex: _this._renderedColumnStopIndex,\\n          rowOverscanStartIndex: _this._rowStartIndex,\\n          rowOverscanStopIndex: _this._rowStopIndex,\\n          rowStartIndex: _this._renderedRowStartIndex,\\n          rowStopIndex: _this._renderedRowStopIndex\\n        }\\n      });\\n    };\\n\\n    _this._setScrollingContainerRef = function (ref) {\\n      _this._scrollingContainer = ref;\\n    };\\n\\n    _this._onScroll = function (event) {\\n      // In certain edge-cases React dispatches an onScroll event with an invalid target.scrollLeft / target.scrollTop.\\n      // This invalid event can be detected by comparing event.target to this component's scrollable DOM element.\\n      // See issue #404 for more information.\\n      if (event.target === _this._scrollingContainer) {\\n        _this.handleScrollEvent(event.target);\\n      }\\n    };\\n\\n    var columnSizeAndPositionManager = new _ScalingCellSizeAndPositionManager2.default({\\n      cellCount: props.columnCount,\\n      cellSizeGetter: function cellSizeGetter(params) {\\n        return Grid._wrapSizeGetter(props.columnWidth)(params);\\n      },\\n      estimatedCellSize: Grid._getEstimatedColumnSize(props)\\n    });\\n    var rowSizeAndPositionManager = new _ScalingCellSizeAndPositionManager2.default({\\n      cellCount: props.rowCount,\\n      cellSizeGetter: function cellSizeGetter(params) {\\n        return Grid._wrapSizeGetter(props.rowHeight)(params);\\n      },\\n      estimatedCellSize: Grid._getEstimatedRowSize(props)\\n    });\\n\\n    _this.state = {\\n      instanceProps: {\\n        columnSizeAndPositionManager: columnSizeAndPositionManager,\\n        rowSizeAndPositionManager: rowSizeAndPositionManager,\\n\\n        prevColumnWidth: props.columnWidth,\\n        prevRowHeight: props.rowHeight,\\n        prevColumnCount: props.columnCount,\\n        prevRowCount: props.rowCount,\\n        prevIsScrolling: props.isScrolling === true,\\n        prevScrollToColumn: props.scrollToColumn,\\n        prevScrollToRow: props.scrollToRow,\\n\\n        scrollbarSize: 0,\\n        scrollbarSizeMeasured: false\\n      },\\n      isScrolling: false,\\n      scrollDirectionHorizontal: _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD,\\n      scrollDirectionVertical: _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD,\\n      scrollLeft: 0,\\n      scrollTop: 0,\\n      scrollPositionChangeReason: null,\\n\\n      needToResetStyleCache: false\\n    };\\n\\n    if (props.scrollToRow > 0) {\\n      _this._initialScrollTop = _this._getCalculatedScrollTop(props, _this.state);\\n    }\\n    if (props.scrollToColumn > 0) {\\n      _this._initialScrollLeft = _this._getCalculatedScrollLeft(props, _this.state);\\n    }\\n    return _this;\\n  }\\n\\n  /**\\n   * Gets offsets for a given cell and alignment.\\n   */\\n\\n\\n  (0, _createClass3.default)(Grid, [{\\n    key: 'getOffsetForCell',\\n    value: function getOffsetForCell() {\\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\\n          _ref$alignment = _ref.alignment,\\n          alignment = _ref$alignment === undefined ? this.props.scrollToAlignment : _ref$alignment,\\n          _ref$columnIndex = _ref.columnIndex,\\n          columnIndex = _ref$columnIndex === undefined ? this.props.scrollToColumn : _ref$columnIndex,\\n          _ref$rowIndex = _ref.rowIndex,\\n          rowIndex = _ref$rowIndex === undefined ? this.props.scrollToRow : _ref$rowIndex;\\n\\n      var offsetProps = (0, _extends3.default)({}, this.props, {\\n        scrollToAlignment: alignment,\\n        scrollToColumn: columnIndex,\\n        scrollToRow: rowIndex\\n      });\\n\\n      return {\\n        scrollLeft: this._getCalculatedScrollLeft(offsetProps),\\n        scrollTop: this._getCalculatedScrollTop(offsetProps)\\n      };\\n    }\\n\\n    /**\\n     * Gets estimated total rows' height.\\n     */\\n\\n  }, {\\n    key: 'getTotalRowsHeight',\\n    value: function getTotalRowsHeight() {\\n      return this.state.instanceProps.rowSizeAndPositionManager.getTotalSize();\\n    }\\n\\n    /**\\n     * Gets estimated total columns' width.\\n     */\\n\\n  }, {\\n    key: 'getTotalColumnsWidth',\\n    value: function getTotalColumnsWidth() {\\n      return this.state.instanceProps.columnSizeAndPositionManager.getTotalSize();\\n    }\\n\\n    /**\\n     * This method handles a scroll event originating from an external scroll control.\\n     * It's an advanced method and should probably not be used unless you're implementing a custom scroll-bar solution.\\n     */\\n\\n  }, {\\n    key: 'handleScrollEvent',\\n    value: function handleScrollEvent(_ref2) {\\n      var _ref2$scrollLeft = _ref2.scrollLeft,\\n          scrollLeftParam = _ref2$scrollLeft === undefined ? 0 : _ref2$scrollLeft,\\n          _ref2$scrollTop = _ref2.scrollTop,\\n          scrollTopParam = _ref2$scrollTop === undefined ? 0 : _ref2$scrollTop;\\n\\n      // On iOS, we can arrive at negative offsets by swiping past the start.\\n      // To prevent flicker here, we make playing in the negative offset zone cause nothing to happen.\\n      if (scrollTopParam < 0) {\\n        return;\\n      }\\n\\n      // Prevent pointer events from interrupting a smooth scroll\\n      this._debounceScrollEnded();\\n\\n      var _props = this.props,\\n          autoHeight = _props.autoHeight,\\n          autoWidth = _props.autoWidth,\\n          height = _props.height,\\n          width = _props.width;\\n      var instanceProps = this.state.instanceProps;\\n\\n      // When this component is shrunk drastically, React dispatches a series of back-to-back scroll events,\\n      // Gradually converging on a scrollTop that is within the bounds of the new, smaller height.\\n      // This causes a series of rapid renders that is slow for long lists.\\n      // We can avoid that by doing some simple bounds checking to ensure that scroll offsets never exceed their bounds.\\n\\n      var scrollbarSize = instanceProps.scrollbarSize;\\n      var totalRowsHeight = instanceProps.rowSizeAndPositionManager.getTotalSize();\\n      var totalColumnsWidth = instanceProps.columnSizeAndPositionManager.getTotalSize();\\n      var scrollLeft = Math.min(Math.max(0, totalColumnsWidth - width + scrollbarSize), scrollLeftParam);\\n      var scrollTop = Math.min(Math.max(0, totalRowsHeight - height + scrollbarSize), scrollTopParam);\\n\\n      // Certain devices (like Apple touchpad) rapid-fire duplicate events.\\n      // Don't force a re-render if this is the case.\\n      // The mouse may move faster then the animation frame does.\\n      // Use requestAnimationFrame to avoid over-updating.\\n      if (this.state.scrollLeft !== scrollLeft || this.state.scrollTop !== scrollTop) {\\n        // Track scrolling direction so we can more efficiently overscan rows to reduce empty space around the edges while scrolling.\\n        // Don't change direction for an axis unless scroll offset has changed.\\n        var _scrollDirectionHorizontal = scrollLeft !== this.state.scrollLeft ? scrollLeft > this.state.scrollLeft ? _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD : _defaultOverscanIndicesGetter.SCROLL_DIRECTION_BACKWARD : this.state.scrollDirectionHorizontal;\\n        var _scrollDirectionVertical = scrollTop !== this.state.scrollTop ? scrollTop > this.state.scrollTop ? _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD : _defaultOverscanIndicesGetter.SCROLL_DIRECTION_BACKWARD : this.state.scrollDirectionVertical;\\n\\n        var newState = {\\n          isScrolling: true,\\n          scrollDirectionHorizontal: _scrollDirectionHorizontal,\\n          scrollDirectionVertical: _scrollDirectionVertical,\\n          scrollPositionChangeReason: SCROLL_POSITION_CHANGE_REASONS.OBSERVED\\n        };\\n\\n        if (!autoHeight) {\\n          newState.scrollTop = scrollTop;\\n        }\\n\\n        if (!autoWidth) {\\n          newState.scrollLeft = scrollLeft;\\n        }\\n\\n        newState.needToResetStyleCache = false;\\n        this.setState(newState);\\n      }\\n\\n      this._invokeOnScrollMemoizer({\\n        scrollLeft: scrollLeft,\\n        scrollTop: scrollTop,\\n        totalColumnsWidth: totalColumnsWidth,\\n        totalRowsHeight: totalRowsHeight\\n      });\\n    }\\n\\n    /**\\n     * Invalidate Grid size and recompute visible cells.\\n     * This is a deferred wrapper for recomputeGridSize().\\n     * It sets a flag to be evaluated on cDM/cDU to avoid unnecessary renders.\\n     * This method is intended for advanced use-cases like CellMeasurer.\\n     */\\n    // @TODO (bvaughn) Add automated test coverage for this.\\n\\n  }, {\\n    key: 'invalidateCellSizeAfterRender',\\n    value: function invalidateCellSizeAfterRender(_ref3) {\\n      var columnIndex = _ref3.columnIndex,\\n          rowIndex = _ref3.rowIndex;\\n\\n      this._deferredInvalidateColumnIndex = typeof this._deferredInvalidateColumnIndex === 'number' ? Math.min(this._deferredInvalidateColumnIndex, columnIndex) : columnIndex;\\n      this._deferredInvalidateRowIndex = typeof this._deferredInvalidateRowIndex === 'number' ? Math.min(this._deferredInvalidateRowIndex, rowIndex) : rowIndex;\\n    }\\n\\n    /**\\n     * Pre-measure all columns and rows in a Grid.\\n     * Typically cells are only measured as needed and estimated sizes are used for cells that have not yet been measured.\\n     * This method ensures that the next call to getTotalSize() returns an exact size (as opposed to just an estimated one).\\n     */\\n\\n  }, {\\n    key: 'measureAllCells',\\n    value: function measureAllCells() {\\n      var _props2 = this.props,\\n          columnCount = _props2.columnCount,\\n          rowCount = _props2.rowCount;\\n      var instanceProps = this.state.instanceProps;\\n\\n      instanceProps.columnSizeAndPositionManager.getSizeAndPositionOfCell(columnCount - 1);\\n      instanceProps.rowSizeAndPositionManager.getSizeAndPositionOfCell(rowCount - 1);\\n    }\\n\\n    /**\\n     * Forced recompute of row heights and column widths.\\n     * This function should be called if dynamic column or row sizes have changed but nothing else has.\\n     * Since Grid only receives :columnCount and :rowCount it has no way of detecting when the underlying data changes.\\n     */\\n\\n  }, {\\n    key: 'recomputeGridSize',\\n    value: function recomputeGridSize() {\\n      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\\n          _ref4$columnIndex = _ref4.columnIndex,\\n          columnIndex = _ref4$columnIndex === undefined ? 0 : _ref4$columnIndex,\\n          _ref4$rowIndex = _ref4.rowIndex,\\n          rowIndex = _ref4$rowIndex === undefined ? 0 : _ref4$rowIndex;\\n\\n      var _props3 = this.props,\\n          scrollToColumn = _props3.scrollToColumn,\\n          scrollToRow = _props3.scrollToRow;\\n      var instanceProps = this.state.instanceProps;\\n\\n\\n      instanceProps.columnSizeAndPositionManager.resetCell(columnIndex);\\n      instanceProps.rowSizeAndPositionManager.resetCell(rowIndex);\\n\\n      // Cell sizes may be determined by a function property.\\n      // In this case the cDU handler can't know if they changed.\\n      // Store this flag to let the next cDU pass know it needs to recompute the scroll offset.\\n      this._recomputeScrollLeftFlag = scrollToColumn >= 0 && (this.state.scrollDirectionHorizontal === _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD ? columnIndex <= scrollToColumn : columnIndex >= scrollToColumn);\\n      this._recomputeScrollTopFlag = scrollToRow >= 0 && (this.state.scrollDirectionVertical === _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD ? rowIndex <= scrollToRow : rowIndex >= scrollToRow);\\n\\n      // Clear cell cache in case we are scrolling;\\n      // Invalid row heights likely mean invalid cached content as well.\\n      this._styleCache = {};\\n      this._cellCache = {};\\n\\n      this.forceUpdate();\\n    }\\n\\n    /**\\n     * Ensure column and row are visible.\\n     */\\n\\n  }, {\\n    key: 'scrollToCell',\\n    value: function scrollToCell(_ref5) {\\n      var columnIndex = _ref5.columnIndex,\\n          rowIndex = _ref5.rowIndex;\\n      var columnCount = this.props.columnCount;\\n\\n\\n      var props = this.props;\\n\\n      // Don't adjust scroll offset for single-column grids (eg List, Table).\\n      // This can cause a funky scroll offset because of the vertical scrollbar width.\\n      if (columnCount > 1 && columnIndex !== undefined) {\\n        this._updateScrollLeftForScrollToColumn((0, _extends3.default)({}, props, {\\n          scrollToColumn: columnIndex\\n        }));\\n      }\\n\\n      if (rowIndex !== undefined) {\\n        this._updateScrollTopForScrollToRow((0, _extends3.default)({}, props, {\\n          scrollToRow: rowIndex\\n        }));\\n      }\\n    }\\n  }, {\\n    key: 'componentDidMount',\\n    value: function componentDidMount() {\\n      var _props4 = this.props,\\n          getScrollbarSize = _props4.getScrollbarSize,\\n          height = _props4.height,\\n          scrollLeft = _props4.scrollLeft,\\n          scrollToColumn = _props4.scrollToColumn,\\n          scrollTop = _props4.scrollTop,\\n          scrollToRow = _props4.scrollToRow,\\n          width = _props4.width;\\n      var instanceProps = this.state.instanceProps;\\n\\n      // Reset initial offsets to be ignored in browser\\n\\n      this._initialScrollTop = 0;\\n      this._initialScrollLeft = 0;\\n\\n      // If cell sizes have been invalidated (eg we are using CellMeasurer) then reset cached positions.\\n      // We must do this at the start of the method as we may calculate and update scroll position below.\\n      this._handleInvalidatedGridSize();\\n\\n      // If this component was first rendered server-side, scrollbar size will be undefined.\\n      // In that event we need to remeasure.\\n      if (!instanceProps.scrollbarSizeMeasured) {\\n        this.setState(function (prevState) {\\n          var stateUpdate = (0, _extends3.default)({}, prevState, { needToResetStyleCache: false });\\n          stateUpdate.instanceProps.scrollbarSize = getScrollbarSize();\\n          stateUpdate.instanceProps.scrollbarSizeMeasured = true;\\n          return stateUpdate;\\n        });\\n      }\\n\\n      if (typeof scrollLeft === 'number' && scrollLeft >= 0 || typeof scrollTop === 'number' && scrollTop >= 0) {\\n        var stateUpdate = Grid._getScrollToPositionStateUpdate({\\n          prevState: this.state,\\n          scrollLeft: scrollLeft,\\n          scrollTop: scrollTop\\n        });\\n        if (stateUpdate) {\\n          stateUpdate.needToResetStyleCache = false;\\n          this.setState(stateUpdate);\\n        }\\n      }\\n\\n      // refs don't work in `react-test-renderer`\\n      if (this._scrollingContainer) {\\n        // setting the ref's scrollLeft and scrollTop.\\n        // Somehow in MultiGrid the main grid doesn't trigger a update on mount.\\n        if (this._scrollingContainer.scrollLeft !== this.state.scrollLeft) {\\n          this._scrollingContainer.scrollLeft = this.state.scrollLeft;\\n        }\\n        if (this._scrollingContainer.scrollTop !== this.state.scrollTop) {\\n          this._scrollingContainer.scrollTop = this.state.scrollTop;\\n        }\\n      }\\n\\n      // Don't update scroll offset if the size is 0; we don't render any cells in this case.\\n      // Setting a state may cause us to later thing we've updated the offce when we haven't.\\n      var sizeIsBiggerThanZero = height > 0 && width > 0;\\n      if (scrollToColumn >= 0 && sizeIsBiggerThanZero) {\\n        this._updateScrollLeftForScrollToColumn();\\n      }\\n      if (scrollToRow >= 0 && sizeIsBiggerThanZero) {\\n        this._updateScrollTopForScrollToRow();\\n      }\\n\\n      // Update onRowsRendered callback\\n      this._invokeOnGridRenderedHelper();\\n\\n      // Initialize onScroll callback\\n      this._invokeOnScrollMemoizer({\\n        scrollLeft: scrollLeft || 0,\\n        scrollTop: scrollTop || 0,\\n        totalColumnsWidth: instanceProps.columnSizeAndPositionManager.getTotalSize(),\\n        totalRowsHeight: instanceProps.rowSizeAndPositionManager.getTotalSize()\\n      });\\n\\n      this._maybeCallOnScrollbarPresenceChange();\\n    }\\n\\n    /**\\n     * @private\\n     * This method updates scrollLeft/scrollTop in state for the following conditions:\\n     * 1) New scroll-to-cell props have been set\\n     */\\n\\n  }, {\\n    key: 'componentDidUpdate',\\n    value: function componentDidUpdate(prevProps, prevState) {\\n      var _this2 = this;\\n\\n      var _props5 = this.props,\\n          autoHeight = _props5.autoHeight,\\n          autoWidth = _props5.autoWidth,\\n          columnCount = _props5.columnCount,\\n          height = _props5.height,\\n          rowCount = _props5.rowCount,\\n          scrollToAlignment = _props5.scrollToAlignment,\\n          scrollToColumn = _props5.scrollToColumn,\\n          scrollToRow = _props5.scrollToRow,\\n          width = _props5.width;\\n      var _state = this.state,\\n          scrollLeft = _state.scrollLeft,\\n          scrollPositionChangeReason = _state.scrollPositionChangeReason,\\n          scrollTop = _state.scrollTop,\\n          instanceProps = _state.instanceProps;\\n      // If cell sizes have been invalidated (eg we are using CellMeasurer) then reset cached positions.\\n      // We must do this at the start of the method as we may calculate and update scroll position below.\\n\\n      this._handleInvalidatedGridSize();\\n\\n      // Handle edge case where column or row count has only just increased over 0.\\n      // In this case we may have to restore a previously-specified scroll offset.\\n      // For more info see bvaughn/react-virtualized/issues/218\\n      var columnOrRowCountJustIncreasedFromZero = columnCount > 0 && prevProps.columnCount === 0 || rowCount > 0 && prevProps.rowCount === 0;\\n\\n      // Make sure requested changes to :scrollLeft or :scrollTop get applied.\\n      // Assigning to scrollLeft/scrollTop tells the browser to interrupt any running scroll animations,\\n      // And to discard any pending async changes to the scroll position that may have happened in the meantime (e.g. on a separate scrolling thread).\\n      // So we only set these when we require an adjustment of the scroll position.\\n      // See issue #2 for more information.\\n      if (scrollPositionChangeReason === SCROLL_POSITION_CHANGE_REASONS.REQUESTED) {\\n        // @TRICKY :autoHeight and :autoWidth properties instructs Grid to leave :scrollTop and :scrollLeft management to an external HOC (eg WindowScroller).\\n        // In this case we should avoid checking scrollingContainer.scrollTop and scrollingContainer.scrollLeft since it forces layout/flow.\\n        if (!autoWidth && scrollLeft >= 0 && (scrollLeft !== this._scrollingContainer.scrollLeft || columnOrRowCountJustIncreasedFromZero)) {\\n          this._scrollingContainer.scrollLeft = scrollLeft;\\n        }\\n        if (!autoHeight && scrollTop >= 0 && (scrollTop !== this._scrollingContainer.scrollTop || columnOrRowCountJustIncreasedFromZero)) {\\n          this._scrollingContainer.scrollTop = scrollTop;\\n        }\\n      }\\n\\n      // Special case where the previous size was 0:\\n      // In this case we don't show any windowed cells at all.\\n      // So we should always recalculate offset afterwards.\\n      var sizeJustIncreasedFromZero = (prevProps.width === 0 || prevProps.height === 0) && height > 0 && width > 0;\\n\\n      // Update scroll offsets if the current :scrollToColumn or :scrollToRow values requires it\\n      // @TODO Do we also need this check or can the one in componentWillUpdate() suffice?\\n      if (this._recomputeScrollLeftFlag) {\\n        this._recomputeScrollLeftFlag = false;\\n        this._updateScrollLeftForScrollToColumn(this.props);\\n      } else {\\n        (0, _updateScrollIndexHelper2.default)({\\n          cellSizeAndPositionManager: instanceProps.columnSizeAndPositionManager,\\n          previousCellsCount: prevProps.columnCount,\\n          previousCellSize: prevProps.columnWidth,\\n          previousScrollToAlignment: prevProps.scrollToAlignment,\\n          previousScrollToIndex: prevProps.scrollToColumn,\\n          previousSize: prevProps.width,\\n          scrollOffset: scrollLeft,\\n          scrollToAlignment: scrollToAlignment,\\n          scrollToIndex: scrollToColumn,\\n          size: width,\\n          sizeJustIncreasedFromZero: sizeJustIncreasedFromZero,\\n          updateScrollIndexCallback: function updateScrollIndexCallback() {\\n            return _this2._updateScrollLeftForScrollToColumn(_this2.props);\\n          }\\n        });\\n      }\\n\\n      if (this._recomputeScrollTopFlag) {\\n        this._recomputeScrollTopFlag = false;\\n        this._updateScrollTopForScrollToRow(this.props);\\n      } else {\\n        (0, _updateScrollIndexHelper2.default)({\\n          cellSizeAndPositionManager: instanceProps.rowSizeAndPositionManager,\\n          previousCellsCount: prevProps.rowCount,\\n          previousCellSize: prevProps.rowHeight,\\n          previousScrollToAlignment: prevProps.scrollToAlignment,\\n          previousScrollToIndex: prevProps.scrollToRow,\\n          previousSize: prevProps.height,\\n          scrollOffset: scrollTop,\\n          scrollToAlignment: scrollToAlignment,\\n          scrollToIndex: scrollToRow,\\n          size: height,\\n          sizeJustIncreasedFromZero: sizeJustIncreasedFromZero,\\n          updateScrollIndexCallback: function updateScrollIndexCallback() {\\n            return _this2._updateScrollTopForScrollToRow(_this2.props);\\n          }\\n        });\\n      }\\n\\n      // Update onRowsRendered callback if start/stop indices have changed\\n      this._invokeOnGridRenderedHelper();\\n\\n      // Changes to :scrollLeft or :scrollTop should also notify :onScroll listeners\\n      if (scrollLeft !== prevState.scrollLeft || scrollTop !== prevState.scrollTop) {\\n        var totalRowsHeight = instanceProps.rowSizeAndPositionManager.getTotalSize();\\n        var totalColumnsWidth = instanceProps.columnSizeAndPositionManager.getTotalSize();\\n\\n        this._invokeOnScrollMemoizer({\\n          scrollLeft: scrollLeft,\\n          scrollTop: scrollTop,\\n          totalColumnsWidth: totalColumnsWidth,\\n          totalRowsHeight: totalRowsHeight\\n        });\\n      }\\n\\n      this._maybeCallOnScrollbarPresenceChange();\\n    }\\n  }, {\\n    key: 'componentWillUnmount',\\n    value: function componentWillUnmount() {\\n      if (this._disablePointerEventsTimeoutId) {\\n        (0, _requestAnimationTimeout.cancelAnimationTimeout)(this._disablePointerEventsTimeoutId);\\n      }\\n    }\\n\\n    /**\\n     * This method updates scrollLeft/scrollTop in state for the following conditions:\\n     * 1) Empty content (0 rows or columns)\\n     * 2) New scroll props overriding the current state\\n     * 3) Cells-count or cells-size has changed, making previous scroll offsets invalid\\n     */\\n\\n  }, {\\n    key: 'render',\\n    value: function render() {\\n      var _props6 = this.props,\\n          autoContainerWidth = _props6.autoContainerWidth,\\n          autoHeight = _props6.autoHeight,\\n          autoWidth = _props6.autoWidth,\\n          className = _props6.className,\\n          containerProps = _props6.containerProps,\\n          containerRole = _props6.containerRole,\\n          containerStyle = _props6.containerStyle,\\n          height = _props6.height,\\n          id = _props6.id,\\n          noContentRenderer = _props6.noContentRenderer,\\n          role = _props6.role,\\n          style = _props6.style,\\n          tabIndex = _props6.tabIndex,\\n          width = _props6.width;\\n      var _state2 = this.state,\\n          instanceProps = _state2.instanceProps,\\n          needToResetStyleCache = _state2.needToResetStyleCache;\\n\\n\\n      var isScrolling = this._isScrolling();\\n\\n      var gridStyle = {\\n        boxSizing: 'border-box',\\n        direction: 'ltr',\\n        height: autoHeight ? 'auto' : height,\\n        position: 'relative',\\n        width: autoWidth ? 'auto' : width,\\n        WebkitOverflowScrolling: 'touch',\\n        willChange: 'transform'\\n      };\\n\\n      if (needToResetStyleCache) {\\n        this._styleCache = {};\\n      }\\n\\n      // calculate _styleCache here\\n      // if state.isScrolling (not from _isScrolling) then reset\\n      if (!this.state.isScrolling) {\\n        this._resetStyleCache();\\n      }\\n\\n      // calculate children to render here\\n      this._calculateChildrenToRender(this.props, this.state);\\n\\n      var totalColumnsWidth = instanceProps.columnSizeAndPositionManager.getTotalSize();\\n      var totalRowsHeight = instanceProps.rowSizeAndPositionManager.getTotalSize();\\n\\n      // Force browser to hide scrollbars when we know they aren't necessary.\\n      // Otherwise once scrollbars appear they may not disappear again.\\n      // For more info see issue #116\\n      var verticalScrollBarSize = totalRowsHeight > height ? instanceProps.scrollbarSize : 0;\\n      var horizontalScrollBarSize = totalColumnsWidth > width ? instanceProps.scrollbarSize : 0;\\n\\n      if (horizontalScrollBarSize !== this._horizontalScrollBarSize || verticalScrollBarSize !== this._verticalScrollBarSize) {\\n        this._horizontalScrollBarSize = horizontalScrollBarSize;\\n        this._verticalScrollBarSize = verticalScrollBarSize;\\n        this._scrollbarPresenceChanged = true;\\n      }\\n\\n      // Also explicitly init styles to 'auto' if scrollbars are required.\\n      // This works around an obscure edge case where external CSS styles have not yet been loaded,\\n      // But an initial scroll index of offset is set as an external prop.\\n      // Without this style, Grid would render the correct range of cells but would NOT update its internal offset.\\n      // This was originally reported via clauderic/react-infinite-calendar/issues/23\\n      gridStyle.overflowX = totalColumnsWidth + verticalScrollBarSize <= width ? 'hidden' : 'auto';\\n      gridStyle.overflowY = totalRowsHeight + horizontalScrollBarSize <= height ? 'hidden' : 'auto';\\n\\n      var childrenToDisplay = this._childrenToDisplay;\\n\\n      var showNoContentRenderer = childrenToDisplay.length === 0 && height > 0 && width > 0;\\n\\n      return React.createElement(\\n        'div',\\n        (0, _extends3.default)({\\n          ref: this._setScrollingContainerRef\\n        }, containerProps, {\\n          'aria-label': this.props['aria-label'],\\n          'aria-readonly': this.props['aria-readonly'],\\n          className: (0, _classnames2.default)('ReactVirtualized__Grid', className),\\n          id: id,\\n          onScroll: this._onScroll,\\n          role: role,\\n          style: (0, _extends3.default)({}, gridStyle, style),\\n          tabIndex: tabIndex }),\\n        childrenToDisplay.length > 0 && React.createElement(\\n          'div',\\n          {\\n            className: 'ReactVirtualized__Grid__innerScrollContainer',\\n            role: containerRole,\\n            style: (0, _extends3.default)({\\n              width: autoContainerWidth ? 'auto' : totalColumnsWidth,\\n              height: totalRowsHeight,\\n              maxWidth: totalColumnsWidth,\\n              maxHeight: totalRowsHeight,\\n              overflow: 'hidden',\\n              pointerEvents: isScrolling ? 'none' : '',\\n              position: 'relative'\\n            }, containerStyle) },\\n          childrenToDisplay\\n        ),\\n        showNoContentRenderer && noContentRenderer()\\n      );\\n    }\\n\\n    /* ---------------------------- Helper methods ---------------------------- */\\n\\n  }, {\\n    key: '_calculateChildrenToRender',\\n    value: function _calculateChildrenToRender() {\\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\\n      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;\\n      var cellRenderer = props.cellRenderer,\\n          cellRangeRenderer = props.cellRangeRenderer,\\n          columnCount = props.columnCount,\\n          deferredMeasurementCache = props.deferredMeasurementCache,\\n          height = props.height,\\n          overscanColumnCount = props.overscanColumnCount,\\n          overscanIndicesGetter = props.overscanIndicesGetter,\\n          overscanRowCount = props.overscanRowCount,\\n          rowCount = props.rowCount,\\n          width = props.width,\\n          isScrollingOptOut = props.isScrollingOptOut;\\n      var scrollDirectionHorizontal = state.scrollDirectionHorizontal,\\n          scrollDirectionVertical = state.scrollDirectionVertical,\\n          instanceProps = state.instanceProps;\\n\\n\\n      var scrollTop = this._initialScrollTop > 0 ? this._initialScrollTop : state.scrollTop;\\n      var scrollLeft = this._initialScrollLeft > 0 ? this._initialScrollLeft : state.scrollLeft;\\n\\n      var isScrolling = this._isScrolling(props, state);\\n\\n      this._childrenToDisplay = [];\\n\\n      // Render only enough columns and rows to cover the visible area of the grid.\\n      if (height > 0 && width > 0) {\\n        var visibleColumnIndices = instanceProps.columnSizeAndPositionManager.getVisibleCellRange({\\n          containerSize: width,\\n          offset: scrollLeft\\n        });\\n        var visibleRowIndices = instanceProps.rowSizeAndPositionManager.getVisibleCellRange({\\n          containerSize: height,\\n          offset: scrollTop\\n        });\\n\\n        var horizontalOffsetAdjustment = instanceProps.columnSizeAndPositionManager.getOffsetAdjustment({\\n          containerSize: width,\\n          offset: scrollLeft\\n        });\\n        var verticalOffsetAdjustment = instanceProps.rowSizeAndPositionManager.getOffsetAdjustment({\\n          containerSize: height,\\n          offset: scrollTop\\n        });\\n\\n        // Store for _invokeOnGridRenderedHelper()\\n        this._renderedColumnStartIndex = visibleColumnIndices.start;\\n        this._renderedColumnStopIndex = visibleColumnIndices.stop;\\n        this._renderedRowStartIndex = visibleRowIndices.start;\\n        this._renderedRowStopIndex = visibleRowIndices.stop;\\n\\n        var overscanColumnIndices = overscanIndicesGetter({\\n          direction: 'horizontal',\\n          cellCount: columnCount,\\n          overscanCellsCount: overscanColumnCount,\\n          scrollDirection: scrollDirectionHorizontal,\\n          startIndex: typeof visibleColumnIndices.start === 'number' ? visibleColumnIndices.start : 0,\\n          stopIndex: typeof visibleColumnIndices.stop === 'number' ? visibleColumnIndices.stop : -1\\n        });\\n\\n        var overscanRowIndices = overscanIndicesGetter({\\n          direction: 'vertical',\\n          cellCount: rowCount,\\n          overscanCellsCount: overscanRowCount,\\n          scrollDirection: scrollDirectionVertical,\\n          startIndex: typeof visibleRowIndices.start === 'number' ? visibleRowIndices.start : 0,\\n          stopIndex: typeof visibleRowIndices.stop === 'number' ? visibleRowIndices.stop : -1\\n        });\\n\\n        // Store for _invokeOnGridRenderedHelper()\\n        var columnStartIndex = overscanColumnIndices.overscanStartIndex;\\n        var columnStopIndex = overscanColumnIndices.overscanStopIndex;\\n        var rowStartIndex = overscanRowIndices.overscanStartIndex;\\n        var rowStopIndex = overscanRowIndices.overscanStopIndex;\\n\\n        // Advanced use-cases (eg CellMeasurer) require batched measurements to determine accurate sizes.\\n        if (deferredMeasurementCache) {\\n          // If rows have a dynamic height, scan the rows we are about to render.\\n          // If any have not yet been measured, then we need to render all columns initially,\\n          // Because the height of the row is equal to the tallest cell within that row,\\n          // (And so we can't know the height without measuring all column-cells first).\\n          if (!deferredMeasurementCache.hasFixedHeight()) {\\n            for (var rowIndex = rowStartIndex; rowIndex <= rowStopIndex; rowIndex++) {\\n              if (!deferredMeasurementCache.has(rowIndex, 0)) {\\n                columnStartIndex = 0;\\n                columnStopIndex = columnCount - 1;\\n                break;\\n              }\\n            }\\n          }\\n\\n          // If columns have a dynamic width, scan the columns we are about to render.\\n          // If any have not yet been measured, then we need to render all rows initially,\\n          // Because the width of the column is equal to the widest cell within that column,\\n          // (And so we can't know the width without measuring all row-cells first).\\n          if (!deferredMeasurementCache.hasFixedWidth()) {\\n            for (var columnIndex = columnStartIndex; columnIndex <= columnStopIndex; columnIndex++) {\\n              if (!deferredMeasurementCache.has(0, columnIndex)) {\\n                rowStartIndex = 0;\\n                rowStopIndex = rowCount - 1;\\n                break;\\n              }\\n            }\\n          }\\n        }\\n\\n        this._childrenToDisplay = cellRangeRenderer({\\n          cellCache: this._cellCache,\\n          cellRenderer: cellRenderer,\\n          columnSizeAndPositionManager: instanceProps.columnSizeAndPositionManager,\\n          columnStartIndex: columnStartIndex,\\n          columnStopIndex: columnStopIndex,\\n          deferredMeasurementCache: deferredMeasurementCache,\\n          horizontalOffsetAdjustment: horizontalOffsetAdjustment,\\n          isScrolling: isScrolling,\\n          isScrollingOptOut: isScrollingOptOut,\\n          parent: this,\\n          rowSizeAndPositionManager: instanceProps.rowSizeAndPositionManager,\\n          rowStartIndex: rowStartIndex,\\n          rowStopIndex: rowStopIndex,\\n          scrollLeft: scrollLeft,\\n          scrollTop: scrollTop,\\n          styleCache: this._styleCache,\\n          verticalOffsetAdjustment: verticalOffsetAdjustment,\\n          visibleColumnIndices: visibleColumnIndices,\\n          visibleRowIndices: visibleRowIndices\\n        });\\n\\n        // update the indices\\n        this._columnStartIndex = columnStartIndex;\\n        this._columnStopIndex = columnStopIndex;\\n        this._rowStartIndex = rowStartIndex;\\n        this._rowStopIndex = rowStopIndex;\\n      }\\n    }\\n\\n    /**\\n     * Sets an :isScrolling flag for a small window of time.\\n     * This flag is used to disable pointer events on the scrollable portion of the Grid.\\n     * This prevents jerky/stuttery mouse-wheel scrolling.\\n     */\\n\\n  }, {\\n    key: '_debounceScrollEnded',\\n    value: function _debounceScrollEnded() {\\n      var scrollingResetTimeInterval = this.props.scrollingResetTimeInterval;\\n\\n\\n      if (this._disablePointerEventsTimeoutId) {\\n        (0, _requestAnimationTimeout.cancelAnimationTimeout)(this._disablePointerEventsTimeoutId);\\n      }\\n\\n      this._disablePointerEventsTimeoutId = (0, _requestAnimationTimeout.requestAnimationTimeout)(this._debounceScrollEndedCallback, scrollingResetTimeInterval);\\n    }\\n  }, {\\n    key: '_handleInvalidatedGridSize',\\n\\n\\n    /**\\n     * Check for batched CellMeasurer size invalidations.\\n     * This will occur the first time one or more previously unmeasured cells are rendered.\\n     */\\n    value: function _handleInvalidatedGridSize() {\\n      if (typeof this._deferredInvalidateColumnIndex === 'number' && typeof this._deferredInvalidateRowIndex === 'number') {\\n        var columnIndex = this._deferredInvalidateColumnIndex;\\n        var rowIndex = this._deferredInvalidateRowIndex;\\n\\n        this._deferredInvalidateColumnIndex = null;\\n        this._deferredInvalidateRowIndex = null;\\n\\n        this.recomputeGridSize({ columnIndex: columnIndex, rowIndex: rowIndex });\\n      }\\n    }\\n  }, {\\n    key: '_invokeOnScrollMemoizer',\\n    value: function _invokeOnScrollMemoizer(_ref6) {\\n      var _this3 = this;\\n\\n      var scrollLeft = _ref6.scrollLeft,\\n          scrollTop = _ref6.scrollTop,\\n          totalColumnsWidth = _ref6.totalColumnsWidth,\\n          totalRowsHeight = _ref6.totalRowsHeight;\\n\\n      this._onScrollMemoizer({\\n        callback: function callback(_ref7) {\\n          var scrollLeft = _ref7.scrollLeft,\\n              scrollTop = _ref7.scrollTop;\\n          var _props7 = _this3.props,\\n              height = _props7.height,\\n              onScroll = _props7.onScroll,\\n              width = _props7.width;\\n\\n\\n          onScroll({\\n            clientHeight: height,\\n            clientWidth: width,\\n            scrollHeight: totalRowsHeight,\\n            scrollLeft: scrollLeft,\\n            scrollTop: scrollTop,\\n            scrollWidth: totalColumnsWidth\\n          });\\n        },\\n        indices: {\\n          scrollLeft: scrollLeft,\\n          scrollTop: scrollTop\\n        }\\n      });\\n    }\\n  }, {\\n    key: '_isScrolling',\\n    value: function _isScrolling() {\\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\\n      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;\\n\\n      // If isScrolling is defined in props, use it to override the value in state\\n      // This is a performance optimization for WindowScroller + Grid\\n      return Object.hasOwnProperty.call(props, 'isScrolling') ? Boolean(props.isScrolling) : Boolean(state.isScrolling);\\n    }\\n  }, {\\n    key: '_maybeCallOnScrollbarPresenceChange',\\n    value: function _maybeCallOnScrollbarPresenceChange() {\\n      if (this._scrollbarPresenceChanged) {\\n        var _onScrollbarPresenceChange = this.props.onScrollbarPresenceChange;\\n\\n\\n        this._scrollbarPresenceChanged = false;\\n\\n        _onScrollbarPresenceChange({\\n          horizontal: this._horizontalScrollBarSize > 0,\\n          size: this.state.instanceProps.scrollbarSize,\\n          vertical: this._verticalScrollBarSize > 0\\n        });\\n      }\\n    }\\n  }, {\\n    key: 'scrollToPosition',\\n\\n\\n    /**\\n     * Scroll to the specified offset(s).\\n     * Useful for animating position changes.\\n     */\\n    value: function scrollToPosition(_ref8) {\\n      var scrollLeft = _ref8.scrollLeft,\\n          scrollTop = _ref8.scrollTop;\\n\\n      var stateUpdate = Grid._getScrollToPositionStateUpdate({\\n        prevState: this.state,\\n        scrollLeft: scrollLeft,\\n        scrollTop: scrollTop\\n      });\\n\\n      if (stateUpdate) {\\n        stateUpdate.needToResetStyleCache = false;\\n        this.setState(stateUpdate);\\n      }\\n    }\\n  }, {\\n    key: '_getCalculatedScrollLeft',\\n    value: function _getCalculatedScrollLeft() {\\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\\n      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;\\n\\n      return Grid._getCalculatedScrollLeft(props, state);\\n    }\\n  }, {\\n    key: '_updateScrollLeftForScrollToColumn',\\n    value: function _updateScrollLeftForScrollToColumn() {\\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\\n      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;\\n\\n      var stateUpdate = Grid._getScrollLeftForScrollToColumnStateUpdate(props, state);\\n      if (stateUpdate) {\\n        stateUpdate.needToResetStyleCache = false;\\n        this.setState(stateUpdate);\\n      }\\n    }\\n  }, {\\n    key: '_getCalculatedScrollTop',\\n    value: function _getCalculatedScrollTop() {\\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\\n      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;\\n\\n      return Grid._getCalculatedScrollTop(props, state);\\n    }\\n  }, {\\n    key: '_resetStyleCache',\\n    value: function _resetStyleCache() {\\n      var styleCache = this._styleCache;\\n      var cellCache = this._cellCache;\\n      var isScrollingOptOut = this.props.isScrollingOptOut;\\n\\n      // Reset cell and style caches once scrolling stops.\\n      // This makes Grid simpler to use (since cells commonly change).\\n      // And it keeps the caches from growing too large.\\n      // Performance is most sensitive when a user is scrolling.\\n      // Don't clear visible cells from cellCache if isScrollingOptOut is specified.\\n      // This keeps the cellCache to a resonable size.\\n\\n      this._cellCache = {};\\n      this._styleCache = {};\\n\\n      // Copy over the visible cell styles so avoid unnecessary re-render.\\n      for (var rowIndex = this._rowStartIndex; rowIndex <= this._rowStopIndex; rowIndex++) {\\n        for (var columnIndex = this._columnStartIndex; columnIndex <= this._columnStopIndex; columnIndex++) {\\n          var key = rowIndex + '-' + columnIndex;\\n          this._styleCache[key] = styleCache[key];\\n\\n          if (isScrollingOptOut) {\\n            this._cellCache[key] = cellCache[key];\\n          }\\n        }\\n      }\\n    }\\n  }, {\\n    key: '_updateScrollTopForScrollToRow',\\n    value: function _updateScrollTopForScrollToRow() {\\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\\n      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;\\n\\n      var stateUpdate = Grid._getScrollTopForScrollToRowStateUpdate(props, state);\\n      if (stateUpdate) {\\n        stateUpdate.needToResetStyleCache = false;\\n        this.setState(stateUpdate);\\n      }\\n    }\\n  }], [{\\n    key: 'getDerivedStateFromProps',\\n    value: function getDerivedStateFromProps(nextProps, prevState) {\\n      var newState = {};\\n\\n      if (nextProps.columnCount === 0 && prevState.scrollLeft !== 0 || nextProps.rowCount === 0 && prevState.scrollTop !== 0) {\\n        newState.scrollLeft = 0;\\n        newState.scrollTop = 0;\\n\\n        // only use scroll{Left,Top} from props if scrollTo{Column,Row} isn't specified\\n        // scrollTo{Column,Row} should override scroll{Left,Top}\\n      } else if (nextProps.scrollLeft !== prevState.scrollLeft && nextProps.scrollToColumn < 0 || nextProps.scrollTop !== prevState.scrollTop && nextProps.scrollToRow < 0) {\\n        (0, _assign2.default)(newState, Grid._getScrollToPositionStateUpdate({\\n          prevState: prevState,\\n          scrollLeft: nextProps.scrollLeft,\\n          scrollTop: nextProps.scrollTop\\n        }));\\n      }\\n\\n      var instanceProps = prevState.instanceProps;\\n\\n      // Initially we should not clearStyleCache\\n\\n      newState.needToResetStyleCache = false;\\n      if (nextProps.columnWidth !== instanceProps.prevColumnWidth || nextProps.rowHeight !== instanceProps.prevRowHeight) {\\n        // Reset cache. set it to {} in render\\n        newState.needToResetStyleCache = true;\\n      }\\n\\n      instanceProps.columnSizeAndPositionManager.configure({\\n        cellCount: nextProps.columnCount,\\n        estimatedCellSize: Grid._getEstimatedColumnSize(nextProps),\\n        cellSizeGetter: Grid._wrapSizeGetter(nextProps.columnWidth)\\n      });\\n\\n      instanceProps.rowSizeAndPositionManager.configure({\\n        cellCount: nextProps.rowCount,\\n        estimatedCellSize: Grid._getEstimatedRowSize(nextProps),\\n        cellSizeGetter: Grid._wrapSizeGetter(nextProps.rowHeight)\\n      });\\n\\n      if (instanceProps.prevColumnCount === 0 || instanceProps.prevRowCount === 0) {\\n        instanceProps.prevColumnCount = 0;\\n        instanceProps.prevRowCount = 0;\\n      }\\n\\n      // If scrolling is controlled outside this component, clear cache when scrolling stops\\n      if (nextProps.autoHeight && nextProps.isScrolling === false && instanceProps.prevIsScrolling === true) {\\n        (0, _assign2.default)(newState, {\\n          isScrolling: false\\n        });\\n      }\\n\\n      var maybeStateA = void 0;\\n      var maybeStateB = void 0;\\n\\n      (0, _calculateSizeAndPositionDataAndUpdateScrollOffset2.default)({\\n        cellCount: instanceProps.prevColumnCount,\\n        cellSize: typeof instanceProps.prevColumnWidth === 'number' ? instanceProps.prevColumnWidth : null,\\n        computeMetadataCallback: function computeMetadataCallback() {\\n          return instanceProps.columnSizeAndPositionManager.resetCell(0);\\n        },\\n        computeMetadataCallbackProps: nextProps,\\n        nextCellsCount: nextProps.columnCount,\\n        nextCellSize: typeof nextProps.columnWidth === 'number' ? nextProps.columnWidth : null,\\n        nextScrollToIndex: nextProps.scrollToColumn,\\n        scrollToIndex: instanceProps.prevScrollToColumn,\\n        updateScrollOffsetForScrollToIndex: function updateScrollOffsetForScrollToIndex() {\\n          maybeStateA = Grid._getScrollLeftForScrollToColumnStateUpdate(nextProps, prevState);\\n        }\\n      });\\n      (0, _calculateSizeAndPositionDataAndUpdateScrollOffset2.default)({\\n        cellCount: instanceProps.prevRowCount,\\n        cellSize: typeof instanceProps.prevRowHeight === 'number' ? instanceProps.prevRowHeight : null,\\n        computeMetadataCallback: function computeMetadataCallback() {\\n          return instanceProps.rowSizeAndPositionManager.resetCell(0);\\n        },\\n        computeMetadataCallbackProps: nextProps,\\n        nextCellsCount: nextProps.rowCount,\\n        nextCellSize: typeof nextProps.rowHeight === 'number' ? nextProps.rowHeight : null,\\n        nextScrollToIndex: nextProps.scrollToRow,\\n        scrollToIndex: instanceProps.prevScrollToRow,\\n        updateScrollOffsetForScrollToIndex: function updateScrollOffsetForScrollToIndex() {\\n          maybeStateB = Grid._getScrollTopForScrollToRowStateUpdate(nextProps, prevState);\\n        }\\n      });\\n\\n      instanceProps.prevColumnCount = nextProps.columnCount;\\n      instanceProps.prevColumnWidth = nextProps.columnWidth;\\n      instanceProps.prevIsScrolling = nextProps.isScrolling === true;\\n      instanceProps.prevRowCount = nextProps.rowCount;\\n      instanceProps.prevRowHeight = nextProps.rowHeight;\\n      instanceProps.prevScrollToColumn = nextProps.scrollToColumn;\\n      instanceProps.prevScrollToRow = nextProps.scrollToRow;\\n\\n      // getting scrollBarSize (moved from componentWillMount)\\n      instanceProps.scrollbarSize = nextProps.getScrollbarSize();\\n      if (instanceProps.scrollbarSize === undefined) {\\n        instanceProps.scrollbarSizeMeasured = false;\\n        instanceProps.scrollbarSize = 0;\\n      } else {\\n        instanceProps.scrollbarSizeMeasured = true;\\n      }\\n\\n      newState.instanceProps = instanceProps;\\n\\n      return (0, _extends3.default)({}, newState, maybeStateA, maybeStateB);\\n    }\\n  }, {\\n    key: '_getEstimatedColumnSize',\\n    value: function _getEstimatedColumnSize(props) {\\n      return typeof props.columnWidth === 'number' ? props.columnWidth : props.estimatedColumnSize;\\n    }\\n  }, {\\n    key: '_getEstimatedRowSize',\\n    value: function _getEstimatedRowSize(props) {\\n      return typeof props.rowHeight === 'number' ? props.rowHeight : props.estimatedRowSize;\\n    }\\n  }, {\\n    key: '_getScrollToPositionStateUpdate',\\n\\n\\n    /**\\n     * Get the updated state after scrolling to\\n     * scrollLeft and scrollTop\\n     */\\n    value: function _getScrollToPositionStateUpdate(_ref9) {\\n      var prevState = _ref9.prevState,\\n          scrollLeft = _ref9.scrollLeft,\\n          scrollTop = _ref9.scrollTop;\\n\\n      var newState = {\\n        scrollPositionChangeReason: SCROLL_POSITION_CHANGE_REASONS.REQUESTED\\n      };\\n\\n      if (typeof scrollLeft === 'number' && scrollLeft >= 0) {\\n        newState.scrollDirectionHorizontal = scrollLeft > prevState.scrollLeft ? _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD : _defaultOverscanIndicesGetter.SCROLL_DIRECTION_BACKWARD;\\n        newState.scrollLeft = scrollLeft;\\n      }\\n\\n      if (typeof scrollTop === 'number' && scrollTop >= 0) {\\n        newState.scrollDirectionVertical = scrollTop > prevState.scrollTop ? _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD : _defaultOverscanIndicesGetter.SCROLL_DIRECTION_BACKWARD;\\n        newState.scrollTop = scrollTop;\\n      }\\n\\n      if (typeof scrollLeft === 'number' && scrollLeft >= 0 && scrollLeft !== prevState.scrollLeft || typeof scrollTop === 'number' && scrollTop >= 0 && scrollTop !== prevState.scrollTop) {\\n        return newState;\\n      }\\n      return null;\\n    }\\n  }, {\\n    key: '_wrapSizeGetter',\\n    value: function _wrapSizeGetter(value) {\\n      return typeof value === 'function' ? value : function () {\\n        return value;\\n      };\\n    }\\n  }, {\\n    key: '_getCalculatedScrollLeft',\\n    value: function _getCalculatedScrollLeft(nextProps, prevState) {\\n      var columnCount = nextProps.columnCount,\\n          height = nextProps.height,\\n          scrollToAlignment = nextProps.scrollToAlignment,\\n          scrollToColumn = nextProps.scrollToColumn,\\n          width = nextProps.width;\\n      var scrollLeft = prevState.scrollLeft,\\n          instanceProps = prevState.instanceProps;\\n\\n\\n      if (columnCount > 0) {\\n        var finalColumn = columnCount - 1;\\n        var targetIndex = scrollToColumn < 0 ? finalColumn : Math.min(finalColumn, scrollToColumn);\\n        var totalRowsHeight = instanceProps.rowSizeAndPositionManager.getTotalSize();\\n        var scrollBarSize = instanceProps.scrollbarSizeMeasured && totalRowsHeight > height ? instanceProps.scrollbarSize : 0;\\n\\n        return instanceProps.columnSizeAndPositionManager.getUpdatedOffsetForIndex({\\n          align: scrollToAlignment,\\n          containerSize: width - scrollBarSize,\\n          currentOffset: scrollLeft,\\n          targetIndex: targetIndex\\n        });\\n      }\\n      return 0;\\n    }\\n  }, {\\n    key: '_getScrollLeftForScrollToColumnStateUpdate',\\n    value: function _getScrollLeftForScrollToColumnStateUpdate(nextProps, prevState) {\\n      var scrollLeft = prevState.scrollLeft;\\n\\n      var calculatedScrollLeft = Grid._getCalculatedScrollLeft(nextProps, prevState);\\n\\n      if (typeof calculatedScrollLeft === 'number' && calculatedScrollLeft >= 0 && scrollLeft !== calculatedScrollLeft) {\\n        return Grid._getScrollToPositionStateUpdate({\\n          prevState: prevState,\\n          scrollLeft: calculatedScrollLeft,\\n          scrollTop: -1\\n        });\\n      }\\n      return null;\\n    }\\n  }, {\\n    key: '_getCalculatedScrollTop',\\n    value: function _getCalculatedScrollTop(nextProps, prevState) {\\n      var height = nextProps.height,\\n          rowCount = nextProps.rowCount,\\n          scrollToAlignment = nextProps.scrollToAlignment,\\n          scrollToRow = nextProps.scrollToRow,\\n          width = nextProps.width;\\n      var scrollTop = prevState.scrollTop,\\n          instanceProps = prevState.instanceProps;\\n\\n\\n      if (rowCount > 0) {\\n        var finalRow = rowCount - 1;\\n        var targetIndex = scrollToRow < 0 ? finalRow : Math.min(finalRow, scrollToRow);\\n        var totalColumnsWidth = instanceProps.columnSizeAndPositionManager.getTotalSize();\\n        var scrollBarSize = instanceProps.scrollbarSizeMeasured && totalColumnsWidth > width ? instanceProps.scrollbarSize : 0;\\n\\n        return instanceProps.rowSizeAndPositionManager.getUpdatedOffsetForIndex({\\n          align: scrollToAlignment,\\n          containerSize: height - scrollBarSize,\\n          currentOffset: scrollTop,\\n          targetIndex: targetIndex\\n        });\\n      }\\n      return 0;\\n    }\\n  }, {\\n    key: '_getScrollTopForScrollToRowStateUpdate',\\n    value: function _getScrollTopForScrollToRowStateUpdate(nextProps, prevState) {\\n      var scrollTop = prevState.scrollTop;\\n\\n      var calculatedScrollTop = Grid._getCalculatedScrollTop(nextProps, prevState);\\n\\n      if (typeof calculatedScrollTop === 'number' && calculatedScrollTop >= 0 && scrollTop !== calculatedScrollTop) {\\n        return Grid._getScrollToPositionStateUpdate({\\n          prevState: prevState,\\n          scrollLeft: -1,\\n          scrollTop: calculatedScrollTop\\n        });\\n      }\\n      return null;\\n    }\\n  }]);\\n  return Grid;\\n}(React.PureComponent);\\n\\nGrid.defaultProps = {\\n  'aria-label': 'grid',\\n  'aria-readonly': true,\\n  autoContainerWidth: false,\\n  autoHeight: false,\\n  autoWidth: false,\\n  cellRangeRenderer: _defaultCellRangeRenderer2.default,\\n  containerRole: 'rowgroup',\\n  containerStyle: {},\\n  estimatedColumnSize: 100,\\n  estimatedRowSize: 30,\\n  getScrollbarSize: _scrollbarSize2.default,\\n  noContentRenderer: renderNull,\\n  onScroll: function onScroll() {},\\n  onScrollbarPresenceChange: function onScrollbarPresenceChange() {},\\n  onSectionRendered: function onSectionRendered() {},\\n  overscanColumnCount: 0,\\n  overscanIndicesGetter: _defaultOverscanIndicesGetter2.default,\\n  overscanRowCount: 10,\\n  role: 'grid',\\n  scrollingResetTimeInterval: DEFAULT_SCROLLING_RESET_TIME_INTERVAL,\\n  scrollToAlignment: 'auto',\\n  scrollToColumn: -1,\\n  scrollToRow: -1,\\n  style: {},\\n  tabIndex: 0,\\n  isScrollingOptOut: false\\n};\\nGrid.propTypes = process.env.NODE_ENV === 'production' ? null : {\\n  \\\"aria-label\\\": _propTypes2.default.string.isRequired,\\n  \\\"aria-readonly\\\": _propTypes2.default.bool,\\n\\n\\n  /**\\n   * Set the width of the inner scrollable container to 'auto'.\\n   * This is useful for single-column Grids to ensure that the column doesn't extend below a vertical scrollbar.\\n   */\\n  autoContainerWidth: _propTypes2.default.bool.isRequired,\\n\\n\\n  /**\\n   * Removes fixed height from the scrollingContainer so that the total height of rows can stretch the window.\\n   * Intended for use with WindowScroller\\n   */\\n  autoHeight: _propTypes2.default.bool.isRequired,\\n\\n\\n  /**\\n   * Removes fixed width from the scrollingContainer so that the total width of rows can stretch the window.\\n   * Intended for use with WindowScroller\\n   */\\n  autoWidth: _propTypes2.default.bool.isRequired,\\n\\n\\n  /** Responsible for rendering a cell given an row and column index.  */\\n  cellRenderer: function cellRenderer() {\\n    return (typeof _types.bpfrpt_proptype_CellRenderer === 'function' ? _types.bpfrpt_proptype_CellRenderer.isRequired ? _types.bpfrpt_proptype_CellRenderer.isRequired : _types.bpfrpt_proptype_CellRenderer : _propTypes2.default.shape(_types.bpfrpt_proptype_CellRenderer).isRequired).apply(this, arguments);\\n  },\\n\\n\\n  /** Responsible for rendering a group of cells given their index ranges.  */\\n  cellRangeRenderer: function cellRangeRenderer() {\\n    return (typeof _types.bpfrpt_proptype_CellRangeRenderer === 'function' ? _types.bpfrpt_proptype_CellRangeRenderer.isRequired ? _types.bpfrpt_proptype_CellRangeRenderer.isRequired : _types.bpfrpt_proptype_CellRangeRenderer : _propTypes2.default.shape(_types.bpfrpt_proptype_CellRangeRenderer).isRequired).apply(this, arguments);\\n  },\\n\\n\\n  /** Optional custom CSS class name to attach to root Grid element.  */\\n  className: _propTypes2.default.string,\\n\\n\\n  /** Number of columns in grid.  */\\n  columnCount: _propTypes2.default.number.isRequired,\\n\\n\\n  /** Either a fixed column width (number) or a function that returns the width of a column given its index.  */\\n  columnWidth: function columnWidth() {\\n    return (typeof _types.bpfrpt_proptype_CellSize === 'function' ? _types.bpfrpt_proptype_CellSize.isRequired ? _types.bpfrpt_proptype_CellSize.isRequired : _types.bpfrpt_proptype_CellSize : _propTypes2.default.shape(_types.bpfrpt_proptype_CellSize).isRequired).apply(this, arguments);\\n  },\\n\\n\\n  /** Unfiltered props for the Grid container. */\\n  containerProps: _propTypes2.default.object,\\n\\n\\n  /** ARIA role for the cell-container.  */\\n  containerRole: _propTypes2.default.string.isRequired,\\n\\n\\n  /** Optional inline style applied to inner cell-container */\\n  containerStyle: _propTypes2.default.object.isRequired,\\n\\n\\n  /**\\n   * If CellMeasurer is used to measure this Grid's children, this should be a pointer to its CellMeasurerCache.\\n   * A shared CellMeasurerCache reference enables Grid and CellMeasurer to share measurement data.\\n   */\\n  deferredMeasurementCache: _propTypes2.default.object,\\n\\n\\n  /**\\n   * Used to estimate the total width of a Grid before all of its columns have actually been measured.\\n   * The estimated total width is adjusted as columns are rendered.\\n   */\\n  estimatedColumnSize: _propTypes2.default.number.isRequired,\\n\\n\\n  /**\\n   * Used to estimate the total height of a Grid before all of its rows have actually been measured.\\n   * The estimated total height is adjusted as rows are rendered.\\n   */\\n  estimatedRowSize: _propTypes2.default.number.isRequired,\\n\\n\\n  /** Exposed for testing purposes only.  */\\n  getScrollbarSize: _propTypes2.default.func.isRequired,\\n\\n\\n  /** Height of Grid; this property determines the number of visible (vs virtualized) rows.  */\\n  height: _propTypes2.default.number.isRequired,\\n\\n\\n  /** Optional custom id to attach to root Grid element.  */\\n  id: _propTypes2.default.string,\\n\\n\\n  /**\\n   * Override internal is-scrolling state tracking.\\n   * This property is primarily intended for use with the WindowScroller component.\\n   */\\n  isScrolling: _propTypes2.default.bool,\\n\\n\\n  /**\\n   * Opt-out of isScrolling param passed to cellRangeRenderer.\\n   * To avoid the extra render when scroll stops.\\n   */\\n  isScrollingOptOut: _propTypes2.default.bool.isRequired,\\n\\n\\n  /** Optional renderer to be used in place of rows when either :rowCount or :columnCount is 0.  */\\n  noContentRenderer: function noContentRenderer() {\\n    return (typeof _types.bpfrpt_proptype_NoContentRenderer === 'function' ? _types.bpfrpt_proptype_NoContentRenderer.isRequired ? _types.bpfrpt_proptype_NoContentRenderer.isRequired : _types.bpfrpt_proptype_NoContentRenderer : _propTypes2.default.shape(_types.bpfrpt_proptype_NoContentRenderer).isRequired).apply(this, arguments);\\n  },\\n\\n\\n  /**\\n   * Callback invoked whenever the scroll offset changes within the inner scrollable region.\\n   * This callback can be used to sync scrolling between lists, tables, or grids.\\n   */\\n  onScroll: _propTypes2.default.func.isRequired,\\n\\n\\n  /**\\n   * Called whenever a horizontal or vertical scrollbar is added or removed.\\n   * This prop is not intended for end-user use;\\n   * It is used by MultiGrid to support fixed-row/fixed-column scroll syncing.\\n   */\\n  onScrollbarPresenceChange: _propTypes2.default.func.isRequired,\\n\\n\\n  /** Callback invoked with information about the section of the Grid that was just rendered.  */\\n  onSectionRendered: _propTypes2.default.func.isRequired,\\n\\n\\n  /**\\n   * Number of columns to render before/after the visible section of the grid.\\n   * These columns can help for smoother scrolling on touch devices or browsers that send scroll events infrequently.\\n   */\\n  overscanColumnCount: _propTypes2.default.number.isRequired,\\n\\n\\n  /**\\n   * Calculates the number of cells to overscan before and after a specified range.\\n   * This function ensures that overscanning doesn't exceed the available cells.\\n   */\\n  overscanIndicesGetter: function overscanIndicesGetter() {\\n    return (typeof _types.bpfrpt_proptype_OverscanIndicesGetter === 'function' ? _types.bpfrpt_proptype_OverscanIndicesGetter.isRequired ? _types.bpfrpt_proptype_OverscanIndicesGetter.isRequired : _types.bpfrpt_proptype_OverscanIndicesGetter : _propTypes2.default.shape(_types.bpfrpt_proptype_OverscanIndicesGetter).isRequired).apply(this, arguments);\\n  },\\n\\n\\n  /**\\n   * Number of rows to render above/below the visible section of the grid.\\n   * These rows can help for smoother scrolling on touch devices or browsers that send scroll events infrequently.\\n   */\\n  overscanRowCount: _propTypes2.default.number.isRequired,\\n\\n\\n  /** ARIA role for the grid element.  */\\n  role: _propTypes2.default.string.isRequired,\\n\\n\\n  /**\\n   * Either a fixed row height (number) or a function that returns the height of a row given its index.\\n   * Should implement the following interface: ({ index: number }): number\\n   */\\n  rowHeight: function rowHeight() {\\n    return (typeof _types.bpfrpt_proptype_CellSize === 'function' ? _types.bpfrpt_proptype_CellSize.isRequired ? _types.bpfrpt_proptype_CellSize.isRequired : _types.bpfrpt_proptype_CellSize : _propTypes2.default.shape(_types.bpfrpt_proptype_CellSize).isRequired).apply(this, arguments);\\n  },\\n\\n\\n  /** Number of rows in grid.  */\\n  rowCount: _propTypes2.default.number.isRequired,\\n\\n\\n  /** Wait this amount of time after the last scroll event before resetting Grid `pointer-events`. */\\n  scrollingResetTimeInterval: _propTypes2.default.number.isRequired,\\n\\n\\n  /** Horizontal offset. */\\n  scrollLeft: _propTypes2.default.number,\\n\\n\\n  /**\\n   * Controls scroll-to-cell behavior of the Grid.\\n   * The default (\\\"auto\\\") scrolls the least amount possible to ensure that the specified cell is fully visible.\\n   * Use \\\"start\\\" to align cells to the top/left of the Grid and \\\"end\\\" to align bottom/right.\\n   */\\n  scrollToAlignment: function scrollToAlignment() {\\n    return (typeof _types.bpfrpt_proptype_Alignment === 'function' ? _types.bpfrpt_proptype_Alignment.isRequired ? _types.bpfrpt_proptype_Alignment.isRequired : _types.bpfrpt_proptype_Alignment : _propTypes2.default.shape(_types.bpfrpt_proptype_Alignment).isRequired).apply(this, arguments);\\n  },\\n\\n\\n  /** Column index to ensure visible (by forcefully scrolling if necessary) */\\n  scrollToColumn: _propTypes2.default.number.isRequired,\\n\\n\\n  /** Vertical offset. */\\n  scrollTop: _propTypes2.default.number,\\n\\n\\n  /** Row index to ensure visible (by forcefully scrolling if necessary) */\\n  scrollToRow: _propTypes2.default.number.isRequired,\\n\\n\\n  /** Optional inline style */\\n  style: _propTypes2.default.object.isRequired,\\n\\n\\n  /** Tab index for focus */\\n  tabIndex: _propTypes2.default.number,\\n\\n\\n  /** Width of Grid; this property determines the number of visible (vs virtualized) columns.  */\\n  width: _propTypes2.default.number.isRequired\\n};\\n\\n\\n(0, _reactLifecyclesCompat.polyfill)(Grid);\\nexports.default = Grid;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"process\",\"require\",\"module\",\"exports\",\"shadow$shims\",\"_interopRequireDefault\",\"obj\",\"__esModule\",\"default\",\"Object\",\"defineProperty\",\"value\",\"DEFAULT_SCROLLING_RESET_TIME_INTERVAL\",\"undefined\",\"_assign\",\"_assign2\",\"_extends2\",\"_extends3\",\"_getPrototypeOf\",\"_getPrototypeOf2\",\"_classCallCheck2\",\"_classCallCheck3\",\"_createClass2\",\"_createClass3\",\"_possibleConstructorReturn2\",\"_possibleConstructorReturn3\",\"_inherits2\",\"_inherits3\",\"React\",\"_interopRequireWildcard\",\"newObj\",\"key\",\"prototype\",\"hasOwnProperty\",\"call\",\"_react\",\"_classnames\",\"_classnames2\",\"_calculateSizeAndPositionDataAndUpdateScrollOffset\",\"_calculateSizeAndPositionDataAndUpdateScrollOffset2\",\"_ScalingCellSizeAndPositionManager\",\"_ScalingCellSizeAndPositionManager2\",\"_createCallbackMemoizer\",\"_createCallbackMemoizer2\",\"_defaultOverscanIndicesGetter\",\"_defaultOverscanIndicesGetter2\",\"_updateScrollIndexHelper\",\"_updateScrollIndexHelper2\",\"_defaultCellRangeRenderer\",\"_defaultCellRangeRenderer2\",\"_scrollbarSize\",\"_scrollbarSize2\",\"_reactLifecyclesCompat\",\"_requestAnimationTimeout\",\"_propTypes\",\"Grid\",\"_React$PureComponent\",\"props\",\"_this\",\"__proto__\",\"_onGridRenderedMemoizer\",\"_onScrollMemoizer\",\"_deferredInvalidateColumnIndex\",\"_deferredInvalidateRowIndex\",\"_recomputeScrollLeftFlag\",\"_recomputeScrollTopFlag\",\"_horizontalScrollBarSize\",\"_verticalScrollBarSize\",\"_scrollbarPresenceChanged\",\"_renderedColumnStartIndex\",\"_renderedColumnStopIndex\",\"_renderedRowStartIndex\",\"_renderedRowStopIndex\",\"_styleCache\",\"_cellCache\",\"_debounceScrollEndedCallback\",\"_this._debounceScrollEndedCallback\",\"_disablePointerEventsTimeoutId\",\"setState\",\"isScrolling\",\"needToResetStyleCache\",\"_invokeOnGridRenderedHelper\",\"_this._invokeOnGridRenderedHelper\",\"callback\",\"onSectionRendered\",\"indices\",\"columnOverscanStartIndex\",\"_columnStartIndex\",\"columnOverscanStopIndex\",\"_columnStopIndex\",\"columnStartIndex\",\"columnStopIndex\",\"rowOverscanStartIndex\",\"_rowStartIndex\",\"rowOverscanStopIndex\",\"_rowStopIndex\",\"rowStartIndex\",\"rowStopIndex\",\"_setScrollingContainerRef\",\"_this._setScrollingContainerRef\",\"ref\",\"_scrollingContainer\",\"_onScroll\",\"_this._onScroll\",\"event\",\"target\",\"handleScrollEvent\",\"columnSizeAndPositionManager\",\"cellCount\",\"columnCount\",\"cellSizeGetter\",\"params\",\"_wrapSizeGetter\",\"columnWidth\",\"estimatedCellSize\",\"_getEstimatedColumnSize\",\"rowSizeAndPositionManager\",\"rowCount\",\"rowHeight\",\"_getEstimatedRowSize\",\"state\",\"instanceProps\",\"prevColumnWidth\",\"prevRowHeight\",\"prevColumnCount\",\"prevRowCount\",\"prevIsScrolling\",\"prevScrollToColumn\",\"scrollToColumn\",\"prevScrollToRow\",\"scrollToRow\",\"scrollbarSize\",\"scrollbarSizeMeasured\",\"scrollDirectionHorizontal\",\"SCROLL_DIRECTION_FORWARD\",\"scrollDirectionVertical\",\"scrollLeft\",\"scrollTop\",\"scrollPositionChangeReason\",\"_initialScrollTop\",\"_getCalculatedScrollTop\",\"_initialScrollLeft\",\"_getCalculatedScrollLeft\",\"getOffsetForCell\",\"_ref\",\"arguments\",\"length\",\"_ref$alignment\",\"alignment\",\"scrollToAlignment\",\"_ref$columnIndex\",\"columnIndex\",\"_ref$rowIndex\",\"rowIndex\",\"offsetProps\",\"getTotalRowsHeight\",\"getTotalSize\",\"getTotalColumnsWidth\",\"_ref2\",\"_ref2$scrollLeft\",\"scrollLeftParam\",\"_ref2$scrollTop\",\"scrollTopParam\",\"_debounceScrollEnded\",\"_props\",\"autoHeight\",\"autoWidth\",\"height\",\"width\",\"totalRowsHeight\",\"totalColumnsWidth\",\"Math\",\"min\",\"max\",\"newState\",\"_scrollDirectionHorizontal\",\"SCROLL_DIRECTION_BACKWARD\",\"_scrollDirectionVertical\",\"OBSERVED\",\"_invokeOnScrollMemoizer\",\"invalidateCellSizeAfterRender\",\"_ref3\",\"measureAllCells\",\"_props2\",\"getSizeAndPositionOfCell\",\"recomputeGridSize\",\"_ref4\",\"_ref4$columnIndex\",\"_ref4$rowIndex\",\"_props3\",\"resetCell\",\"forceUpdate\",\"scrollToCell\",\"_ref5\",\"_updateScrollLeftForScrollToColumn\",\"_updateScrollTopForScrollToRow\",\"componentDidMount\",\"_props4\",\"getScrollbarSize\",\"_handleInvalidatedGridSize\",\"prevState\",\"stateUpdate\",\"_getScrollToPositionStateUpdate\",\"sizeIsBiggerThanZero\",\"_maybeCallOnScrollbarPresenceChange\",\"componentDidUpdate\",\"prevProps\",\"_this2\",\"_props5\",\"_state\",\"columnOrRowCountJustIncreasedFromZero\",\"REQUESTED\",\"sizeJustIncreasedFromZero\",\"cellSizeAndPositionManager\",\"previousCellsCount\",\"previousCellSize\",\"previousScrollToAlignment\",\"previousScrollToIndex\",\"previousSize\",\"scrollOffset\",\"scrollToIndex\",\"size\",\"updateScrollIndexCallback\",\"componentWillUnmount\",\"cancelAnimationTimeout\",\"render\",\"_props6\",\"autoContainerWidth\",\"className\",\"containerProps\",\"containerRole\",\"containerStyle\",\"id\",\"noContentRenderer\",\"role\",\"style\",\"tabIndex\",\"_state2\",\"_isScrolling\",\"gridStyle\",\"boxSizing\",\"direction\",\"position\",\"WebkitOverflowScrolling\",\"willChange\",\"_resetStyleCache\",\"_calculateChildrenToRender\",\"verticalScrollBarSize\",\"horizontalScrollBarSize\",\"overflowX\",\"overflowY\",\"childrenToDisplay\",\"_childrenToDisplay\",\"showNoContentRenderer\",\"createElement\",\"onScroll\",\"maxWidth\",\"maxHeight\",\"overflow\",\"pointerEvents\",\"cellRenderer\",\"cellRangeRenderer\",\"deferredMeasurementCache\",\"overscanColumnCount\",\"overscanIndicesGetter\",\"overscanRowCount\",\"isScrollingOptOut\",\"visibleColumnIndices\",\"getVisibleCellRange\",\"containerSize\",\"offset\",\"visibleRowIndices\",\"horizontalOffsetAdjustment\",\"getOffsetAdjustment\",\"verticalOffsetAdjustment\",\"start\",\"stop\",\"overscanColumnIndices\",\"overscanCellsCount\",\"scrollDirection\",\"startIndex\",\"stopIndex\",\"overscanRowIndices\",\"overscanStartIndex\",\"overscanStopIndex\",\"hasFixedHeight\",\"has\",\"hasFixedWidth\",\"cellCache\",\"parent\",\"styleCache\",\"scrollingResetTimeInterval\",\"requestAnimationTimeout\",\"_ref6\",\"_this3\",\"_ref7\",\"_props7\",\"clientHeight\",\"clientWidth\",\"scrollHeight\",\"scrollWidth\",\"_onScrollbarPresenceChange\",\"onScrollbarPresenceChange\",\"horizontal\",\"vertical\",\"scrollToPosition\",\"_ref8\",\"_getScrollLeftForScrollToColumnStateUpdate\",\"_getScrollTopForScrollToRowStateUpdate\",\"getDerivedStateFromProps\",\"nextProps\",\"configure\",\"maybeStateA\",\"maybeStateB\",\"cellSize\",\"computeMetadataCallback\",\"computeMetadataCallbackProps\",\"nextCellsCount\",\"nextCellSize\",\"nextScrollToIndex\",\"updateScrollOffsetForScrollToIndex\",\"estimatedColumnSize\",\"estimatedRowSize\",\"_ref9\",\"finalColumn\",\"targetIndex\",\"getUpdatedOffsetForIndex\",\"align\",\"scrollBarSize\",\"currentOffset\",\"calculatedScrollLeft\",\"finalRow\",\"calculatedScrollTop\",\"PureComponent\",\"defaultProps\",\"renderNull\",\"propTypes\",\"polyfill\"]\n}\n"]