["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/react-virtualized/dist/commonjs/InfiniteLoader/InfiniteLoader.js"],"~:js","shadow$provide.module$node_modules$react_virtualized$dist$commonjs$InfiniteLoader$InfiniteLoader=function(b,e,a,f,c,m){function d(a){return a&&a.__esModule?a:{default:a}}function k(a){var b=a.lastRenderedStartIndex,c=a.stopIndex;return!(a.startIndex>a.lastRenderedStopIndex||c<b)}function l(a){var b=a.isRowLoaded,c=a.minimumBatchSize,d=a.rowCount,e=a.stopIndex,g=[],f=null,h=null;for(a=a.startIndex;a<=e;a++)b({index:a})?null!==h&&(g.push({startIndex:f,stopIndex:h}),f=h=null):(h=a,null===f&&(f=a));if(null!==\nh){d=Math.min(Math.max(h,f+c-1),d-1);for(e=h+1;e<=d&&!b({index:e});e++)h=e;g.push({startIndex:f,stopIndex:h})}if(g.length)for(f=g[0];f.stopIndex-f.startIndex+1<c&&0<f.startIndex&&(h=f.startIndex-1,!b({index:h}));)f.startIndex=h;return g}function h(a){var b=1<arguments.length&&void 0!==arguments[1]?arguments[1]:0,c=\"function\"===typeof a.recomputeGridSize?a.recomputeGridSize:a.recomputeRowHeights;c?c.call(a,b):a.forceUpdate()}Object.defineProperty(c,\"__esModule\",{value:!0});b=a(\"module$node_modules$babel_runtime$core_js$object$get_prototype_of\");\nvar p=d(b);b=a(\"module$node_modules$babel_runtime$helpers$classCallCheck\");var r=d(b);b=a(\"module$node_modules$babel_runtime$helpers$createClass\");var q=d(b);b=a(\"module$node_modules$babel_runtime$helpers$possibleConstructorReturn\");var g=d(b);b=a(\"module$node_modules$babel_runtime$helpers$inherits\");var n=d(b);c.isRangeVisible=k;c.scanForUnloadedRanges=l;c.forceUpdateReactVirtualizedComponent=h;b=function(a){if(a&&a.__esModule)return a;var b={};if(null!=a)for(var c in a)Object.prototype.hasOwnProperty.call(a,\nc)&&(b[c]=a[c]);b.default=a;return b}(a(\"module$node_modules$react$index\"));e=a(\"module$node_modules$prop_types$index\");d(e);a=a(\"module$node_modules$react_virtualized$dist$commonjs$utils$createCallbackMemoizer\");var v=d(a);a=function(a){function b(a,c){(0,r.default)(this,b);a=(0,g.default)(this,(b.__proto__||(0,p.default)(b)).call(this,a,c));a._loadMoreRowsMemoizer=(0,v.default)();a._onRowsRendered=a._onRowsRendered.bind(a);a._registerChild=a._registerChild.bind(a);return a}(0,n.default)(b,a);(0,\nq.default)(b,[{key:\"resetLoadMoreRowsCache\",value:function(a){this._loadMoreRowsMemoizer=(0,v.default)();a&&this._doStuff(this._lastRenderedStartIndex,this._lastRenderedStopIndex)}},{key:\"render\",value:function(){var a=this.props.children;return a({onRowsRendered:this._onRowsRendered,registerChild:this._registerChild})}},{key:\"_loadUnloadedRanges\",value:function(a){var b=this,c=this.props.loadMoreRows;a.forEach(function(a){var d=c(a);d&&d.then(function(){k({lastRenderedStartIndex:b._lastRenderedStartIndex,\nlastRenderedStopIndex:b._lastRenderedStopIndex,startIndex:a.startIndex,stopIndex:a.stopIndex})&&b._registeredChild&&h(b._registeredChild,b._lastRenderedStartIndex)})})}},{key:\"_onRowsRendered\",value:function(a){var b=a.startIndex;a=a.stopIndex;this._lastRenderedStartIndex=b;this._lastRenderedStopIndex=a;this._doStuff(b,a)}},{key:\"_doStuff\",value:function(a,b){var c=this,d=this.props,e=d.rowCount,g=d.threshold,f=l({isRowLoaded:d.isRowLoaded,minimumBatchSize:d.minimumBatchSize,rowCount:e,startIndex:Math.max(0,\na-g),stopIndex:Math.min(e-1,b+g)});a=f.reduce(function(a,b){return a.concat([b.startIndex,b.stopIndex])},[]);this._loadMoreRowsMemoizer({callback:function(){c._loadUnloadedRanges(f)},indices:{squashedUnloadedRanges:a}})}},{key:\"_registerChild\",value:function(a){this._registeredChild=a}}]);return b}(b.PureComponent);a.defaultProps={minimumBatchSize:10,rowCount:0,threshold:15};c.default=a;a.propTypes={}}","~:source","shadow$provide[\"module$node_modules$react_virtualized$dist$commonjs$InfiniteLoader$InfiniteLoader\"] = function(global,process,require,module,exports,shadow$shims) {\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = require('babel-runtime/helpers/inherits');\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nexports.isRangeVisible = isRangeVisible;\nexports.scanForUnloadedRanges = scanForUnloadedRanges;\nexports.forceUpdateReactVirtualizedComponent = forceUpdateReactVirtualizedComponent;\n\nvar _react = require('react');\n\nvar React = _interopRequireWildcard(_react);\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _createCallbackMemoizer = require('../utils/createCallbackMemoizer');\n\nvar _createCallbackMemoizer2 = _interopRequireDefault(_createCallbackMemoizer);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Higher-order component that manages lazy-loading for \"infinite\" data.\n * This component decorates a virtual component and just-in-time prefetches rows as a user scrolls.\n * It is intended as a convenience component; fork it if you'd like finer-grained control over data-loading.\n */\nvar InfiniteLoader = function (_React$PureComponent) {\n  (0, _inherits3.default)(InfiniteLoader, _React$PureComponent);\n\n  function InfiniteLoader(props, context) {\n    (0, _classCallCheck3.default)(this, InfiniteLoader);\n\n    var _this = (0, _possibleConstructorReturn3.default)(this, (InfiniteLoader.__proto__ || (0, _getPrototypeOf2.default)(InfiniteLoader)).call(this, props, context));\n\n    _this._loadMoreRowsMemoizer = (0, _createCallbackMemoizer2.default)();\n\n    _this._onRowsRendered = _this._onRowsRendered.bind(_this);\n    _this._registerChild = _this._registerChild.bind(_this);\n    return _this;\n  }\n\n  (0, _createClass3.default)(InfiniteLoader, [{\n    key: 'resetLoadMoreRowsCache',\n    value: function resetLoadMoreRowsCache(autoReload) {\n      this._loadMoreRowsMemoizer = (0, _createCallbackMemoizer2.default)();\n\n      if (autoReload) {\n        this._doStuff(this._lastRenderedStartIndex, this._lastRenderedStopIndex);\n      }\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var children = this.props.children;\n\n\n      return children({\n        onRowsRendered: this._onRowsRendered,\n        registerChild: this._registerChild\n      });\n    }\n  }, {\n    key: '_loadUnloadedRanges',\n    value: function _loadUnloadedRanges(unloadedRanges) {\n      var _this2 = this;\n\n      var loadMoreRows = this.props.loadMoreRows;\n\n\n      unloadedRanges.forEach(function (unloadedRange) {\n        var promise = loadMoreRows(unloadedRange);\n        if (promise) {\n          promise.then(function () {\n            // Refresh the visible rows if any of them have just been loaded.\n            // Otherwise they will remain in their unloaded visual state.\n            if (isRangeVisible({\n              lastRenderedStartIndex: _this2._lastRenderedStartIndex,\n              lastRenderedStopIndex: _this2._lastRenderedStopIndex,\n              startIndex: unloadedRange.startIndex,\n              stopIndex: unloadedRange.stopIndex\n            })) {\n              if (_this2._registeredChild) {\n                forceUpdateReactVirtualizedComponent(_this2._registeredChild, _this2._lastRenderedStartIndex);\n              }\n            }\n          });\n        }\n      });\n    }\n  }, {\n    key: '_onRowsRendered',\n    value: function _onRowsRendered(_ref) {\n      var startIndex = _ref.startIndex,\n          stopIndex = _ref.stopIndex;\n\n      this._lastRenderedStartIndex = startIndex;\n      this._lastRenderedStopIndex = stopIndex;\n\n      this._doStuff(startIndex, stopIndex);\n    }\n  }, {\n    key: '_doStuff',\n    value: function _doStuff(startIndex, stopIndex) {\n      var _this3 = this;\n\n      var _props = this.props,\n          isRowLoaded = _props.isRowLoaded,\n          minimumBatchSize = _props.minimumBatchSize,\n          rowCount = _props.rowCount,\n          threshold = _props.threshold;\n\n\n      var unloadedRanges = scanForUnloadedRanges({\n        isRowLoaded: isRowLoaded,\n        minimumBatchSize: minimumBatchSize,\n        rowCount: rowCount,\n        startIndex: Math.max(0, startIndex - threshold),\n        stopIndex: Math.min(rowCount - 1, stopIndex + threshold)\n      });\n\n      // For memoize comparison\n      var squashedUnloadedRanges = unloadedRanges.reduce(function (reduced, unloadedRange) {\n        return reduced.concat([unloadedRange.startIndex, unloadedRange.stopIndex]);\n      }, []);\n\n      this._loadMoreRowsMemoizer({\n        callback: function callback() {\n          _this3._loadUnloadedRanges(unloadedRanges);\n        },\n        indices: { squashedUnloadedRanges: squashedUnloadedRanges }\n      });\n    }\n  }, {\n    key: '_registerChild',\n    value: function _registerChild(registeredChild) {\n      this._registeredChild = registeredChild;\n    }\n  }]);\n  return InfiniteLoader;\n}(React.PureComponent);\n\n/**\n * Determines if the specified start/stop range is visible based on the most recently rendered range.\n */\n\n\nInfiniteLoader.defaultProps = {\n  minimumBatchSize: 10,\n  rowCount: 0,\n  threshold: 15\n};\nexports.default = InfiniteLoader;\nInfiniteLoader.propTypes = process.env.NODE_ENV !== \"production\" ? {\n  /**\n   * Function responsible for rendering a virtualized component.\n   * This function should implement the following signature:\n   * ({ onRowsRendered, registerChild }) => PropTypes.element\n   *\n   * The specified :onRowsRendered function should be passed through to the child's :onRowsRendered property.\n   * The :registerChild callback should be set as the virtualized component's :ref.\n   */\n  children: _propTypes2.default.func.isRequired,\n\n  /**\n   * Function responsible for tracking the loaded state of each row.\n   * It should implement the following signature: ({ index: number }): boolean\n   */\n  isRowLoaded: _propTypes2.default.func.isRequired,\n\n  /**\n   * Callback to be invoked when more rows must be loaded.\n   * It should implement the following signature: ({ startIndex, stopIndex }): Promise\n   * The returned Promise should be resolved once row data has finished loading.\n   * It will be used to determine when to refresh the list with the newly-loaded data.\n   * This callback may be called multiple times in reaction to a single scroll event.\n   */\n  loadMoreRows: _propTypes2.default.func.isRequired,\n\n  /**\n   * Minimum number of rows to be loaded at a time.\n   * This property can be used to batch requests to reduce HTTP requests.\n   */\n  minimumBatchSize: _propTypes2.default.number.isRequired,\n\n  /**\n   * Number of rows in list; can be arbitrary high number if actual number is unknown.\n   */\n  rowCount: _propTypes2.default.number.isRequired,\n\n  /**\n   * Threshold at which to pre-fetch data.\n   * A threshold X means that data will start loading when a user scrolls within X rows.\n   * This value defaults to 15.\n   */\n  threshold: _propTypes2.default.number.isRequired\n} : {};\nfunction isRangeVisible(_ref2) {\n  var lastRenderedStartIndex = _ref2.lastRenderedStartIndex,\n      lastRenderedStopIndex = _ref2.lastRenderedStopIndex,\n      startIndex = _ref2.startIndex,\n      stopIndex = _ref2.stopIndex;\n\n  return !(startIndex > lastRenderedStopIndex || stopIndex < lastRenderedStartIndex);\n}\n\n/**\n * Returns all of the ranges within a larger range that contain unloaded rows.\n */\nfunction scanForUnloadedRanges(_ref3) {\n  var isRowLoaded = _ref3.isRowLoaded,\n      minimumBatchSize = _ref3.minimumBatchSize,\n      rowCount = _ref3.rowCount,\n      startIndex = _ref3.startIndex,\n      stopIndex = _ref3.stopIndex;\n\n  var unloadedRanges = [];\n\n  var rangeStartIndex = null;\n  var rangeStopIndex = null;\n\n  for (var index = startIndex; index <= stopIndex; index++) {\n    var loaded = isRowLoaded({ index: index });\n\n    if (!loaded) {\n      rangeStopIndex = index;\n      if (rangeStartIndex === null) {\n        rangeStartIndex = index;\n      }\n    } else if (rangeStopIndex !== null) {\n      unloadedRanges.push({\n        startIndex: rangeStartIndex,\n        stopIndex: rangeStopIndex\n      });\n\n      rangeStartIndex = rangeStopIndex = null;\n    }\n  }\n\n  // If :rangeStopIndex is not null it means we haven't ran out of unloaded rows.\n  // Scan forward to try filling our :minimumBatchSize.\n  if (rangeStopIndex !== null) {\n    var potentialStopIndex = Math.min(Math.max(rangeStopIndex, rangeStartIndex + minimumBatchSize - 1), rowCount - 1);\n\n    for (var _index = rangeStopIndex + 1; _index <= potentialStopIndex; _index++) {\n      if (!isRowLoaded({ index: _index })) {\n        rangeStopIndex = _index;\n      } else {\n        break;\n      }\n    }\n\n    unloadedRanges.push({\n      startIndex: rangeStartIndex,\n      stopIndex: rangeStopIndex\n    });\n  }\n\n  // Check to see if our first range ended prematurely.\n  // In this case we should scan backwards to try filling our :minimumBatchSize.\n  if (unloadedRanges.length) {\n    var firstUnloadedRange = unloadedRanges[0];\n\n    while (firstUnloadedRange.stopIndex - firstUnloadedRange.startIndex + 1 < minimumBatchSize && firstUnloadedRange.startIndex > 0) {\n      var _index2 = firstUnloadedRange.startIndex - 1;\n\n      if (!isRowLoaded({ index: _index2 })) {\n        firstUnloadedRange.startIndex = _index2;\n      } else {\n        break;\n      }\n    }\n  }\n\n  return unloadedRanges;\n}\n\n/**\n * Since RV components use shallowCompare we need to force a render (even though props haven't changed).\n * However InfiniteLoader may wrap a Grid or it may wrap a Table or List.\n * In the first case the built-in React forceUpdate() method is sufficient to force a re-render,\n * But in the latter cases we need to use the RV-specific forceUpdateGrid() method.\n * Else the inner Grid will not be re-rendered and visuals may be stale.\n *\n * Additionally, while a Grid is scrolling the cells can be cached,\n * So it's important to invalidate that cache by recalculating sizes\n * before forcing a rerender.\n */\nfunction forceUpdateReactVirtualizedComponent(component) {\n  var currentIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n  var recomputeSize = typeof component.recomputeGridSize === 'function' ? component.recomputeGridSize : component.recomputeRowHeights;\n\n  if (recomputeSize) {\n    recomputeSize.call(component, currentIndex);\n  } else {\n    component.forceUpdate();\n  }\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$react_virtualized$dist$commonjs$utils$createCallbackMemoizer","~$module$node_modules$babel_runtime$helpers$possibleConstructorReturn","~$module$node_modules$react$index","~$module$node_modules$prop_types$index","~$shadow.js","~$module$node_modules$babel_runtime$helpers$inherits","~$module$node_modules$babel_runtime$core_js$object$get_prototype_of","~$module$node_modules$babel_runtime$helpers$classCallCheck","~$module$node_modules$babel_runtime$helpers$createClass"]],"~:properties",["^5",["minimumBatchSize","callback","startIndex","index","squashedUnloadedRanges","onRowsRendered","isRangeVisible","key","__esModule","rowCount","propTypes","isRowLoaded","registerChild","value","_onRowsRendered","threshold","stopIndex","_registeredChild","_loadMoreRowsMemoizer","defaultProps","lastRenderedStartIndex","_lastRenderedStopIndex","scanForUnloadedRanges","_lastRenderedStartIndex","forceUpdateReactVirtualizedComponent","default","lastRenderedStopIndex","indices","_registerChild"]],"~:compiled-at",1537815743274,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$react_virtualized$dist$commonjs$InfiniteLoader$InfiniteLoader.js\",\n\"lineCount\":7,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/react-virtualized/dist/commonjs/InfiniteLoader/InfiniteLoader.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$react_virtualized$dist$commonjs$InfiniteLoader$InfiniteLoader\\\"] = function(global,process,require,module,exports,shadow$shims) {\\n'use strict';\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\n\\nvar _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');\\n\\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\\n\\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\\n\\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\\n\\nvar _createClass2 = require('babel-runtime/helpers/createClass');\\n\\nvar _createClass3 = _interopRequireDefault(_createClass2);\\n\\nvar _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');\\n\\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\\n\\nvar _inherits2 = require('babel-runtime/helpers/inherits');\\n\\nvar _inherits3 = _interopRequireDefault(_inherits2);\\n\\nexports.isRangeVisible = isRangeVisible;\\nexports.scanForUnloadedRanges = scanForUnloadedRanges;\\nexports.forceUpdateReactVirtualizedComponent = forceUpdateReactVirtualizedComponent;\\n\\nvar _react = require('react');\\n\\nvar React = _interopRequireWildcard(_react);\\n\\nvar _propTypes = require('prop-types');\\n\\nvar _propTypes2 = _interopRequireDefault(_propTypes);\\n\\nvar _createCallbackMemoizer = require('../utils/createCallbackMemoizer');\\n\\nvar _createCallbackMemoizer2 = _interopRequireDefault(_createCallbackMemoizer);\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\\n\\n/**\\n * Higher-order component that manages lazy-loading for \\\"infinite\\\" data.\\n * This component decorates a virtual component and just-in-time prefetches rows as a user scrolls.\\n * It is intended as a convenience component; fork it if you'd like finer-grained control over data-loading.\\n */\\nvar InfiniteLoader = function (_React$PureComponent) {\\n  (0, _inherits3.default)(InfiniteLoader, _React$PureComponent);\\n\\n  function InfiniteLoader(props, context) {\\n    (0, _classCallCheck3.default)(this, InfiniteLoader);\\n\\n    var _this = (0, _possibleConstructorReturn3.default)(this, (InfiniteLoader.__proto__ || (0, _getPrototypeOf2.default)(InfiniteLoader)).call(this, props, context));\\n\\n    _this._loadMoreRowsMemoizer = (0, _createCallbackMemoizer2.default)();\\n\\n    _this._onRowsRendered = _this._onRowsRendered.bind(_this);\\n    _this._registerChild = _this._registerChild.bind(_this);\\n    return _this;\\n  }\\n\\n  (0, _createClass3.default)(InfiniteLoader, [{\\n    key: 'resetLoadMoreRowsCache',\\n    value: function resetLoadMoreRowsCache(autoReload) {\\n      this._loadMoreRowsMemoizer = (0, _createCallbackMemoizer2.default)();\\n\\n      if (autoReload) {\\n        this._doStuff(this._lastRenderedStartIndex, this._lastRenderedStopIndex);\\n      }\\n    }\\n  }, {\\n    key: 'render',\\n    value: function render() {\\n      var children = this.props.children;\\n\\n\\n      return children({\\n        onRowsRendered: this._onRowsRendered,\\n        registerChild: this._registerChild\\n      });\\n    }\\n  }, {\\n    key: '_loadUnloadedRanges',\\n    value: function _loadUnloadedRanges(unloadedRanges) {\\n      var _this2 = this;\\n\\n      var loadMoreRows = this.props.loadMoreRows;\\n\\n\\n      unloadedRanges.forEach(function (unloadedRange) {\\n        var promise = loadMoreRows(unloadedRange);\\n        if (promise) {\\n          promise.then(function () {\\n            // Refresh the visible rows if any of them have just been loaded.\\n            // Otherwise they will remain in their unloaded visual state.\\n            if (isRangeVisible({\\n              lastRenderedStartIndex: _this2._lastRenderedStartIndex,\\n              lastRenderedStopIndex: _this2._lastRenderedStopIndex,\\n              startIndex: unloadedRange.startIndex,\\n              stopIndex: unloadedRange.stopIndex\\n            })) {\\n              if (_this2._registeredChild) {\\n                forceUpdateReactVirtualizedComponent(_this2._registeredChild, _this2._lastRenderedStartIndex);\\n              }\\n            }\\n          });\\n        }\\n      });\\n    }\\n  }, {\\n    key: '_onRowsRendered',\\n    value: function _onRowsRendered(_ref) {\\n      var startIndex = _ref.startIndex,\\n          stopIndex = _ref.stopIndex;\\n\\n      this._lastRenderedStartIndex = startIndex;\\n      this._lastRenderedStopIndex = stopIndex;\\n\\n      this._doStuff(startIndex, stopIndex);\\n    }\\n  }, {\\n    key: '_doStuff',\\n    value: function _doStuff(startIndex, stopIndex) {\\n      var _this3 = this;\\n\\n      var _props = this.props,\\n          isRowLoaded = _props.isRowLoaded,\\n          minimumBatchSize = _props.minimumBatchSize,\\n          rowCount = _props.rowCount,\\n          threshold = _props.threshold;\\n\\n\\n      var unloadedRanges = scanForUnloadedRanges({\\n        isRowLoaded: isRowLoaded,\\n        minimumBatchSize: minimumBatchSize,\\n        rowCount: rowCount,\\n        startIndex: Math.max(0, startIndex - threshold),\\n        stopIndex: Math.min(rowCount - 1, stopIndex + threshold)\\n      });\\n\\n      // For memoize comparison\\n      var squashedUnloadedRanges = unloadedRanges.reduce(function (reduced, unloadedRange) {\\n        return reduced.concat([unloadedRange.startIndex, unloadedRange.stopIndex]);\\n      }, []);\\n\\n      this._loadMoreRowsMemoizer({\\n        callback: function callback() {\\n          _this3._loadUnloadedRanges(unloadedRanges);\\n        },\\n        indices: { squashedUnloadedRanges: squashedUnloadedRanges }\\n      });\\n    }\\n  }, {\\n    key: '_registerChild',\\n    value: function _registerChild(registeredChild) {\\n      this._registeredChild = registeredChild;\\n    }\\n  }]);\\n  return InfiniteLoader;\\n}(React.PureComponent);\\n\\n/**\\n * Determines if the specified start/stop range is visible based on the most recently rendered range.\\n */\\n\\n\\nInfiniteLoader.defaultProps = {\\n  minimumBatchSize: 10,\\n  rowCount: 0,\\n  threshold: 15\\n};\\nexports.default = InfiniteLoader;\\nInfiniteLoader.propTypes = process.env.NODE_ENV !== \\\"production\\\" ? {\\n  /**\\n   * Function responsible for rendering a virtualized component.\\n   * This function should implement the following signature:\\n   * ({ onRowsRendered, registerChild }) => PropTypes.element\\n   *\\n   * The specified :onRowsRendered function should be passed through to the child's :onRowsRendered property.\\n   * The :registerChild callback should be set as the virtualized component's :ref.\\n   */\\n  children: _propTypes2.default.func.isRequired,\\n\\n  /**\\n   * Function responsible for tracking the loaded state of each row.\\n   * It should implement the following signature: ({ index: number }): boolean\\n   */\\n  isRowLoaded: _propTypes2.default.func.isRequired,\\n\\n  /**\\n   * Callback to be invoked when more rows must be loaded.\\n   * It should implement the following signature: ({ startIndex, stopIndex }): Promise\\n   * The returned Promise should be resolved once row data has finished loading.\\n   * It will be used to determine when to refresh the list with the newly-loaded data.\\n   * This callback may be called multiple times in reaction to a single scroll event.\\n   */\\n  loadMoreRows: _propTypes2.default.func.isRequired,\\n\\n  /**\\n   * Minimum number of rows to be loaded at a time.\\n   * This property can be used to batch requests to reduce HTTP requests.\\n   */\\n  minimumBatchSize: _propTypes2.default.number.isRequired,\\n\\n  /**\\n   * Number of rows in list; can be arbitrary high number if actual number is unknown.\\n   */\\n  rowCount: _propTypes2.default.number.isRequired,\\n\\n  /**\\n   * Threshold at which to pre-fetch data.\\n   * A threshold X means that data will start loading when a user scrolls within X rows.\\n   * This value defaults to 15.\\n   */\\n  threshold: _propTypes2.default.number.isRequired\\n} : {};\\nfunction isRangeVisible(_ref2) {\\n  var lastRenderedStartIndex = _ref2.lastRenderedStartIndex,\\n      lastRenderedStopIndex = _ref2.lastRenderedStopIndex,\\n      startIndex = _ref2.startIndex,\\n      stopIndex = _ref2.stopIndex;\\n\\n  return !(startIndex > lastRenderedStopIndex || stopIndex < lastRenderedStartIndex);\\n}\\n\\n/**\\n * Returns all of the ranges within a larger range that contain unloaded rows.\\n */\\nfunction scanForUnloadedRanges(_ref3) {\\n  var isRowLoaded = _ref3.isRowLoaded,\\n      minimumBatchSize = _ref3.minimumBatchSize,\\n      rowCount = _ref3.rowCount,\\n      startIndex = _ref3.startIndex,\\n      stopIndex = _ref3.stopIndex;\\n\\n  var unloadedRanges = [];\\n\\n  var rangeStartIndex = null;\\n  var rangeStopIndex = null;\\n\\n  for (var index = startIndex; index <= stopIndex; index++) {\\n    var loaded = isRowLoaded({ index: index });\\n\\n    if (!loaded) {\\n      rangeStopIndex = index;\\n      if (rangeStartIndex === null) {\\n        rangeStartIndex = index;\\n      }\\n    } else if (rangeStopIndex !== null) {\\n      unloadedRanges.push({\\n        startIndex: rangeStartIndex,\\n        stopIndex: rangeStopIndex\\n      });\\n\\n      rangeStartIndex = rangeStopIndex = null;\\n    }\\n  }\\n\\n  // If :rangeStopIndex is not null it means we haven't ran out of unloaded rows.\\n  // Scan forward to try filling our :minimumBatchSize.\\n  if (rangeStopIndex !== null) {\\n    var potentialStopIndex = Math.min(Math.max(rangeStopIndex, rangeStartIndex + minimumBatchSize - 1), rowCount - 1);\\n\\n    for (var _index = rangeStopIndex + 1; _index <= potentialStopIndex; _index++) {\\n      if (!isRowLoaded({ index: _index })) {\\n        rangeStopIndex = _index;\\n      } else {\\n        break;\\n      }\\n    }\\n\\n    unloadedRanges.push({\\n      startIndex: rangeStartIndex,\\n      stopIndex: rangeStopIndex\\n    });\\n  }\\n\\n  // Check to see if our first range ended prematurely.\\n  // In this case we should scan backwards to try filling our :minimumBatchSize.\\n  if (unloadedRanges.length) {\\n    var firstUnloadedRange = unloadedRanges[0];\\n\\n    while (firstUnloadedRange.stopIndex - firstUnloadedRange.startIndex + 1 < minimumBatchSize && firstUnloadedRange.startIndex > 0) {\\n      var _index2 = firstUnloadedRange.startIndex - 1;\\n\\n      if (!isRowLoaded({ index: _index2 })) {\\n        firstUnloadedRange.startIndex = _index2;\\n      } else {\\n        break;\\n      }\\n    }\\n  }\\n\\n  return unloadedRanges;\\n}\\n\\n/**\\n * Since RV components use shallowCompare we need to force a render (even though props haven't changed).\\n * However InfiniteLoader may wrap a Grid or it may wrap a Table or List.\\n * In the first case the built-in React forceUpdate() method is sufficient to force a re-render,\\n * But in the latter cases we need to use the RV-specific forceUpdateGrid() method.\\n * Else the inner Grid will not be re-rendered and visuals may be stale.\\n *\\n * Additionally, while a Grid is scrolling the cells can be cached,\\n * So it's important to invalidate that cache by recalculating sizes\\n * before forcing a rerender.\\n */\\nfunction forceUpdateReactVirtualizedComponent(component) {\\n  var currentIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\\n\\n  var recomputeSize = typeof component.recomputeGridSize === 'function' ? component.recomputeGridSize : component.recomputeRowHeights;\\n\\n  if (recomputeSize) {\\n    recomputeSize.call(component, currentIndex);\\n  } else {\\n    component.forceUpdate();\\n  }\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"process\",\"require\",\"module\",\"exports\",\"shadow$shims\",\"_interopRequireDefault\",\"obj\",\"__esModule\",\"default\",\"isRangeVisible\",\"_ref2\",\"lastRenderedStartIndex\",\"stopIndex\",\"startIndex\",\"lastRenderedStopIndex\",\"scanForUnloadedRanges\",\"_ref3\",\"isRowLoaded\",\"minimumBatchSize\",\"rowCount\",\"unloadedRanges\",\"rangeStartIndex\",\"rangeStopIndex\",\"index\",\"loaded\",\"push\",\"potentialStopIndex\",\"Math\",\"min\",\"max\",\"_index\",\"length\",\"firstUnloadedRange\",\"_index2\",\"forceUpdateReactVirtualizedComponent\",\"component\",\"currentIndex\",\"arguments\",\"undefined\",\"recomputeSize\",\"recomputeGridSize\",\"recomputeRowHeights\",\"call\",\"forceUpdate\",\"Object\",\"defineProperty\",\"value\",\"_getPrototypeOf\",\"_getPrototypeOf2\",\"_classCallCheck2\",\"_classCallCheck3\",\"_createClass2\",\"_createClass3\",\"_possibleConstructorReturn2\",\"_possibleConstructorReturn3\",\"_inherits2\",\"_inherits3\",\"React\",\"_interopRequireWildcard\",\"newObj\",\"key\",\"prototype\",\"hasOwnProperty\",\"_react\",\"_propTypes\",\"_createCallbackMemoizer\",\"_createCallbackMemoizer2\",\"InfiniteLoader\",\"_React$PureComponent\",\"props\",\"context\",\"_this\",\"__proto__\",\"_loadMoreRowsMemoizer\",\"_onRowsRendered\",\"bind\",\"_registerChild\",\"resetLoadMoreRowsCache\",\"autoReload\",\"_doStuff\",\"_lastRenderedStartIndex\",\"_lastRenderedStopIndex\",\"render\",\"children\",\"onRowsRendered\",\"registerChild\",\"_loadUnloadedRanges\",\"_this2\",\"loadMoreRows\",\"forEach\",\"unloadedRange\",\"promise\",\"then\",\"_registeredChild\",\"_ref\",\"_this3\",\"_props\",\"threshold\",\"squashedUnloadedRanges\",\"reduce\",\"reduced\",\"concat\",\"callback\",\"indices\",\"registeredChild\",\"PureComponent\",\"defaultProps\",\"propTypes\"]\n}\n"]