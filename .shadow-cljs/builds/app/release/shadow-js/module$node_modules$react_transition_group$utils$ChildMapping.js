["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/react-transition-group/utils/ChildMapping.js"],"~:js","shadow$provide.module$node_modules$react_transition_group$utils$ChildMapping=function(b,e,a,f,c,m){function d(a,b){var c=Object.create(null);a&&h.Children.map(a,function(a){return a}).forEach(function(a){var d=a.key;a=b&&(0,h.isValidElement)(a)?b(a):a;c[d]=a});return c}function k(a,b){function c(c){return c in b?b[c]:a[c]}a=a||{};b=b||{};var d=Object.create(null),e=[];for(h in a)h in b?e.length&&(d[h]=e,e=[]):e.push(h);var h=void 0;var k={},l;for(l in b){if(d[l])for(h=0;h<d[l].length;h++)k[d[l][h]]=\nc(d[l][h]);k[l]=c(l)}for(h=0;h<e.length;h++)k[e[h]]=c(e[h]);return k}function l(a,b,c){return null!=c[b]?c[b]:a.props[b]}c.__esModule=!0;c.getChildMapping=d;c.mergeChildMappings=k;c.getInitialChildMapping=function(a,b){return d(a.children,function(c){return(0,h.cloneElement)(c,{onExited:b.bind(null,c),in:!0,appear:l(c,\"appear\",a),enter:l(c,\"enter\",a),exit:l(c,\"exit\",a)})})};c.getNextChildMapping=function(a,b,c){var e=d(a.children),n=k(b,e);Object.keys(n).forEach(function(d){var g=n[d];if((0,h.isValidElement)(g)){var k=\nd in b,f=d in e,q=b[d],t=(0,h.isValidElement)(q)&&!q.props.in;!f||k&&!t?f||!k||t?f&&k&&(0,h.isValidElement)(q)&&(n[d]=(0,h.cloneElement)(g,{onExited:c.bind(null,g),in:q.props.in,exit:l(g,\"exit\",a),enter:l(g,\"enter\",a)})):n[d]=(0,h.cloneElement)(g,{in:!1}):n[d]=(0,h.cloneElement)(g,{onExited:c.bind(null,g),in:!0,exit:l(g,\"exit\",a),enter:l(g,\"enter\",a)})}});return n};var h=a(\"module$node_modules$react$index\")}","~:source","shadow$provide[\"module$node_modules$react_transition_group$utils$ChildMapping\"] = function(global,process,require,module,exports,shadow$shims) {\n'use strict';\n\nexports.__esModule = true;\nexports.getChildMapping = getChildMapping;\nexports.mergeChildMappings = mergeChildMappings;\nexports.getInitialChildMapping = getInitialChildMapping;\nexports.getNextChildMapping = getNextChildMapping;\n\nvar _react = require('react');\n\n/**\n * Given `this.props.children`, return an object mapping key to child.\n *\n * @param {*} children `this.props.children`\n * @return {object} Mapping of key to child\n */\nfunction getChildMapping(children, mapFn) {\n  var mapper = function mapper(child) {\n    return mapFn && (0, _react.isValidElement)(child) ? mapFn(child) : child;\n  };\n\n  var result = Object.create(null);\n  if (children) _react.Children.map(children, function (c) {\n    return c;\n  }).forEach(function (child) {\n    // run the map function here instead so that the key is the computed one\n    result[child.key] = mapper(child);\n  });\n  return result;\n}\n\n/**\n * When you're adding or removing children some may be added or removed in the\n * same render pass. We want to show *both* since we want to simultaneously\n * animate elements in and out. This function takes a previous set of keys\n * and a new set of keys and merges them with its best guess of the correct\n * ordering. In the future we may expose some of the utilities in\n * ReactMultiChild to make this easy, but for now React itself does not\n * directly have this concept of the union of prevChildren and nextChildren\n * so we implement it here.\n *\n * @param {object} prev prev children as returned from\n * `ReactTransitionChildMapping.getChildMapping()`.\n * @param {object} next next children as returned from\n * `ReactTransitionChildMapping.getChildMapping()`.\n * @return {object} a key set that contains all keys in `prev` and all keys\n * in `next` in a reasonable order.\n */\nfunction mergeChildMappings(prev, next) {\n  prev = prev || {};\n  next = next || {};\n\n  function getValueForKey(key) {\n    return key in next ? next[key] : prev[key];\n  }\n\n  // For each key of `next`, the list of keys to insert before that key in\n  // the combined list\n  var nextKeysPending = Object.create(null);\n\n  var pendingKeys = [];\n  for (var prevKey in prev) {\n    if (prevKey in next) {\n      if (pendingKeys.length) {\n        nextKeysPending[prevKey] = pendingKeys;\n        pendingKeys = [];\n      }\n    } else {\n      pendingKeys.push(prevKey);\n    }\n  }\n\n  var i = void 0;\n  var childMapping = {};\n  for (var nextKey in next) {\n    if (nextKeysPending[nextKey]) {\n      for (i = 0; i < nextKeysPending[nextKey].length; i++) {\n        var pendingNextKey = nextKeysPending[nextKey][i];\n        childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);\n      }\n    }\n    childMapping[nextKey] = getValueForKey(nextKey);\n  }\n\n  // Finally, add the keys which didn't appear before any key in `next`\n  for (i = 0; i < pendingKeys.length; i++) {\n    childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);\n  }\n\n  return childMapping;\n}\n\nfunction getProp(child, prop, props) {\n  return props[prop] != null ? props[prop] : child.props[prop];\n}\n\nfunction getInitialChildMapping(props, onExited) {\n  return getChildMapping(props.children, function (child) {\n    return (0, _react.cloneElement)(child, {\n      onExited: onExited.bind(null, child),\n      in: true,\n      appear: getProp(child, 'appear', props),\n      enter: getProp(child, 'enter', props),\n      exit: getProp(child, 'exit', props)\n    });\n  });\n}\n\nfunction getNextChildMapping(nextProps, prevChildMapping, onExited) {\n  var nextChildMapping = getChildMapping(nextProps.children);\n  var children = mergeChildMappings(prevChildMapping, nextChildMapping);\n\n  Object.keys(children).forEach(function (key) {\n    var child = children[key];\n\n    if (!(0, _react.isValidElement)(child)) return;\n\n    var hasPrev = key in prevChildMapping;\n    var hasNext = key in nextChildMapping;\n\n    var prevChild = prevChildMapping[key];\n    var isLeaving = (0, _react.isValidElement)(prevChild) && !prevChild.props.in;\n\n    // item is new (entering)\n    if (hasNext && (!hasPrev || isLeaving)) {\n      // console.log('entering', key)\n      children[key] = (0, _react.cloneElement)(child, {\n        onExited: onExited.bind(null, child),\n        in: true,\n        exit: getProp(child, 'exit', nextProps),\n        enter: getProp(child, 'enter', nextProps)\n      });\n    } else if (!hasNext && hasPrev && !isLeaving) {\n      // item is old (exiting)\n      // console.log('leaving', key)\n      children[key] = (0, _react.cloneElement)(child, { in: false });\n    } else if (hasNext && hasPrev && (0, _react.isValidElement)(prevChild)) {\n      // item hasn't changed transition states\n      // copy over the last transition props;\n      // console.log('unchanged', key)\n      children[key] = (0, _react.cloneElement)(child, {\n        onExited: onExited.bind(null, child),\n        in: prevChild.props.in,\n        exit: getProp(child, 'exit', nextProps),\n        enter: getProp(child, 'enter', nextProps)\n      });\n    }\n  });\n\n  return children;\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$react$index","~$shadow.js"]],"~:properties",["^5",["appear","onExited","__esModule","getNextChildMapping","getInitialChildMapping","getChildMapping","exit","mergeChildMappings","enter","in"]],"~:compiled-at",1537815743076,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$react_transition_group$utils$ChildMapping.js\",\n\"lineCount\":3,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/react-transition-group/utils/ChildMapping.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$react_transition_group$utils$ChildMapping\\\"] = function(global,process,require,module,exports,shadow$shims) {\\n'use strict';\\n\\nexports.__esModule = true;\\nexports.getChildMapping = getChildMapping;\\nexports.mergeChildMappings = mergeChildMappings;\\nexports.getInitialChildMapping = getInitialChildMapping;\\nexports.getNextChildMapping = getNextChildMapping;\\n\\nvar _react = require('react');\\n\\n/**\\n * Given `this.props.children`, return an object mapping key to child.\\n *\\n * @param {*} children `this.props.children`\\n * @return {object} Mapping of key to child\\n */\\nfunction getChildMapping(children, mapFn) {\\n  var mapper = function mapper(child) {\\n    return mapFn && (0, _react.isValidElement)(child) ? mapFn(child) : child;\\n  };\\n\\n  var result = Object.create(null);\\n  if (children) _react.Children.map(children, function (c) {\\n    return c;\\n  }).forEach(function (child) {\\n    // run the map function here instead so that the key is the computed one\\n    result[child.key] = mapper(child);\\n  });\\n  return result;\\n}\\n\\n/**\\n * When you're adding or removing children some may be added or removed in the\\n * same render pass. We want to show *both* since we want to simultaneously\\n * animate elements in and out. This function takes a previous set of keys\\n * and a new set of keys and merges them with its best guess of the correct\\n * ordering. In the future we may expose some of the utilities in\\n * ReactMultiChild to make this easy, but for now React itself does not\\n * directly have this concept of the union of prevChildren and nextChildren\\n * so we implement it here.\\n *\\n * @param {object} prev prev children as returned from\\n * `ReactTransitionChildMapping.getChildMapping()`.\\n * @param {object} next next children as returned from\\n * `ReactTransitionChildMapping.getChildMapping()`.\\n * @return {object} a key set that contains all keys in `prev` and all keys\\n * in `next` in a reasonable order.\\n */\\nfunction mergeChildMappings(prev, next) {\\n  prev = prev || {};\\n  next = next || {};\\n\\n  function getValueForKey(key) {\\n    return key in next ? next[key] : prev[key];\\n  }\\n\\n  // For each key of `next`, the list of keys to insert before that key in\\n  // the combined list\\n  var nextKeysPending = Object.create(null);\\n\\n  var pendingKeys = [];\\n  for (var prevKey in prev) {\\n    if (prevKey in next) {\\n      if (pendingKeys.length) {\\n        nextKeysPending[prevKey] = pendingKeys;\\n        pendingKeys = [];\\n      }\\n    } else {\\n      pendingKeys.push(prevKey);\\n    }\\n  }\\n\\n  var i = void 0;\\n  var childMapping = {};\\n  for (var nextKey in next) {\\n    if (nextKeysPending[nextKey]) {\\n      for (i = 0; i < nextKeysPending[nextKey].length; i++) {\\n        var pendingNextKey = nextKeysPending[nextKey][i];\\n        childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);\\n      }\\n    }\\n    childMapping[nextKey] = getValueForKey(nextKey);\\n  }\\n\\n  // Finally, add the keys which didn't appear before any key in `next`\\n  for (i = 0; i < pendingKeys.length; i++) {\\n    childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);\\n  }\\n\\n  return childMapping;\\n}\\n\\nfunction getProp(child, prop, props) {\\n  return props[prop] != null ? props[prop] : child.props[prop];\\n}\\n\\nfunction getInitialChildMapping(props, onExited) {\\n  return getChildMapping(props.children, function (child) {\\n    return (0, _react.cloneElement)(child, {\\n      onExited: onExited.bind(null, child),\\n      in: true,\\n      appear: getProp(child, 'appear', props),\\n      enter: getProp(child, 'enter', props),\\n      exit: getProp(child, 'exit', props)\\n    });\\n  });\\n}\\n\\nfunction getNextChildMapping(nextProps, prevChildMapping, onExited) {\\n  var nextChildMapping = getChildMapping(nextProps.children);\\n  var children = mergeChildMappings(prevChildMapping, nextChildMapping);\\n\\n  Object.keys(children).forEach(function (key) {\\n    var child = children[key];\\n\\n    if (!(0, _react.isValidElement)(child)) return;\\n\\n    var hasPrev = key in prevChildMapping;\\n    var hasNext = key in nextChildMapping;\\n\\n    var prevChild = prevChildMapping[key];\\n    var isLeaving = (0, _react.isValidElement)(prevChild) && !prevChild.props.in;\\n\\n    // item is new (entering)\\n    if (hasNext && (!hasPrev || isLeaving)) {\\n      // console.log('entering', key)\\n      children[key] = (0, _react.cloneElement)(child, {\\n        onExited: onExited.bind(null, child),\\n        in: true,\\n        exit: getProp(child, 'exit', nextProps),\\n        enter: getProp(child, 'enter', nextProps)\\n      });\\n    } else if (!hasNext && hasPrev && !isLeaving) {\\n      // item is old (exiting)\\n      // console.log('leaving', key)\\n      children[key] = (0, _react.cloneElement)(child, { in: false });\\n    } else if (hasNext && hasPrev && (0, _react.isValidElement)(prevChild)) {\\n      // item hasn't changed transition states\\n      // copy over the last transition props;\\n      // console.log('unchanged', key)\\n      children[key] = (0, _react.cloneElement)(child, {\\n        onExited: onExited.bind(null, child),\\n        in: prevChild.props.in,\\n        exit: getProp(child, 'exit', nextProps),\\n        enter: getProp(child, 'enter', nextProps)\\n      });\\n    }\\n  });\\n\\n  return children;\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"process\",\"require\",\"module\",\"exports\",\"shadow$shims\",\"getChildMapping\",\"children\",\"mapFn\",\"result\",\"Object\",\"create\",\"_react\",\"Children\",\"map\",\"c\",\"forEach\",\"child\",\"key\",\"isValidElement\",\"mergeChildMappings\",\"prev\",\"next\",\"getValueForKey\",\"nextKeysPending\",\"pendingKeys\",\"prevKey\",\"length\",\"push\",\"i\",\"childMapping\",\"nextKey\",\"pendingNextKey\",\"getProp\",\"prop\",\"props\",\"__esModule\",\"getInitialChildMapping\",\"onExited\",\"cloneElement\",\"bind\",\"in\",\"appear\",\"enter\",\"exit\",\"getNextChildMapping\",\"nextProps\",\"prevChildMapping\",\"nextChildMapping\",\"keys\",\"hasPrev\",\"hasNext\",\"prevChild\",\"isLeaving\"]\n}\n"]