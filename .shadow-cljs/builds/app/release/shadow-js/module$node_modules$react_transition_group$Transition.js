["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/react-transition-group/Transition.js"],"~:js","shadow$provide.module$node_modules$react_transition_group$Transition=function(b,e,a,f,c,m){function d(a,b){if(\"function\"!==typeof b&&null!==b)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof b);a.prototype=Object.create(b&&b.prototype,{constructor:{value:a,enumerable:!1,writable:!0,configurable:!0}});b&&(Object.setPrototypeOf?Object.setPrototypeOf(a,b):a.__proto__=b)}function k(){}c.__esModule=!0;c.EXITING=c.ENTERED=c.ENTERING=c.EXITED=c.UNMOUNTED=void 0;b=function(a){if(a&&\na.__esModule)return a;var b={};if(null!=a)for(var c in a)Object.prototype.hasOwnProperty.call(a,c)&&(b[c]=a[c]);b.default=a;return b}(a(\"module$node_modules$prop_types$index\"));var l=(e=a(\"module$node_modules$react$index\"))&&e.__esModule?e:{default:e},h=(e=a(\"module$node_modules$react_dom$index\"))&&e.__esModule?e:{default:e};e=a(\"module$node_modules$react_lifecycles_compat$react_lifecycles_compat_cjs\");a(\"module$node_modules$react_transition_group$utils$PropTypes\");var p=c.UNMOUNTED=\"unmounted\",r=\nc.EXITED=\"exited\",q=c.ENTERING=\"entering\",g=c.ENTERED=\"entered\",n=c.EXITING=\"exiting\";a=function(a){function b(c,d){if(!(this instanceof b))throw new TypeError(\"Cannot call a class as a function\");var e=a.call(this,c,d);if(!this)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");e=!e||\"object\"!==typeof e&&\"function\"!==typeof e?this:e;d=(d=d.transitionGroup)&&!d.isMounting?c.enter:c.appear;e.appearStatus=null;c.in?d?(c=r,e.appearStatus=q):c=g:c=c.unmountOnExit||c.mountOnEnter?\np:r;e.state={status:c};e.nextCallback=null;return e}d(b,a);b.prototype.getChildContext=function(){return{transitionGroup:null}};b.getDerivedStateFromProps=function(a,b){return a.in&&b.status===p?{status:r}:null};b.prototype.componentDidMount=function(){this.updateStatus(!0,this.appearStatus)};b.prototype.componentDidUpdate=function(a){var b=null;if(a!==this.props)if(a=this.state.status,this.props.in)a!==q&&a!==g&&(b=q);else if(a===q||a===g)b=n;this.updateStatus(!1,b)};b.prototype.componentWillUnmount=\nfunction(){this.cancelNextCallback()};b.prototype.getTimeouts=function(){var a=this.props.timeout,b,c;var d=b=c=a;null!=a&&\"number\"!==typeof a&&(d=a.exit,b=a.enter,c=a.appear);return{exit:d,enter:b,appear:c}};b.prototype.updateStatus=function(){var a=0<arguments.length&&void 0!==arguments[0]?arguments[0]:!1,b=arguments[1];if(null!==b){this.cancelNextCallback();var c=h.default.findDOMNode(this);b===q?this.performEnter(c,a):this.performExit(c)}else this.props.unmountOnExit&&this.state.status===r&&this.setState({status:p})};\nb.prototype.performEnter=function(a,b){var c=this,d=this.props.enter,e=this.context.transitionGroup?this.context.transitionGroup.isMounting:b,h=this.getTimeouts();b||d?(this.props.onEnter(a,e),this.safeSetState({status:q},function(){c.props.onEntering(a,e);c.onTransitionEnd(a,h.enter,function(){c.safeSetState({status:g},function(){c.props.onEntered(a,e)})})})):this.safeSetState({status:g},function(){c.props.onEntered(a)})};b.prototype.performExit=function(a){var b=this,c=this.props.exit,d=this.getTimeouts();\nc?(this.props.onExit(a),this.safeSetState({status:n},function(){b.props.onExiting(a);b.onTransitionEnd(a,d.exit,function(){b.safeSetState({status:r},function(){b.props.onExited(a)})})})):this.safeSetState({status:r},function(){b.props.onExited(a)})};b.prototype.cancelNextCallback=function(){null!==this.nextCallback&&(this.nextCallback.cancel(),this.nextCallback=null)};b.prototype.safeSetState=function(a,b){b=this.setNextCallback(b);this.setState(a,b)};b.prototype.setNextCallback=function(a){var b=\nthis,c=!0;this.nextCallback=function(d){c&&(c=!1,b.nextCallback=null,a(d))};this.nextCallback.cancel=function(){c=!1};return this.nextCallback};b.prototype.onTransitionEnd=function(a,b,c){this.setNextCallback(c);a?(this.props.addEndListener&&this.props.addEndListener(a,this.nextCallback),null!=b&&setTimeout(this.nextCallback,b)):setTimeout(this.nextCallback,0)};b.prototype.render=function(){var a=this.state.status;if(a===p)return null;var b=this.props,c=b.children,d=[\"children\"],e={},g;for(g in b)0<=\nd.indexOf(g)||Object.prototype.hasOwnProperty.call(b,g)&&(e[g]=b[g]);delete e.in;delete e.mountOnEnter;delete e.unmountOnExit;delete e.appear;delete e.enter;delete e.exit;delete e.timeout;delete e.addEndListener;delete e.onEnter;delete e.onEntering;delete e.onEntered;delete e.onExit;delete e.onExiting;delete e.onExited;if(\"function\"===typeof c)return c(a,e);a=l.default.Children.only(c);return l.default.cloneElement(a,e)};return b}(l.default.Component);a.contextTypes={transitionGroup:b.object};a.childContextTypes=\n{transitionGroup:function(){}};a.propTypes={};a.defaultProps={in:!1,mountOnEnter:!1,unmountOnExit:!1,appear:!1,enter:!0,exit:!0,onEnter:k,onEntering:k,onEntered:k,onExit:k,onExiting:k,onExited:k};a.UNMOUNTED=0;a.EXITED=1;a.ENTERING=2;a.ENTERED=3;a.EXITING=4;c.default=(0,e.polyfill)(a)}","~:source","shadow$provide[\"module$node_modules$react_transition_group$Transition\"] = function(global,process,require,module,exports,shadow$shims) {\n'use strict';\n\nexports.__esModule = true;\nexports.EXITING = exports.ENTERED = exports.ENTERING = exports.EXITED = exports.UNMOUNTED = undefined;\n\nvar _propTypes = require('prop-types');\n\nvar PropTypes = _interopRequireWildcard(_propTypes);\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _reactDom = require('react-dom');\n\nvar _reactDom2 = _interopRequireDefault(_reactDom);\n\nvar _reactLifecyclesCompat = require('react-lifecycles-compat');\n\nvar _PropTypes = require('./utils/PropTypes');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar UNMOUNTED = exports.UNMOUNTED = 'unmounted';\nvar EXITED = exports.EXITED = 'exited';\nvar ENTERING = exports.ENTERING = 'entering';\nvar ENTERED = exports.ENTERED = 'entered';\nvar EXITING = exports.EXITING = 'exiting';\n\n/**\n * The Transition component lets you describe a transition from one component\n * state to another _over time_ with a simple declarative API. Most commonly\n * it's used to animate the mounting and unmounting of a component, but can also\n * be used to describe in-place transition states as well.\n *\n * By default the `Transition` component does not alter the behavior of the\n * component it renders, it only tracks \"enter\" and \"exit\" states for the components.\n * It's up to you to give meaning and effect to those states. For example we can\n * add styles to a component when it enters or exits:\n *\n * ```jsx\n * import Transition from 'react-transition-group/Transition';\n *\n * const duration = 300;\n *\n * const defaultStyle = {\n *   transition: `opacity ${duration}ms ease-in-out`,\n *   opacity: 0,\n * }\n *\n * const transitionStyles = {\n *   entering: { opacity: 0 },\n *   entered:  { opacity: 1 },\n * };\n *\n * const Fade = ({ in: inProp }) => (\n *   <Transition in={inProp} timeout={duration}>\n *     {(state) => (\n *       <div style={{\n *         ...defaultStyle,\n *         ...transitionStyles[state]\n *       }}>\n *         I'm a fade Transition!\n *       </div>\n *     )}\n *   </Transition>\n * );\n * ```\n *\n * As noted the `Transition` component doesn't _do_ anything by itself to its child component.\n * What it does do is track transition states over time so you can update the\n * component (such as by adding styles or classes) when it changes states.\n *\n * There are 4 main states a Transition can be in:\n *  - `'entering'`\n *  - `'entered'`\n *  - `'exiting'`\n *  - `'exited'`\n *\n * Transition state is toggled via the `in` prop. When `true` the component begins the\n * \"Enter\" stage. During this stage, the component will shift from its current transition state,\n * to `'entering'` for the duration of the transition and then to the `'entered'` stage once\n * it's complete. Let's take the following example:\n *\n * ```jsx\n * state = { in: false };\n *\n * toggleEnterState = () => {\n *   this.setState({ in: true });\n * }\n *\n * render() {\n *   return (\n *     <div>\n *       <Transition in={this.state.in} timeout={500} />\n *       <button onClick={this.toggleEnterState}>Click to Enter</button>\n *     </div>\n *   );\n * }\n * ```\n *\n * When the button is clicked the component will shift to the `'entering'` state and\n * stay there for 500ms (the value of `timeout`) before it finally switches to `'entered'`.\n *\n * When `in` is `false` the same thing happens except the state moves from `'exiting'` to `'exited'`.\n *\n * ## Timing\n *\n * Timing is often the trickiest part of animation, mistakes can result in slight delays\n * that are hard to pin down. A common example is when you want to add an exit transition,\n * you should set the desired final styles when the state is `'exiting'`. That's when the\n * transition to those styles will start and, if you matched the `timeout` prop with the\n * CSS Transition duration, it will end exactly when the state changes to `'exited'`.\n *\n * > **Note**: For simpler transitions the `Transition` component might be enough, but\n * > take into account that it's platform-agnostic, while the `CSSTransition` component\n * > [forces reflows](https://github.com/reactjs/react-transition-group/blob/5007303e729a74be66a21c3e2205e4916821524b/src/CSSTransition.js#L208-L215)\n * > in order to make more complex transitions more predictable. For example, even though\n * > classes `example-enter` and `example-enter-active` are applied immediately one after\n * > another, you can still transition from one to the other because of the forced reflow\n * > (read [this issue](https://github.com/reactjs/react-transition-group/issues/159#issuecomment-322761171)\n * > for more info). Take this into account when choosing between `Transition` and\n * > `CSSTransition`.\n *\n * ## Example\n *\n * <iframe src=\"https://codesandbox.io/embed/741op4mmj0?fontsize=14\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n *\n */\n\nvar Transition = function (_React$Component) {\n  _inherits(Transition, _React$Component);\n\n  function Transition(props, context) {\n    _classCallCheck(this, Transition);\n\n    var _this = _possibleConstructorReturn(this, _React$Component.call(this, props, context));\n\n    var parentGroup = context.transitionGroup;\n    // In the context of a TransitionGroup all enters are really appears\n    var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;\n\n    var initialStatus = void 0;\n\n    _this.appearStatus = null;\n\n    if (props.in) {\n      if (appear) {\n        initialStatus = EXITED;\n        _this.appearStatus = ENTERING;\n      } else {\n        initialStatus = ENTERED;\n      }\n    } else {\n      if (props.unmountOnExit || props.mountOnEnter) {\n        initialStatus = UNMOUNTED;\n      } else {\n        initialStatus = EXITED;\n      }\n    }\n\n    _this.state = { status: initialStatus };\n\n    _this.nextCallback = null;\n    return _this;\n  }\n\n  Transition.prototype.getChildContext = function getChildContext() {\n    return { transitionGroup: null // allows for nested Transitions\n    };\n  };\n\n  Transition.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {\n    var nextIn = _ref.in;\n\n    if (nextIn && prevState.status === UNMOUNTED) {\n      return { status: EXITED };\n    }\n    return null;\n  };\n\n  // getSnapshotBeforeUpdate(prevProps) {\n  //   let nextStatus = null\n\n  //   if (prevProps !== this.props) {\n  //     const { status } = this.state\n\n  //     if (this.props.in) {\n  //       if (status !== ENTERING && status !== ENTERED) {\n  //         nextStatus = ENTERING\n  //       }\n  //     } else {\n  //       if (status === ENTERING || status === ENTERED) {\n  //         nextStatus = EXITING\n  //       }\n  //     }\n  //   }\n\n  //   return { nextStatus }\n  // }\n\n  Transition.prototype.componentDidMount = function componentDidMount() {\n    this.updateStatus(true, this.appearStatus);\n  };\n\n  Transition.prototype.componentDidUpdate = function componentDidUpdate(prevProps) {\n    var nextStatus = null;\n    if (prevProps !== this.props) {\n      var status = this.state.status;\n\n\n      if (this.props.in) {\n        if (status !== ENTERING && status !== ENTERED) {\n          nextStatus = ENTERING;\n        }\n      } else {\n        if (status === ENTERING || status === ENTERED) {\n          nextStatus = EXITING;\n        }\n      }\n    }\n    this.updateStatus(false, nextStatus);\n  };\n\n  Transition.prototype.componentWillUnmount = function componentWillUnmount() {\n    this.cancelNextCallback();\n  };\n\n  Transition.prototype.getTimeouts = function getTimeouts() {\n    var timeout = this.props.timeout;\n\n    var exit = void 0,\n        enter = void 0,\n        appear = void 0;\n\n    exit = enter = appear = timeout;\n\n    if (timeout != null && typeof timeout !== 'number') {\n      exit = timeout.exit;\n      enter = timeout.enter;\n      appear = timeout.appear;\n    }\n    return { exit: exit, enter: enter, appear: appear };\n  };\n\n  Transition.prototype.updateStatus = function updateStatus() {\n    var mounting = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var nextStatus = arguments[1];\n\n    if (nextStatus !== null) {\n      // nextStatus will always be ENTERING or EXITING.\n      this.cancelNextCallback();\n      var node = _reactDom2.default.findDOMNode(this);\n\n      if (nextStatus === ENTERING) {\n        this.performEnter(node, mounting);\n      } else {\n        this.performExit(node);\n      }\n    } else if (this.props.unmountOnExit && this.state.status === EXITED) {\n      this.setState({ status: UNMOUNTED });\n    }\n  };\n\n  Transition.prototype.performEnter = function performEnter(node, mounting) {\n    var _this2 = this;\n\n    var enter = this.props.enter;\n\n    var appearing = this.context.transitionGroup ? this.context.transitionGroup.isMounting : mounting;\n\n    var timeouts = this.getTimeouts();\n\n    // no enter animation skip right to ENTERED\n    // if we are mounting and running this it means appear _must_ be set\n    if (!mounting && !enter) {\n      this.safeSetState({ status: ENTERED }, function () {\n        _this2.props.onEntered(node);\n      });\n      return;\n    }\n\n    this.props.onEnter(node, appearing);\n\n    this.safeSetState({ status: ENTERING }, function () {\n      _this2.props.onEntering(node, appearing);\n\n      // FIXME: appear timeout?\n      _this2.onTransitionEnd(node, timeouts.enter, function () {\n        _this2.safeSetState({ status: ENTERED }, function () {\n          _this2.props.onEntered(node, appearing);\n        });\n      });\n    });\n  };\n\n  Transition.prototype.performExit = function performExit(node) {\n    var _this3 = this;\n\n    var exit = this.props.exit;\n\n    var timeouts = this.getTimeouts();\n\n    // no exit animation skip right to EXITED\n    if (!exit) {\n      this.safeSetState({ status: EXITED }, function () {\n        _this3.props.onExited(node);\n      });\n      return;\n    }\n    this.props.onExit(node);\n\n    this.safeSetState({ status: EXITING }, function () {\n      _this3.props.onExiting(node);\n\n      _this3.onTransitionEnd(node, timeouts.exit, function () {\n        _this3.safeSetState({ status: EXITED }, function () {\n          _this3.props.onExited(node);\n        });\n      });\n    });\n  };\n\n  Transition.prototype.cancelNextCallback = function cancelNextCallback() {\n    if (this.nextCallback !== null) {\n      this.nextCallback.cancel();\n      this.nextCallback = null;\n    }\n  };\n\n  Transition.prototype.safeSetState = function safeSetState(nextState, callback) {\n    // This shouldn't be necessary, but there are weird race conditions with\n    // setState callbacks and unmounting in testing, so always make sure that\n    // we can cancel any pending setState callbacks after we unmount.\n    callback = this.setNextCallback(callback);\n    this.setState(nextState, callback);\n  };\n\n  Transition.prototype.setNextCallback = function setNextCallback(callback) {\n    var _this4 = this;\n\n    var active = true;\n\n    this.nextCallback = function (event) {\n      if (active) {\n        active = false;\n        _this4.nextCallback = null;\n\n        callback(event);\n      }\n    };\n\n    this.nextCallback.cancel = function () {\n      active = false;\n    };\n\n    return this.nextCallback;\n  };\n\n  Transition.prototype.onTransitionEnd = function onTransitionEnd(node, timeout, handler) {\n    this.setNextCallback(handler);\n\n    if (node) {\n      if (this.props.addEndListener) {\n        this.props.addEndListener(node, this.nextCallback);\n      }\n      if (timeout != null) {\n        setTimeout(this.nextCallback, timeout);\n      }\n    } else {\n      setTimeout(this.nextCallback, 0);\n    }\n  };\n\n  Transition.prototype.render = function render() {\n    var status = this.state.status;\n    if (status === UNMOUNTED) {\n      return null;\n    }\n\n    var _props = this.props,\n        children = _props.children,\n        childProps = _objectWithoutProperties(_props, ['children']);\n    // filter props for Transtition\n\n\n    delete childProps.in;\n    delete childProps.mountOnEnter;\n    delete childProps.unmountOnExit;\n    delete childProps.appear;\n    delete childProps.enter;\n    delete childProps.exit;\n    delete childProps.timeout;\n    delete childProps.addEndListener;\n    delete childProps.onEnter;\n    delete childProps.onEntering;\n    delete childProps.onEntered;\n    delete childProps.onExit;\n    delete childProps.onExiting;\n    delete childProps.onExited;\n\n    if (typeof children === 'function') {\n      return children(status, childProps);\n    }\n\n    var child = _react2.default.Children.only(children);\n    return _react2.default.cloneElement(child, childProps);\n  };\n\n  return Transition;\n}(_react2.default.Component);\n\nTransition.contextTypes = {\n  transitionGroup: PropTypes.object\n};\nTransition.childContextTypes = {\n  transitionGroup: function transitionGroup() {}\n};\n\n\nTransition.propTypes = process.env.NODE_ENV !== \"production\" ? {\n  /**\n   * A `function` child can be used instead of a React element.\n   * This function is called with the current transition status\n   * ('entering', 'entered', 'exiting', 'exited', 'unmounted'), which can be used\n   * to apply context specific props to a component.\n   *\n   * ```jsx\n   * <Transition timeout={150}>\n   *   {(status) => (\n   *     <MyComponent className={`fade fade-${status}`} />\n   *   )}\n   * </Transition>\n   * ```\n   */\n  children: PropTypes.oneOfType([PropTypes.func.isRequired, PropTypes.element.isRequired]).isRequired,\n\n  /**\n   * Show the component; triggers the enter or exit states\n   */\n  in: PropTypes.bool,\n\n  /**\n   * By default the child component is mounted immediately along with\n   * the parent `Transition` component. If you want to \"lazy mount\" the component on the\n   * first `in={true}` you can set `mountOnEnter`. After the first enter transition the component will stay\n   * mounted, even on \"exited\", unless you also specify `unmountOnExit`.\n   */\n  mountOnEnter: PropTypes.bool,\n\n  /**\n   * By default the child component stays mounted after it reaches the `'exited'` state.\n   * Set `unmountOnExit` if you'd prefer to unmount the component after it finishes exiting.\n   */\n  unmountOnExit: PropTypes.bool,\n\n  /**\n   * Normally a component is not transitioned if it is shown when the `<Transition>` component mounts.\n   * If you want to transition on the first mount set `appear` to `true`, and the\n   * component will transition in as soon as the `<Transition>` mounts.\n   *\n   * > Note: there are no specific \"appear\" states. `appear` only adds an additional `enter` transition.\n   */\n  appear: PropTypes.bool,\n\n  /**\n   * Enable or disable enter transitions.\n   */\n  enter: PropTypes.bool,\n\n  /**\n   * Enable or disable exit transitions.\n   */\n  exit: PropTypes.bool,\n\n  /**\n   * The duration of the transition, in milliseconds.\n   * Required unless `addEndListener` is provided\n   *\n   * You may specify a single timeout for all transitions like: `timeout={500}`,\n   * or individually like:\n   *\n   * ```jsx\n   * timeout={{\n   *  enter: 300,\n   *  exit: 500,\n   * }}\n   * ```\n   *\n   * @type {number | { enter?: number, exit?: number }}\n   */\n  timeout: function timeout(props) {\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    var pt = _PropTypes.timeoutsShape;\n    if (!props.addEndListener) pt = pt.isRequired;\n    return pt.apply(undefined, [props].concat(args));\n  },\n\n  /**\n   * Add a custom transition end trigger. Called with the transitioning\n   * DOM node and a `done` callback. Allows for more fine grained transition end\n   * logic. **Note:** Timeouts are still used as a fallback if provided.\n   *\n   * ```jsx\n   * addEndListener={(node, done) => {\n   *   // use the css transitionend event to mark the finish of a transition\n   *   node.addEventListener('transitionend', done, false);\n   * }}\n   * ```\n   */\n  addEndListener: PropTypes.func,\n\n  /**\n   * Callback fired before the \"entering\" status is applied. An extra parameter\n   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount\n   *\n   * @type Function(node: HtmlElement, isAppearing: bool) -> void\n   */\n  onEnter: PropTypes.func,\n\n  /**\n   * Callback fired after the \"entering\" status is applied. An extra parameter\n   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount\n   *\n   * @type Function(node: HtmlElement, isAppearing: bool)\n   */\n  onEntering: PropTypes.func,\n\n  /**\n   * Callback fired after the \"entered\" status is applied. An extra parameter\n   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount\n   *\n   * @type Function(node: HtmlElement, isAppearing: bool) -> void\n   */\n  onEntered: PropTypes.func,\n\n  /**\n   * Callback fired before the \"exiting\" status is applied.\n   *\n   * @type Function(node: HtmlElement) -> void\n   */\n  onExit: PropTypes.func,\n\n  /**\n   * Callback fired after the \"exiting\" status is applied.\n   *\n   * @type Function(node: HtmlElement) -> void\n   */\n  onExiting: PropTypes.func,\n\n  /**\n   * Callback fired after the \"exited\" status is applied.\n   *\n   * @type Function(node: HtmlElement) -> void\n   */\n  onExited: PropTypes.func\n\n  // Name the function so it is clearer in the documentation\n} : {};function noop() {}\n\nTransition.defaultProps = {\n  in: false,\n  mountOnEnter: false,\n  unmountOnExit: false,\n  appear: false,\n  enter: true,\n  exit: true,\n\n  onEnter: noop,\n  onEntering: noop,\n  onEntered: noop,\n\n  onExit: noop,\n  onExiting: noop,\n  onExited: noop\n};\n\nTransition.UNMOUNTED = 0;\nTransition.EXITED = 1;\nTransition.ENTERING = 2;\nTransition.ENTERED = 3;\nTransition.EXITING = 4;\n\nexports.default = (0, _reactLifecyclesCompat.polyfill)(Transition);\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$react_lifecycles_compat$react_lifecycles_compat_cjs","~$module$node_modules$react_dom$index","~$module$node_modules$react$index","~$module$node_modules$prop_types$index","~$shadow.js","~$module$node_modules$react_transition_group$utils$PropTypes"]],"~:properties",["^5",["appear","EXITED","getDerivedStateFromProps","onExited","getChildContext","cancel","childContextTypes","prototype","unmountOnExit","cancelNextCallback","safeSetState","updateStatus","performEnter","__esModule","EXITING","propTypes","transitionGroup","appearStatus","configurable","value","setNextCallback","UNMOUNTED","enumerable","onEntering","getTimeouts","status","onExit","componentDidUpdate","performExit","onEntered","contextTypes","writable","componentDidMount","defaultProps","render","onExiting","state","__proto__","exit","onTransitionEnd","componentWillUnmount","nextCallback","mountOnEnter","ENTERED","onEnter","ENTERING","enter","default","constructor","in"]],"~:compiled-at",1537815743068,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$react_transition_group$Transition.js\",\n\"lineCount\":10,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/react-transition-group/Transition.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$react_transition_group$Transition\\\"] = function(global,process,require,module,exports,shadow$shims) {\\n'use strict';\\n\\nexports.__esModule = true;\\nexports.EXITING = exports.ENTERED = exports.ENTERING = exports.EXITED = exports.UNMOUNTED = undefined;\\n\\nvar _propTypes = require('prop-types');\\n\\nvar PropTypes = _interopRequireWildcard(_propTypes);\\n\\nvar _react = require('react');\\n\\nvar _react2 = _interopRequireDefault(_react);\\n\\nvar _reactDom = require('react-dom');\\n\\nvar _reactDom2 = _interopRequireDefault(_reactDom);\\n\\nvar _reactLifecyclesCompat = require('react-lifecycles-compat');\\n\\nvar _PropTypes = require('./utils/PropTypes');\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\\n\\nfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return call && (typeof call === \\\"object\\\" || typeof call === \\\"function\\\") ? call : self; }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function, not \\\" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nvar UNMOUNTED = exports.UNMOUNTED = 'unmounted';\\nvar EXITED = exports.EXITED = 'exited';\\nvar ENTERING = exports.ENTERING = 'entering';\\nvar ENTERED = exports.ENTERED = 'entered';\\nvar EXITING = exports.EXITING = 'exiting';\\n\\n/**\\n * The Transition component lets you describe a transition from one component\\n * state to another _over time_ with a simple declarative API. Most commonly\\n * it's used to animate the mounting and unmounting of a component, but can also\\n * be used to describe in-place transition states as well.\\n *\\n * By default the `Transition` component does not alter the behavior of the\\n * component it renders, it only tracks \\\"enter\\\" and \\\"exit\\\" states for the components.\\n * It's up to you to give meaning and effect to those states. For example we can\\n * add styles to a component when it enters or exits:\\n *\\n * ```jsx\\n * import Transition from 'react-transition-group/Transition';\\n *\\n * const duration = 300;\\n *\\n * const defaultStyle = {\\n *   transition: `opacity ${duration}ms ease-in-out`,\\n *   opacity: 0,\\n * }\\n *\\n * const transitionStyles = {\\n *   entering: { opacity: 0 },\\n *   entered:  { opacity: 1 },\\n * };\\n *\\n * const Fade = ({ in: inProp }) => (\\n *   <Transition in={inProp} timeout={duration}>\\n *     {(state) => (\\n *       <div style={{\\n *         ...defaultStyle,\\n *         ...transitionStyles[state]\\n *       }}>\\n *         I'm a fade Transition!\\n *       </div>\\n *     )}\\n *   </Transition>\\n * );\\n * ```\\n *\\n * As noted the `Transition` component doesn't _do_ anything by itself to its child component.\\n * What it does do is track transition states over time so you can update the\\n * component (such as by adding styles or classes) when it changes states.\\n *\\n * There are 4 main states a Transition can be in:\\n *  - `'entering'`\\n *  - `'entered'`\\n *  - `'exiting'`\\n *  - `'exited'`\\n *\\n * Transition state is toggled via the `in` prop. When `true` the component begins the\\n * \\\"Enter\\\" stage. During this stage, the component will shift from its current transition state,\\n * to `'entering'` for the duration of the transition and then to the `'entered'` stage once\\n * it's complete. Let's take the following example:\\n *\\n * ```jsx\\n * state = { in: false };\\n *\\n * toggleEnterState = () => {\\n *   this.setState({ in: true });\\n * }\\n *\\n * render() {\\n *   return (\\n *     <div>\\n *       <Transition in={this.state.in} timeout={500} />\\n *       <button onClick={this.toggleEnterState}>Click to Enter</button>\\n *     </div>\\n *   );\\n * }\\n * ```\\n *\\n * When the button is clicked the component will shift to the `'entering'` state and\\n * stay there for 500ms (the value of `timeout`) before it finally switches to `'entered'`.\\n *\\n * When `in` is `false` the same thing happens except the state moves from `'exiting'` to `'exited'`.\\n *\\n * ## Timing\\n *\\n * Timing is often the trickiest part of animation, mistakes can result in slight delays\\n * that are hard to pin down. A common example is when you want to add an exit transition,\\n * you should set the desired final styles when the state is `'exiting'`. That's when the\\n * transition to those styles will start and, if you matched the `timeout` prop with the\\n * CSS Transition duration, it will end exactly when the state changes to `'exited'`.\\n *\\n * > **Note**: For simpler transitions the `Transition` component might be enough, but\\n * > take into account that it's platform-agnostic, while the `CSSTransition` component\\n * > [forces reflows](https://github.com/reactjs/react-transition-group/blob/5007303e729a74be66a21c3e2205e4916821524b/src/CSSTransition.js#L208-L215)\\n * > in order to make more complex transitions more predictable. For example, even though\\n * > classes `example-enter` and `example-enter-active` are applied immediately one after\\n * > another, you can still transition from one to the other because of the forced reflow\\n * > (read [this issue](https://github.com/reactjs/react-transition-group/issues/159#issuecomment-322761171)\\n * > for more info). Take this into account when choosing between `Transition` and\\n * > `CSSTransition`.\\n *\\n * ## Example\\n *\\n * <iframe src=\\\"https://codesandbox.io/embed/741op4mmj0?fontsize=14\\\" style=\\\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\\\" sandbox=\\\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\\\"></iframe>\\n *\\n */\\n\\nvar Transition = function (_React$Component) {\\n  _inherits(Transition, _React$Component);\\n\\n  function Transition(props, context) {\\n    _classCallCheck(this, Transition);\\n\\n    var _this = _possibleConstructorReturn(this, _React$Component.call(this, props, context));\\n\\n    var parentGroup = context.transitionGroup;\\n    // In the context of a TransitionGroup all enters are really appears\\n    var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;\\n\\n    var initialStatus = void 0;\\n\\n    _this.appearStatus = null;\\n\\n    if (props.in) {\\n      if (appear) {\\n        initialStatus = EXITED;\\n        _this.appearStatus = ENTERING;\\n      } else {\\n        initialStatus = ENTERED;\\n      }\\n    } else {\\n      if (props.unmountOnExit || props.mountOnEnter) {\\n        initialStatus = UNMOUNTED;\\n      } else {\\n        initialStatus = EXITED;\\n      }\\n    }\\n\\n    _this.state = { status: initialStatus };\\n\\n    _this.nextCallback = null;\\n    return _this;\\n  }\\n\\n  Transition.prototype.getChildContext = function getChildContext() {\\n    return { transitionGroup: null // allows for nested Transitions\\n    };\\n  };\\n\\n  Transition.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {\\n    var nextIn = _ref.in;\\n\\n    if (nextIn && prevState.status === UNMOUNTED) {\\n      return { status: EXITED };\\n    }\\n    return null;\\n  };\\n\\n  // getSnapshotBeforeUpdate(prevProps) {\\n  //   let nextStatus = null\\n\\n  //   if (prevProps !== this.props) {\\n  //     const { status } = this.state\\n\\n  //     if (this.props.in) {\\n  //       if (status !== ENTERING && status !== ENTERED) {\\n  //         nextStatus = ENTERING\\n  //       }\\n  //     } else {\\n  //       if (status === ENTERING || status === ENTERED) {\\n  //         nextStatus = EXITING\\n  //       }\\n  //     }\\n  //   }\\n\\n  //   return { nextStatus }\\n  // }\\n\\n  Transition.prototype.componentDidMount = function componentDidMount() {\\n    this.updateStatus(true, this.appearStatus);\\n  };\\n\\n  Transition.prototype.componentDidUpdate = function componentDidUpdate(prevProps) {\\n    var nextStatus = null;\\n    if (prevProps !== this.props) {\\n      var status = this.state.status;\\n\\n\\n      if (this.props.in) {\\n        if (status !== ENTERING && status !== ENTERED) {\\n          nextStatus = ENTERING;\\n        }\\n      } else {\\n        if (status === ENTERING || status === ENTERED) {\\n          nextStatus = EXITING;\\n        }\\n      }\\n    }\\n    this.updateStatus(false, nextStatus);\\n  };\\n\\n  Transition.prototype.componentWillUnmount = function componentWillUnmount() {\\n    this.cancelNextCallback();\\n  };\\n\\n  Transition.prototype.getTimeouts = function getTimeouts() {\\n    var timeout = this.props.timeout;\\n\\n    var exit = void 0,\\n        enter = void 0,\\n        appear = void 0;\\n\\n    exit = enter = appear = timeout;\\n\\n    if (timeout != null && typeof timeout !== 'number') {\\n      exit = timeout.exit;\\n      enter = timeout.enter;\\n      appear = timeout.appear;\\n    }\\n    return { exit: exit, enter: enter, appear: appear };\\n  };\\n\\n  Transition.prototype.updateStatus = function updateStatus() {\\n    var mounting = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\\n    var nextStatus = arguments[1];\\n\\n    if (nextStatus !== null) {\\n      // nextStatus will always be ENTERING or EXITING.\\n      this.cancelNextCallback();\\n      var node = _reactDom2.default.findDOMNode(this);\\n\\n      if (nextStatus === ENTERING) {\\n        this.performEnter(node, mounting);\\n      } else {\\n        this.performExit(node);\\n      }\\n    } else if (this.props.unmountOnExit && this.state.status === EXITED) {\\n      this.setState({ status: UNMOUNTED });\\n    }\\n  };\\n\\n  Transition.prototype.performEnter = function performEnter(node, mounting) {\\n    var _this2 = this;\\n\\n    var enter = this.props.enter;\\n\\n    var appearing = this.context.transitionGroup ? this.context.transitionGroup.isMounting : mounting;\\n\\n    var timeouts = this.getTimeouts();\\n\\n    // no enter animation skip right to ENTERED\\n    // if we are mounting and running this it means appear _must_ be set\\n    if (!mounting && !enter) {\\n      this.safeSetState({ status: ENTERED }, function () {\\n        _this2.props.onEntered(node);\\n      });\\n      return;\\n    }\\n\\n    this.props.onEnter(node, appearing);\\n\\n    this.safeSetState({ status: ENTERING }, function () {\\n      _this2.props.onEntering(node, appearing);\\n\\n      // FIXME: appear timeout?\\n      _this2.onTransitionEnd(node, timeouts.enter, function () {\\n        _this2.safeSetState({ status: ENTERED }, function () {\\n          _this2.props.onEntered(node, appearing);\\n        });\\n      });\\n    });\\n  };\\n\\n  Transition.prototype.performExit = function performExit(node) {\\n    var _this3 = this;\\n\\n    var exit = this.props.exit;\\n\\n    var timeouts = this.getTimeouts();\\n\\n    // no exit animation skip right to EXITED\\n    if (!exit) {\\n      this.safeSetState({ status: EXITED }, function () {\\n        _this3.props.onExited(node);\\n      });\\n      return;\\n    }\\n    this.props.onExit(node);\\n\\n    this.safeSetState({ status: EXITING }, function () {\\n      _this3.props.onExiting(node);\\n\\n      _this3.onTransitionEnd(node, timeouts.exit, function () {\\n        _this3.safeSetState({ status: EXITED }, function () {\\n          _this3.props.onExited(node);\\n        });\\n      });\\n    });\\n  };\\n\\n  Transition.prototype.cancelNextCallback = function cancelNextCallback() {\\n    if (this.nextCallback !== null) {\\n      this.nextCallback.cancel();\\n      this.nextCallback = null;\\n    }\\n  };\\n\\n  Transition.prototype.safeSetState = function safeSetState(nextState, callback) {\\n    // This shouldn't be necessary, but there are weird race conditions with\\n    // setState callbacks and unmounting in testing, so always make sure that\\n    // we can cancel any pending setState callbacks after we unmount.\\n    callback = this.setNextCallback(callback);\\n    this.setState(nextState, callback);\\n  };\\n\\n  Transition.prototype.setNextCallback = function setNextCallback(callback) {\\n    var _this4 = this;\\n\\n    var active = true;\\n\\n    this.nextCallback = function (event) {\\n      if (active) {\\n        active = false;\\n        _this4.nextCallback = null;\\n\\n        callback(event);\\n      }\\n    };\\n\\n    this.nextCallback.cancel = function () {\\n      active = false;\\n    };\\n\\n    return this.nextCallback;\\n  };\\n\\n  Transition.prototype.onTransitionEnd = function onTransitionEnd(node, timeout, handler) {\\n    this.setNextCallback(handler);\\n\\n    if (node) {\\n      if (this.props.addEndListener) {\\n        this.props.addEndListener(node, this.nextCallback);\\n      }\\n      if (timeout != null) {\\n        setTimeout(this.nextCallback, timeout);\\n      }\\n    } else {\\n      setTimeout(this.nextCallback, 0);\\n    }\\n  };\\n\\n  Transition.prototype.render = function render() {\\n    var status = this.state.status;\\n    if (status === UNMOUNTED) {\\n      return null;\\n    }\\n\\n    var _props = this.props,\\n        children = _props.children,\\n        childProps = _objectWithoutProperties(_props, ['children']);\\n    // filter props for Transtition\\n\\n\\n    delete childProps.in;\\n    delete childProps.mountOnEnter;\\n    delete childProps.unmountOnExit;\\n    delete childProps.appear;\\n    delete childProps.enter;\\n    delete childProps.exit;\\n    delete childProps.timeout;\\n    delete childProps.addEndListener;\\n    delete childProps.onEnter;\\n    delete childProps.onEntering;\\n    delete childProps.onEntered;\\n    delete childProps.onExit;\\n    delete childProps.onExiting;\\n    delete childProps.onExited;\\n\\n    if (typeof children === 'function') {\\n      return children(status, childProps);\\n    }\\n\\n    var child = _react2.default.Children.only(children);\\n    return _react2.default.cloneElement(child, childProps);\\n  };\\n\\n  return Transition;\\n}(_react2.default.Component);\\n\\nTransition.contextTypes = {\\n  transitionGroup: PropTypes.object\\n};\\nTransition.childContextTypes = {\\n  transitionGroup: function transitionGroup() {}\\n};\\n\\n\\nTransition.propTypes = process.env.NODE_ENV !== \\\"production\\\" ? {\\n  /**\\n   * A `function` child can be used instead of a React element.\\n   * This function is called with the current transition status\\n   * ('entering', 'entered', 'exiting', 'exited', 'unmounted'), which can be used\\n   * to apply context specific props to a component.\\n   *\\n   * ```jsx\\n   * <Transition timeout={150}>\\n   *   {(status) => (\\n   *     <MyComponent className={`fade fade-${status}`} />\\n   *   )}\\n   * </Transition>\\n   * ```\\n   */\\n  children: PropTypes.oneOfType([PropTypes.func.isRequired, PropTypes.element.isRequired]).isRequired,\\n\\n  /**\\n   * Show the component; triggers the enter or exit states\\n   */\\n  in: PropTypes.bool,\\n\\n  /**\\n   * By default the child component is mounted immediately along with\\n   * the parent `Transition` component. If you want to \\\"lazy mount\\\" the component on the\\n   * first `in={true}` you can set `mountOnEnter`. After the first enter transition the component will stay\\n   * mounted, even on \\\"exited\\\", unless you also specify `unmountOnExit`.\\n   */\\n  mountOnEnter: PropTypes.bool,\\n\\n  /**\\n   * By default the child component stays mounted after it reaches the `'exited'` state.\\n   * Set `unmountOnExit` if you'd prefer to unmount the component after it finishes exiting.\\n   */\\n  unmountOnExit: PropTypes.bool,\\n\\n  /**\\n   * Normally a component is not transitioned if it is shown when the `<Transition>` component mounts.\\n   * If you want to transition on the first mount set `appear` to `true`, and the\\n   * component will transition in as soon as the `<Transition>` mounts.\\n   *\\n   * > Note: there are no specific \\\"appear\\\" states. `appear` only adds an additional `enter` transition.\\n   */\\n  appear: PropTypes.bool,\\n\\n  /**\\n   * Enable or disable enter transitions.\\n   */\\n  enter: PropTypes.bool,\\n\\n  /**\\n   * Enable or disable exit transitions.\\n   */\\n  exit: PropTypes.bool,\\n\\n  /**\\n   * The duration of the transition, in milliseconds.\\n   * Required unless `addEndListener` is provided\\n   *\\n   * You may specify a single timeout for all transitions like: `timeout={500}`,\\n   * or individually like:\\n   *\\n   * ```jsx\\n   * timeout={{\\n   *  enter: 300,\\n   *  exit: 500,\\n   * }}\\n   * ```\\n   *\\n   * @type {number | { enter?: number, exit?: number }}\\n   */\\n  timeout: function timeout(props) {\\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\\n      args[_key - 1] = arguments[_key];\\n    }\\n\\n    var pt = _PropTypes.timeoutsShape;\\n    if (!props.addEndListener) pt = pt.isRequired;\\n    return pt.apply(undefined, [props].concat(args));\\n  },\\n\\n  /**\\n   * Add a custom transition end trigger. Called with the transitioning\\n   * DOM node and a `done` callback. Allows for more fine grained transition end\\n   * logic. **Note:** Timeouts are still used as a fallback if provided.\\n   *\\n   * ```jsx\\n   * addEndListener={(node, done) => {\\n   *   // use the css transitionend event to mark the finish of a transition\\n   *   node.addEventListener('transitionend', done, false);\\n   * }}\\n   * ```\\n   */\\n  addEndListener: PropTypes.func,\\n\\n  /**\\n   * Callback fired before the \\\"entering\\\" status is applied. An extra parameter\\n   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount\\n   *\\n   * @type Function(node: HtmlElement, isAppearing: bool) -> void\\n   */\\n  onEnter: PropTypes.func,\\n\\n  /**\\n   * Callback fired after the \\\"entering\\\" status is applied. An extra parameter\\n   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount\\n   *\\n   * @type Function(node: HtmlElement, isAppearing: bool)\\n   */\\n  onEntering: PropTypes.func,\\n\\n  /**\\n   * Callback fired after the \\\"entered\\\" status is applied. An extra parameter\\n   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount\\n   *\\n   * @type Function(node: HtmlElement, isAppearing: bool) -> void\\n   */\\n  onEntered: PropTypes.func,\\n\\n  /**\\n   * Callback fired before the \\\"exiting\\\" status is applied.\\n   *\\n   * @type Function(node: HtmlElement) -> void\\n   */\\n  onExit: PropTypes.func,\\n\\n  /**\\n   * Callback fired after the \\\"exiting\\\" status is applied.\\n   *\\n   * @type Function(node: HtmlElement) -> void\\n   */\\n  onExiting: PropTypes.func,\\n\\n  /**\\n   * Callback fired after the \\\"exited\\\" status is applied.\\n   *\\n   * @type Function(node: HtmlElement) -> void\\n   */\\n  onExited: PropTypes.func\\n\\n  // Name the function so it is clearer in the documentation\\n} : {};function noop() {}\\n\\nTransition.defaultProps = {\\n  in: false,\\n  mountOnEnter: false,\\n  unmountOnExit: false,\\n  appear: false,\\n  enter: true,\\n  exit: true,\\n\\n  onEnter: noop,\\n  onEntering: noop,\\n  onEntered: noop,\\n\\n  onExit: noop,\\n  onExiting: noop,\\n  onExited: noop\\n};\\n\\nTransition.UNMOUNTED = 0;\\nTransition.EXITED = 1;\\nTransition.ENTERING = 2;\\nTransition.ENTERED = 3;\\nTransition.EXITING = 4;\\n\\nexports.default = (0, _reactLifecyclesCompat.polyfill)(Transition);\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"process\",\"require\",\"module\",\"exports\",\"shadow$shims\",\"_inherits\",\"subClass\",\"superClass\",\"TypeError\",\"prototype\",\"Object\",\"create\",\"constructor\",\"value\",\"enumerable\",\"writable\",\"configurable\",\"setPrototypeOf\",\"__proto__\",\"noop\",\"__esModule\",\"EXITING\",\"ENTERED\",\"ENTERING\",\"EXITED\",\"UNMOUNTED\",\"undefined\",\"PropTypes\",\"_interopRequireWildcard\",\"obj\",\"newObj\",\"key\",\"hasOwnProperty\",\"call\",\"default\",\"_propTypes\",\"_react2\",\"_react\",\"_reactDom2\",\"_reactDom\",\"_reactLifecyclesCompat\",\"Transition\",\"_React$Component\",\"props\",\"context\",\"instance\",\"self\",\"ReferenceError\",\"appear\",\"parentGroup\",\"transitionGroup\",\"isMounting\",\"enter\",\"_this\",\"appearStatus\",\"in\",\"initialStatus\",\"unmountOnExit\",\"mountOnEnter\",\"state\",\"status\",\"nextCallback\",\"getChildContext\",\"Transition.prototype.getChildContext\",\"getDerivedStateFromProps\",\"Transition.getDerivedStateFromProps\",\"_ref\",\"prevState\",\"componentDidMount\",\"Transition.prototype.componentDidMount\",\"updateStatus\",\"componentDidUpdate\",\"Transition.prototype.componentDidUpdate\",\"prevProps\",\"nextStatus\",\"componentWillUnmount\",\"Transition.prototype.componentWillUnmount\",\"cancelNextCallback\",\"getTimeouts\",\"Transition.prototype.getTimeouts\",\"timeout\",\"exit\",\"Transition.prototype.updateStatus\",\"mounting\",\"arguments\",\"length\",\"node\",\"findDOMNode\",\"performEnter\",\"performExit\",\"setState\",\"Transition.prototype.performEnter\",\"_this2\",\"appearing\",\"timeouts\",\"onEnter\",\"safeSetState\",\"onEntering\",\"onTransitionEnd\",\"onEntered\",\"Transition.prototype.performExit\",\"_this3\",\"onExit\",\"onExiting\",\"onExited\",\"Transition.prototype.cancelNextCallback\",\"cancel\",\"Transition.prototype.safeSetState\",\"nextState\",\"callback\",\"setNextCallback\",\"Transition.prototype.setNextCallback\",\"_this4\",\"active\",\"this.nextCallback\",\"event\",\"this.nextCallback.cancel\",\"Transition.prototype.onTransitionEnd\",\"handler\",\"addEndListener\",\"setTimeout\",\"render\",\"Transition.prototype.render\",\"_props\",\"children\",\"target\",\"i\",\"keys\",\"indexOf\",\"child\",\"Children\",\"only\",\"cloneElement\",\"Component\",\"contextTypes\",\"object\",\"childContextTypes\",\"propTypes\",\"defaultProps\",\"polyfill\"]\n}\n"]