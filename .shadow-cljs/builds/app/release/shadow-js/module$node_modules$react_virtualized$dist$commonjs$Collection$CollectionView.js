["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/react-virtualized/dist/commonjs/Collection/CollectionView.js"],"~:js","shadow$provide.module$node_modules$react_virtualized$dist$commonjs$Collection$CollectionView=function(b,e,a,f,c,m){function d(a){return a&&a.__esModule?a:{default:a}}Object.defineProperty(c,\"__esModule\",{value:!0});b=a(\"module$node_modules$babel_runtime$helpers$extends\");var k=d(b);b=a(\"module$node_modules$babel_runtime$core_js$object$get_prototype_of\");var l=d(b);b=a(\"module$node_modules$babel_runtime$helpers$classCallCheck\");var h=d(b);b=a(\"module$node_modules$babel_runtime$helpers$createClass\");\nvar p=d(b);b=a(\"module$node_modules$babel_runtime$helpers$possibleConstructorReturn\");var r=d(b);b=a(\"module$node_modules$babel_runtime$helpers$inherits\");var q=d(b);b=a(\"module$node_modules$classnames$index\");var g=d(b);b=a(\"module$node_modules$prop_types$index\");d(b);var n=function(a){if(a&&a.__esModule)return a;var b={};if(null!=a)for(var c in a)Object.prototype.hasOwnProperty.call(a,c)&&(b[c]=a[c]);b.default=a;return b}(a(\"module$node_modules$react$index\"));b=a(\"module$node_modules$react_lifecycles_compat$react_lifecycles_compat_cjs\");\ne=a(\"module$node_modules$react_virtualized$dist$commonjs$utils$createCallbackMemoizer\");var v=d(e);a=a(\"module$node_modules$dom_helpers$util$scrollbarSize\");var y=d(a);a=function(a){function b(){var a;(0,h.default)(this,b);for(var c=arguments.length,d=Array(c),e=0;e<c;e++)d[e]=arguments[e];var g=(0,r.default)(this,(a=b.__proto__||(0,l.default)(b)).call.apply(a,[this].concat(d)));g.state={isScrolling:!1,scrollLeft:0,scrollTop:0};g._calculateSizeAndPositionDataOnNextUpdate=!1;g._onSectionRenderedMemoizer=\n(0,v.default)();g._onScrollMemoizer=(0,v.default)(!1);g._invokeOnSectionRenderedHelper=function(){var a=g.props;g._onSectionRenderedMemoizer({callback:a.onSectionRendered,indices:{indices:a.cellLayoutManager.getLastRenderedIndices()}})};g._setScrollingContainerRef=function(a){g._scrollingContainer=a};g._updateScrollPositionForScrollToCell=function(){var a=g.props,b=a.cellLayoutManager,c=a.height,d=a.scrollToAlignment,e=a.scrollToCell,f=a.width,h=g.state;a=h.scrollLeft;h=h.scrollTop;0<=e&&(b=b.getScrollPositionForCell({align:d,\ncellIndex:e,height:c,scrollLeft:a,scrollTop:h,width:f}),b.scrollLeft===a&&b.scrollTop===h||g._setScrollPosition(b))};g._onScroll=function(a){if(a.target===g._scrollingContainer){g._enablePointerEventsAfterDelay();var b=g.props,c=b.height,d=b.isScrollingChange,e=b.width,f=g._scrollbarSize,h=b.cellLayoutManager.getTotalSize();b=h.height;h=h.width;e=Math.max(0,Math.min(h-e+f,a.target.scrollLeft));c=Math.max(0,Math.min(b-c+f,a.target.scrollTop));if(g.state.scrollLeft!==e||g.state.scrollTop!==c)a=a.cancelable?\n\"observed\":\"requested\",g.state.isScrolling||d(!0),g.setState({isScrolling:!0,scrollLeft:e,scrollPositionChangeReason:a,scrollTop:c});g._invokeOnScrollMemoizer({scrollLeft:e,scrollTop:c,totalWidth:h,totalHeight:b})}};g._scrollbarSize=(0,y.default)();void 0===g._scrollbarSize?(g._scrollbarSizeMeasured=!1,g._scrollbarSize=0):g._scrollbarSizeMeasured=!0;return g}(0,q.default)(b,a);(0,p.default)(b,[{key:\"recomputeCellSizesAndPositions\",value:function(){this._calculateSizeAndPositionDataOnNextUpdate=!0;\nthis.forceUpdate()}},{key:\"componentDidMount\",value:function(){var a=this.props,b=a.cellLayoutManager,c=a.scrollLeft,d=a.scrollToCell;a=a.scrollTop;this._scrollbarSizeMeasured||(this._scrollbarSize=(0,y.default)(),this._scrollbarSizeMeasured=!0,this.setState({}));0<=d?this._updateScrollPositionForScrollToCell():(0<=c||0<=a)&&this._setScrollPosition({scrollLeft:c,scrollTop:a});this._invokeOnSectionRenderedHelper();b=b.getTotalSize();this._invokeOnScrollMemoizer({scrollLeft:c||0,scrollTop:a||0,totalHeight:b.height,\ntotalWidth:b.width})}},{key:\"componentDidUpdate\",value:function(a,b){var c=this.props,d=c.height,e=c.scrollToAlignment,g=c.scrollToCell;c=c.width;var f=this.state,h=f.scrollLeft,k=f.scrollTop;\"requested\"===f.scrollPositionChangeReason&&(0<=h&&h!==b.scrollLeft&&h!==this._scrollingContainer.scrollLeft&&(this._scrollingContainer.scrollLeft=h),0<=k&&k!==b.scrollTop&&k!==this._scrollingContainer.scrollTop&&(this._scrollingContainer.scrollTop=k));d===a.height&&e===a.scrollToAlignment&&g===a.scrollToCell&&\nc===a.width||this._updateScrollPositionForScrollToCell();this._invokeOnSectionRenderedHelper()}},{key:\"componentWillUnmount\",value:function(){this._disablePointerEventsTimeoutId&&clearTimeout(this._disablePointerEventsTimeoutId)}},{key:\"render\",value:function(){var a=this.props,b=a.autoHeight,c=a.cellCount,d=a.cellLayoutManager,e=a.className,f=a.height,h=a.horizontalOverscanSize,l=a.id,m=a.noContentRenderer,q=a.style,p=a.verticalOverscanSize;a=a.width;var r=this.state,x=r.isScrolling,v=r.scrollLeft,\ny=r.scrollTop;if(this._lastRenderedCellCount!==c||this._lastRenderedCellLayoutManager!==d||this._calculateSizeAndPositionDataOnNextUpdate)this._lastRenderedCellCount=c,this._lastRenderedCellLayoutManager=d,this._calculateSizeAndPositionDataOnNextUpdate=!1,d.calculateSizeAndPositionData();var w=d.getTotalSize();r=w.height;w=w.width;var O=Math.max(0,v-h),I=Math.max(0,y-p);h=Math.min(w,v+a+h);p=Math.min(r,y+f+p);d=0<f&&0<a?d.cellRenderers({height:p-I,isScrolling:x,width:h-O,x:O,y:I}):[];b={boxSizing:\"border-box\",\ndirection:\"ltr\",height:b?\"auto\":f,position:\"relative\",WebkitOverflowScrolling:\"touch\",width:a,willChange:\"transform\"};p=w>a?this._scrollbarSize:0;b.overflowX=w+(r>f?this._scrollbarSize:0)<=a?\"hidden\":\"auto\";b.overflowY=r+p<=f?\"hidden\":\"auto\";return n.createElement(\"div\",{ref:this._setScrollingContainerRef,\"aria-label\":this.props[\"aria-label\"],className:(0,g.default)(\"ReactVirtualized__Collection\",e),id:l,onScroll:this._onScroll,role:\"grid\",style:(0,k.default)({},b,q),tabIndex:0},0<c&&n.createElement(\"div\",\n{className:\"ReactVirtualized__Collection__innerScrollContainer\",style:{height:r,maxHeight:r,maxWidth:w,overflow:\"hidden\",pointerEvents:x?\"none\":\"\",width:w}},d),0===c&&m())}},{key:\"_enablePointerEventsAfterDelay\",value:function(){var a=this;this._disablePointerEventsTimeoutId&&clearTimeout(this._disablePointerEventsTimeoutId);this._disablePointerEventsTimeoutId=setTimeout(function(){var b=a.props.isScrollingChange;b(!1);a._disablePointerEventsTimeoutId=null;a.setState({isScrolling:!1})},150)}},{key:\"_invokeOnScrollMemoizer\",\nvalue:function(a){var b=this,c=a.totalHeight,d=a.totalWidth;this._onScrollMemoizer({callback:function(a){var e=b.props,g=e.onScroll;g({clientHeight:e.height,clientWidth:e.width,scrollHeight:c,scrollLeft:a.scrollLeft,scrollTop:a.scrollTop,scrollWidth:d})},indices:{scrollLeft:a.scrollLeft,scrollTop:a.scrollTop}})}},{key:\"_setScrollPosition\",value:function(a){var b=a.scrollLeft;a=a.scrollTop;var c={scrollPositionChangeReason:\"requested\"};0<=b&&(c.scrollLeft=b);0<=a&&(c.scrollTop=a);(0<=b&&b!==this.state.scrollLeft||\n0<=a&&a!==this.state.scrollTop)&&this.setState(c)}}],[{key:\"getDerivedStateFromProps\",value:function(a,b){return 0!==a.cellCount||0===b.scrollLeft&&0===b.scrollTop?a.scrollLeft!==b.scrollLeft||a.scrollTop!==b.scrollTop?{scrollLeft:null!=a.scrollLeft?a.scrollLeft:b.scrollLeft,scrollTop:null!=a.scrollTop?a.scrollTop:b.scrollTop}:null:{scrollLeft:0,scrollTop:0}}}]);return b}(n.PureComponent);a.defaultProps={\"aria-label\":\"grid\",horizontalOverscanSize:0,noContentRenderer:function(){return null},onScroll:function(){return null},\nonSectionRendered:function(){return null},scrollToAlignment:\"auto\",scrollToCell:-1,style:{},verticalOverscanSize:0};a.propTypes={};(0,b.polyfill)(a);c.default=a}","~:source","shadow$provide[\"module$node_modules$react_virtualized$dist$commonjs$Collection$CollectionView\"] = function(global,process,require,module,exports,shadow$shims) {\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends2 = require('babel-runtime/helpers/extends');\n\nvar _extends3 = _interopRequireDefault(_extends2);\n\nvar _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = require('babel-runtime/helpers/inherits');\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _classnames = require('classnames');\n\nvar _classnames2 = _interopRequireDefault(_classnames);\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _react = require('react');\n\nvar React = _interopRequireWildcard(_react);\n\nvar _reactLifecyclesCompat = require('react-lifecycles-compat');\n\nvar _createCallbackMemoizer = require('../utils/createCallbackMemoizer');\n\nvar _createCallbackMemoizer2 = _interopRequireDefault(_createCallbackMemoizer);\n\nvar _scrollbarSize = require('dom-helpers/util/scrollbarSize');\n\nvar _scrollbarSize2 = _interopRequireDefault(_scrollbarSize);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// @TODO Merge Collection and CollectionView\n\n/**\n * Specifies the number of milliseconds during which to disable pointer events while a scroll is in progress.\n * This improves performance and makes scrolling smoother.\n */\nvar IS_SCROLLING_TIMEOUT = 150;\n\n/**\n * Controls whether the Grid updates the DOM element's scrollLeft/scrollTop based on the current state or just observes it.\n * This prevents Grid from interrupting mouse-wheel animations (see issue #2).\n */\nvar SCROLL_POSITION_CHANGE_REASONS = {\n  OBSERVED: 'observed',\n  REQUESTED: 'requested'\n};\n\n/**\n * Monitors changes in properties (eg. cellCount) and state (eg. scroll offsets) to determine when rendering needs to occur.\n * This component does not render any visible content itself; it defers to the specified :cellLayoutManager.\n */\n\nvar CollectionView = function (_React$PureComponent) {\n  (0, _inherits3.default)(CollectionView, _React$PureComponent);\n\n  // Invokes callbacks only when their values have changed.\n  function CollectionView() {\n    var _ref;\n\n    (0, _classCallCheck3.default)(this, CollectionView);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    // If this component is being rendered server-side, getScrollbarSize() will return undefined.\n    // We handle this case in componentDidMount()\n    var _this = (0, _possibleConstructorReturn3.default)(this, (_ref = CollectionView.__proto__ || (0, _getPrototypeOf2.default)(CollectionView)).call.apply(_ref, [this].concat(args)));\n\n    _this.state = {\n      isScrolling: false,\n      scrollLeft: 0,\n      scrollTop: 0\n    };\n    _this._calculateSizeAndPositionDataOnNextUpdate = false;\n    _this._onSectionRenderedMemoizer = (0, _createCallbackMemoizer2.default)();\n    _this._onScrollMemoizer = (0, _createCallbackMemoizer2.default)(false);\n\n    _this._invokeOnSectionRenderedHelper = function () {\n      var _this$props = _this.props,\n          cellLayoutManager = _this$props.cellLayoutManager,\n          onSectionRendered = _this$props.onSectionRendered;\n\n\n      _this._onSectionRenderedMemoizer({\n        callback: onSectionRendered,\n        indices: {\n          indices: cellLayoutManager.getLastRenderedIndices()\n        }\n      });\n    };\n\n    _this._setScrollingContainerRef = function (ref) {\n      _this._scrollingContainer = ref;\n    };\n\n    _this._updateScrollPositionForScrollToCell = function () {\n      var _this$props2 = _this.props,\n          cellLayoutManager = _this$props2.cellLayoutManager,\n          height = _this$props2.height,\n          scrollToAlignment = _this$props2.scrollToAlignment,\n          scrollToCell = _this$props2.scrollToCell,\n          width = _this$props2.width;\n      var _this$state = _this.state,\n          scrollLeft = _this$state.scrollLeft,\n          scrollTop = _this$state.scrollTop;\n\n\n      if (scrollToCell >= 0) {\n        var scrollPosition = cellLayoutManager.getScrollPositionForCell({\n          align: scrollToAlignment,\n          cellIndex: scrollToCell,\n          height: height,\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          width: width\n        });\n\n        if (scrollPosition.scrollLeft !== scrollLeft || scrollPosition.scrollTop !== scrollTop) {\n          _this._setScrollPosition(scrollPosition);\n        }\n      }\n    };\n\n    _this._onScroll = function (event) {\n      // In certain edge-cases React dispatches an onScroll event with an invalid target.scrollLeft / target.scrollTop.\n      // This invalid event can be detected by comparing event.target to this component's scrollable DOM element.\n      // See issue #404 for more information.\n      if (event.target !== _this._scrollingContainer) {\n        return;\n      }\n\n      // Prevent pointer events from interrupting a smooth scroll\n      _this._enablePointerEventsAfterDelay();\n\n      // When this component is shrunk drastically, React dispatches a series of back-to-back scroll events,\n      // Gradually converging on a scrollTop that is within the bounds of the new, smaller height.\n      // This causes a series of rapid renders that is slow for long lists.\n      // We can avoid that by doing some simple bounds checking to ensure that scrollTop never exceeds the total height.\n      var _this$props3 = _this.props,\n          cellLayoutManager = _this$props3.cellLayoutManager,\n          height = _this$props3.height,\n          isScrollingChange = _this$props3.isScrollingChange,\n          width = _this$props3.width;\n\n      var scrollbarSize = _this._scrollbarSize;\n\n      var _cellLayoutManager$ge = cellLayoutManager.getTotalSize(),\n          totalHeight = _cellLayoutManager$ge.height,\n          totalWidth = _cellLayoutManager$ge.width;\n\n      var scrollLeft = Math.max(0, Math.min(totalWidth - width + scrollbarSize, event.target.scrollLeft));\n      var scrollTop = Math.max(0, Math.min(totalHeight - height + scrollbarSize, event.target.scrollTop));\n\n      // Certain devices (like Apple touchpad) rapid-fire duplicate events.\n      // Don't force a re-render if this is the case.\n      // The mouse may move faster then the animation frame does.\n      // Use requestAnimationFrame to avoid over-updating.\n      if (_this.state.scrollLeft !== scrollLeft || _this.state.scrollTop !== scrollTop) {\n        // Browsers with cancelable scroll events (eg. Firefox) interrupt scrolling animations if scrollTop/scrollLeft is set.\n        // Other browsers (eg. Safari) don't scroll as well without the help under certain conditions (DOM or style changes during scrolling).\n        // All things considered, this seems to be the best current work around that I'm aware of.\n        // For more information see https://github.com/bvaughn/react-virtualized/pull/124\n        var scrollPositionChangeReason = event.cancelable ? SCROLL_POSITION_CHANGE_REASONS.OBSERVED : SCROLL_POSITION_CHANGE_REASONS.REQUESTED;\n\n        // Synchronously set :isScrolling the first time (since _setNextState will reschedule its animation frame each time it's called)\n        if (!_this.state.isScrolling) {\n          isScrollingChange(true);\n        }\n\n        _this.setState({\n          isScrolling: true,\n          scrollLeft: scrollLeft,\n          scrollPositionChangeReason: scrollPositionChangeReason,\n          scrollTop: scrollTop\n        });\n      }\n\n      _this._invokeOnScrollMemoizer({\n        scrollLeft: scrollLeft,\n        scrollTop: scrollTop,\n        totalWidth: totalWidth,\n        totalHeight: totalHeight\n      });\n    };\n\n    _this._scrollbarSize = (0, _scrollbarSize2.default)();\n    if (_this._scrollbarSize === undefined) {\n      _this._scrollbarSizeMeasured = false;\n      _this._scrollbarSize = 0;\n    } else {\n      _this._scrollbarSizeMeasured = true;\n    }\n    return _this;\n  }\n\n  /**\n   * Forced recompute of cell sizes and positions.\n   * This function should be called if cell sizes have changed but nothing else has.\n   * Since cell positions are calculated by callbacks, the collection view has no way of detecting when the underlying data has changed.\n   */\n\n\n  (0, _createClass3.default)(CollectionView, [{\n    key: 'recomputeCellSizesAndPositions',\n    value: function recomputeCellSizesAndPositions() {\n      this._calculateSizeAndPositionDataOnNextUpdate = true;\n      this.forceUpdate();\n    }\n\n    /* ---------------------------- Component lifecycle methods ---------------------------- */\n\n    /**\n     * @private\n     * This method updates scrollLeft/scrollTop in state for the following conditions:\n     * 1) Empty content (0 rows or columns)\n     * 2) New scroll props overriding the current state\n     * 3) Cells-count or cells-size has changed, making previous scroll offsets invalid\n     */\n\n  }, {\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      var _props = this.props,\n          cellLayoutManager = _props.cellLayoutManager,\n          scrollLeft = _props.scrollLeft,\n          scrollToCell = _props.scrollToCell,\n          scrollTop = _props.scrollTop;\n\n      // If this component was first rendered server-side, scrollbar size will be undefined.\n      // In that event we need to remeasure.\n\n      if (!this._scrollbarSizeMeasured) {\n        this._scrollbarSize = (0, _scrollbarSize2.default)();\n        this._scrollbarSizeMeasured = true;\n        this.setState({});\n      }\n\n      if (scrollToCell >= 0) {\n        this._updateScrollPositionForScrollToCell();\n      } else if (scrollLeft >= 0 || scrollTop >= 0) {\n        this._setScrollPosition({ scrollLeft: scrollLeft, scrollTop: scrollTop });\n      }\n\n      // Update onSectionRendered callback.\n      this._invokeOnSectionRenderedHelper();\n\n      var _cellLayoutManager$ge2 = cellLayoutManager.getTotalSize(),\n          totalHeight = _cellLayoutManager$ge2.height,\n          totalWidth = _cellLayoutManager$ge2.width;\n\n      // Initialize onScroll callback.\n\n\n      this._invokeOnScrollMemoizer({\n        scrollLeft: scrollLeft || 0,\n        scrollTop: scrollTop || 0,\n        totalHeight: totalHeight,\n        totalWidth: totalWidth\n      });\n    }\n  }, {\n    key: 'componentDidUpdate',\n    value: function componentDidUpdate(prevProps, prevState) {\n      var _props2 = this.props,\n          height = _props2.height,\n          scrollToAlignment = _props2.scrollToAlignment,\n          scrollToCell = _props2.scrollToCell,\n          width = _props2.width;\n      var _state = this.state,\n          scrollLeft = _state.scrollLeft,\n          scrollPositionChangeReason = _state.scrollPositionChangeReason,\n          scrollTop = _state.scrollTop;\n\n      // Make sure requested changes to :scrollLeft or :scrollTop get applied.\n      // Assigning to scrollLeft/scrollTop tells the browser to interrupt any running scroll animations,\n      // And to discard any pending async changes to the scroll position that may have happened in the meantime (e.g. on a separate scrolling thread).\n      // So we only set these when we require an adjustment of the scroll position.\n      // See issue #2 for more information.\n\n      if (scrollPositionChangeReason === SCROLL_POSITION_CHANGE_REASONS.REQUESTED) {\n        if (scrollLeft >= 0 && scrollLeft !== prevState.scrollLeft && scrollLeft !== this._scrollingContainer.scrollLeft) {\n          this._scrollingContainer.scrollLeft = scrollLeft;\n        }\n        if (scrollTop >= 0 && scrollTop !== prevState.scrollTop && scrollTop !== this._scrollingContainer.scrollTop) {\n          this._scrollingContainer.scrollTop = scrollTop;\n        }\n      }\n\n      // Update scroll offsets if the current :scrollToCell values requires it\n      if (height !== prevProps.height || scrollToAlignment !== prevProps.scrollToAlignment || scrollToCell !== prevProps.scrollToCell || width !== prevProps.width) {\n        this._updateScrollPositionForScrollToCell();\n      }\n\n      // Update onRowsRendered callback if start/stop indices have changed\n      this._invokeOnSectionRenderedHelper();\n    }\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      if (this._disablePointerEventsTimeoutId) {\n        clearTimeout(this._disablePointerEventsTimeoutId);\n      }\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _props3 = this.props,\n          autoHeight = _props3.autoHeight,\n          cellCount = _props3.cellCount,\n          cellLayoutManager = _props3.cellLayoutManager,\n          className = _props3.className,\n          height = _props3.height,\n          horizontalOverscanSize = _props3.horizontalOverscanSize,\n          id = _props3.id,\n          noContentRenderer = _props3.noContentRenderer,\n          style = _props3.style,\n          verticalOverscanSize = _props3.verticalOverscanSize,\n          width = _props3.width;\n      var _state2 = this.state,\n          isScrolling = _state2.isScrolling,\n          scrollLeft = _state2.scrollLeft,\n          scrollTop = _state2.scrollTop;\n\n      // Memoization reset\n\n      if (this._lastRenderedCellCount !== cellCount || this._lastRenderedCellLayoutManager !== cellLayoutManager || this._calculateSizeAndPositionDataOnNextUpdate) {\n        this._lastRenderedCellCount = cellCount;\n        this._lastRenderedCellLayoutManager = cellLayoutManager;\n        this._calculateSizeAndPositionDataOnNextUpdate = false;\n\n        cellLayoutManager.calculateSizeAndPositionData();\n      }\n\n      var _cellLayoutManager$ge3 = cellLayoutManager.getTotalSize(),\n          totalHeight = _cellLayoutManager$ge3.height,\n          totalWidth = _cellLayoutManager$ge3.width;\n\n      // Safely expand the rendered area by the specified overscan amount\n\n\n      var left = Math.max(0, scrollLeft - horizontalOverscanSize);\n      var top = Math.max(0, scrollTop - verticalOverscanSize);\n      var right = Math.min(totalWidth, scrollLeft + width + horizontalOverscanSize);\n      var bottom = Math.min(totalHeight, scrollTop + height + verticalOverscanSize);\n\n      var childrenToDisplay = height > 0 && width > 0 ? cellLayoutManager.cellRenderers({\n        height: bottom - top,\n        isScrolling: isScrolling,\n        width: right - left,\n        x: left,\n        y: top\n      }) : [];\n\n      var collectionStyle = {\n        boxSizing: 'border-box',\n        direction: 'ltr',\n        height: autoHeight ? 'auto' : height,\n        position: 'relative',\n        WebkitOverflowScrolling: 'touch',\n        width: width,\n        willChange: 'transform'\n      };\n\n      // Force browser to hide scrollbars when we know they aren't necessary.\n      // Otherwise once scrollbars appear they may not disappear again.\n      // For more info see issue #116\n      var verticalScrollBarSize = totalHeight > height ? this._scrollbarSize : 0;\n      var horizontalScrollBarSize = totalWidth > width ? this._scrollbarSize : 0;\n\n      // Also explicitly init styles to 'auto' if scrollbars are required.\n      // This works around an obscure edge case where external CSS styles have not yet been loaded,\n      // But an initial scroll index of offset is set as an external prop.\n      // Without this style, Grid would render the correct range of cells but would NOT update its internal offset.\n      // This was originally reported via clauderic/react-infinite-calendar/issues/23\n      collectionStyle.overflowX = totalWidth + verticalScrollBarSize <= width ? 'hidden' : 'auto';\n      collectionStyle.overflowY = totalHeight + horizontalScrollBarSize <= height ? 'hidden' : 'auto';\n\n      return React.createElement(\n        'div',\n        {\n          ref: this._setScrollingContainerRef,\n          'aria-label': this.props['aria-label'],\n          className: (0, _classnames2.default)('ReactVirtualized__Collection', className),\n          id: id,\n          onScroll: this._onScroll,\n          role: 'grid',\n          style: (0, _extends3.default)({}, collectionStyle, style),\n          tabIndex: 0 },\n        cellCount > 0 && React.createElement(\n          'div',\n          {\n            className: 'ReactVirtualized__Collection__innerScrollContainer',\n            style: {\n              height: totalHeight,\n              maxHeight: totalHeight,\n              maxWidth: totalWidth,\n              overflow: 'hidden',\n              pointerEvents: isScrolling ? 'none' : '',\n              width: totalWidth\n            } },\n          childrenToDisplay\n        ),\n        cellCount === 0 && noContentRenderer()\n      );\n    }\n\n    /* ---------------------------- Helper methods ---------------------------- */\n\n    /**\n     * Sets an :isScrolling flag for a small window of time.\n     * This flag is used to disable pointer events on the scrollable portion of the Collection.\n     * This prevents jerky/stuttery mouse-wheel scrolling.\n     */\n\n  }, {\n    key: '_enablePointerEventsAfterDelay',\n    value: function _enablePointerEventsAfterDelay() {\n      var _this2 = this;\n\n      if (this._disablePointerEventsTimeoutId) {\n        clearTimeout(this._disablePointerEventsTimeoutId);\n      }\n\n      this._disablePointerEventsTimeoutId = setTimeout(function () {\n        var isScrollingChange = _this2.props.isScrollingChange;\n\n\n        isScrollingChange(false);\n\n        _this2._disablePointerEventsTimeoutId = null;\n        _this2.setState({\n          isScrolling: false\n        });\n      }, IS_SCROLLING_TIMEOUT);\n    }\n  }, {\n    key: '_invokeOnScrollMemoizer',\n    value: function _invokeOnScrollMemoizer(_ref2) {\n      var _this3 = this;\n\n      var scrollLeft = _ref2.scrollLeft,\n          scrollTop = _ref2.scrollTop,\n          totalHeight = _ref2.totalHeight,\n          totalWidth = _ref2.totalWidth;\n\n      this._onScrollMemoizer({\n        callback: function callback(_ref3) {\n          var scrollLeft = _ref3.scrollLeft,\n              scrollTop = _ref3.scrollTop;\n          var _props4 = _this3.props,\n              height = _props4.height,\n              onScroll = _props4.onScroll,\n              width = _props4.width;\n\n\n          onScroll({\n            clientHeight: height,\n            clientWidth: width,\n            scrollHeight: totalHeight,\n            scrollLeft: scrollLeft,\n            scrollTop: scrollTop,\n            scrollWidth: totalWidth\n          });\n        },\n        indices: {\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop\n        }\n      });\n    }\n  }, {\n    key: '_setScrollPosition',\n    value: function _setScrollPosition(_ref4) {\n      var scrollLeft = _ref4.scrollLeft,\n          scrollTop = _ref4.scrollTop;\n\n      var newState = {\n        scrollPositionChangeReason: SCROLL_POSITION_CHANGE_REASONS.REQUESTED\n      };\n\n      if (scrollLeft >= 0) {\n        newState.scrollLeft = scrollLeft;\n      }\n\n      if (scrollTop >= 0) {\n        newState.scrollTop = scrollTop;\n      }\n\n      if (scrollLeft >= 0 && scrollLeft !== this.state.scrollLeft || scrollTop >= 0 && scrollTop !== this.state.scrollTop) {\n        this.setState(newState);\n      }\n    }\n  }], [{\n    key: 'getDerivedStateFromProps',\n    value: function getDerivedStateFromProps(nextProps, prevState) {\n      if (nextProps.cellCount === 0 && (prevState.scrollLeft !== 0 || prevState.scrollTop !== 0)) {\n        return {\n          scrollLeft: 0,\n          scrollTop: 0\n        };\n      } else if (nextProps.scrollLeft !== prevState.scrollLeft || nextProps.scrollTop !== prevState.scrollTop) {\n        return {\n          scrollLeft: nextProps.scrollLeft != null ? nextProps.scrollLeft : prevState.scrollLeft,\n          scrollTop: nextProps.scrollTop != null ? nextProps.scrollTop : prevState.scrollTop\n        };\n      }\n\n      return null;\n    }\n  }]);\n  return CollectionView;\n}(React.PureComponent);\n\nCollectionView.defaultProps = {\n  'aria-label': 'grid',\n  horizontalOverscanSize: 0,\n  noContentRenderer: function noContentRenderer() {\n    return null;\n  },\n  onScroll: function onScroll() {\n    return null;\n  },\n  onSectionRendered: function onSectionRendered() {\n    return null;\n  },\n  scrollToAlignment: 'auto',\n  scrollToCell: -1,\n  style: {},\n  verticalOverscanSize: 0\n};\nCollectionView.propTypes = process.env.NODE_ENV !== \"production\" ? {\n  'aria-label': _propTypes2.default.string,\n\n  /**\n   * Removes fixed height from the scrollingContainer so that the total height\n   * of rows can stretch the window. Intended for use with WindowScroller\n   */\n  autoHeight: _propTypes2.default.bool,\n\n  /**\n   * Number of cells in collection.\n   */\n  cellCount: _propTypes2.default.number.isRequired,\n\n  /**\n   * Calculates cell sizes and positions and manages rendering the appropriate cells given a specified window.\n   */\n  cellLayoutManager: _propTypes2.default.object.isRequired,\n\n  /**\n   * Optional custom CSS class name to attach to root Collection element.\n   */\n  className: _propTypes2.default.string,\n\n  /**\n   * Height of Collection; this property determines the number of visible (vs virtualized) rows.\n   */\n  height: _propTypes2.default.number.isRequired,\n\n  /**\n   * Optional custom id to attach to root Collection element.\n   */\n  id: _propTypes2.default.string,\n\n  /**\n   * Enables the `Collection` to horiontally \"overscan\" its content similar to how `Grid` does.\n   * This can reduce flicker around the edges when a user scrolls quickly.\n   */\n  horizontalOverscanSize: _propTypes2.default.number.isRequired,\n\n  isScrollingChange: _propTypes2.default.func,\n\n  /**\n   * Optional renderer to be used in place of rows when either :rowCount or :cellCount is 0.\n   */\n  noContentRenderer: _propTypes2.default.func.isRequired,\n\n  /**\n   * Callback invoked whenever the scroll offset changes within the inner scrollable region.\n   * This callback can be used to sync scrolling between lists, tables, or grids.\n   * ({ clientHeight, clientWidth, scrollHeight, scrollLeft, scrollTop, scrollWidth }): void\n   */\n  onScroll: _propTypes2.default.func.isRequired,\n\n  /**\n   * Callback invoked with information about the section of the Collection that was just rendered.\n   * This callback is passed a named :indices parameter which is an Array of the most recently rendered section indices.\n   */\n  onSectionRendered: _propTypes2.default.func.isRequired,\n\n  /**\n   * Horizontal offset.\n   */\n  scrollLeft: _propTypes2.default.number,\n\n  /**\n   * Controls scroll-to-cell behavior of the Grid.\n   * The default (\"auto\") scrolls the least amount possible to ensure that the specified cell is fully visible.\n   * Use \"start\" to align cells to the top/left of the Grid and \"end\" to align bottom/right.\n   */\n  scrollToAlignment: _propTypes2.default.oneOf(['auto', 'end', 'start', 'center']).isRequired,\n\n  /**\n   * Cell index to ensure visible (by forcefully scrolling if necessary).\n   */\n  scrollToCell: _propTypes2.default.number.isRequired,\n\n  /**\n   * Vertical offset.\n   */\n  scrollTop: _propTypes2.default.number,\n\n  /**\n   * Optional custom inline style to attach to root Collection element.\n   */\n  style: _propTypes2.default.object,\n\n  /**\n   * Enables the `Collection` to vertically \"overscan\" its content similar to how `Grid` does.\n   * This can reduce flicker around the edges when a user scrolls quickly.\n   */\n  verticalOverscanSize: _propTypes2.default.number.isRequired,\n\n  /**\n   * Width of Collection; this property determines the number of visible (vs virtualized) columns.\n   */\n  width: _propTypes2.default.number.isRequired\n} : {};\n\n\n(0, _reactLifecyclesCompat.polyfill)(CollectionView);\n\nexports.default = CollectionView;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$react_virtualized$dist$commonjs$utils$createCallbackMemoizer","~$module$node_modules$react_lifecycles_compat$react_lifecycles_compat_cjs","~$module$node_modules$babel_runtime$helpers$possibleConstructorReturn","~$module$node_modules$react$index","~$module$node_modules$prop_types$index","~$shadow.js","~$module$node_modules$babel_runtime$helpers$inherits","~$module$node_modules$babel_runtime$core_js$object$get_prototype_of","~$module$node_modules$classnames$index","~$module$node_modules$dom_helpers$util$scrollbarSize","~$module$node_modules$babel_runtime$helpers$extends","~$module$node_modules$babel_runtime$helpers$classCallCheck","~$module$node_modules$babel_runtime$helpers$createClass"]],"~:properties",["^5",["scrollWidth","overflowX","callback","role","width","scrollPositionChangeReason","align","clientHeight","_scrollbarSizeMeasured","height","tabIndex","overflowY","_setScrollingContainerRef","willChange","scrollLeft","className","key","scrollToAlignment","x","__esModule","isScrolling","id","maxHeight","propTypes","position","_lastRenderedCellCount","style","value","scrollToCell","_lastRenderedCellLayoutManager","boxSizing","direction","_onScroll","_updateScrollPositionForScrollToCell","_calculateSizeAndPositionDataOnNextUpdate","_onSectionRenderedMemoizer","onSectionRendered","defaultProps","clientWidth","_onScrollMemoizer","overflow","y","verticalOverscanSize","_invokeOnSectionRenderedHelper","state","ref","totalHeight","horizontalOverscanSize","_scrollingContainer","_disablePointerEventsTimeoutId","maxWidth","totalWidth","onScroll","_scrollbarSize","scrollTop","scrollHeight","noContentRenderer","default","WebkitOverflowScrolling","pointerEvents","cellIndex","indices"]],"~:compiled-at",1537815743269,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$react_virtualized$dist$commonjs$Collection$CollectionView.js\",\n\"lineCount\":15,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/react-virtualized/dist/commonjs/Collection/CollectionView.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$react_virtualized$dist$commonjs$Collection$CollectionView\\\"] = function(global,process,require,module,exports,shadow$shims) {\\n'use strict';\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\n\\nvar _extends2 = require('babel-runtime/helpers/extends');\\n\\nvar _extends3 = _interopRequireDefault(_extends2);\\n\\nvar _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');\\n\\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\\n\\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\\n\\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\\n\\nvar _createClass2 = require('babel-runtime/helpers/createClass');\\n\\nvar _createClass3 = _interopRequireDefault(_createClass2);\\n\\nvar _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');\\n\\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\\n\\nvar _inherits2 = require('babel-runtime/helpers/inherits');\\n\\nvar _inherits3 = _interopRequireDefault(_inherits2);\\n\\nvar _classnames = require('classnames');\\n\\nvar _classnames2 = _interopRequireDefault(_classnames);\\n\\nvar _propTypes = require('prop-types');\\n\\nvar _propTypes2 = _interopRequireDefault(_propTypes);\\n\\nvar _react = require('react');\\n\\nvar React = _interopRequireWildcard(_react);\\n\\nvar _reactLifecyclesCompat = require('react-lifecycles-compat');\\n\\nvar _createCallbackMemoizer = require('../utils/createCallbackMemoizer');\\n\\nvar _createCallbackMemoizer2 = _interopRequireDefault(_createCallbackMemoizer);\\n\\nvar _scrollbarSize = require('dom-helpers/util/scrollbarSize');\\n\\nvar _scrollbarSize2 = _interopRequireDefault(_scrollbarSize);\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\\n\\n// @TODO Merge Collection and CollectionView\\n\\n/**\\n * Specifies the number of milliseconds during which to disable pointer events while a scroll is in progress.\\n * This improves performance and makes scrolling smoother.\\n */\\nvar IS_SCROLLING_TIMEOUT = 150;\\n\\n/**\\n * Controls whether the Grid updates the DOM element's scrollLeft/scrollTop based on the current state or just observes it.\\n * This prevents Grid from interrupting mouse-wheel animations (see issue #2).\\n */\\nvar SCROLL_POSITION_CHANGE_REASONS = {\\n  OBSERVED: 'observed',\\n  REQUESTED: 'requested'\\n};\\n\\n/**\\n * Monitors changes in properties (eg. cellCount) and state (eg. scroll offsets) to determine when rendering needs to occur.\\n * This component does not render any visible content itself; it defers to the specified :cellLayoutManager.\\n */\\n\\nvar CollectionView = function (_React$PureComponent) {\\n  (0, _inherits3.default)(CollectionView, _React$PureComponent);\\n\\n  // Invokes callbacks only when their values have changed.\\n  function CollectionView() {\\n    var _ref;\\n\\n    (0, _classCallCheck3.default)(this, CollectionView);\\n\\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\\n      args[_key] = arguments[_key];\\n    }\\n\\n    // If this component is being rendered server-side, getScrollbarSize() will return undefined.\\n    // We handle this case in componentDidMount()\\n    var _this = (0, _possibleConstructorReturn3.default)(this, (_ref = CollectionView.__proto__ || (0, _getPrototypeOf2.default)(CollectionView)).call.apply(_ref, [this].concat(args)));\\n\\n    _this.state = {\\n      isScrolling: false,\\n      scrollLeft: 0,\\n      scrollTop: 0\\n    };\\n    _this._calculateSizeAndPositionDataOnNextUpdate = false;\\n    _this._onSectionRenderedMemoizer = (0, _createCallbackMemoizer2.default)();\\n    _this._onScrollMemoizer = (0, _createCallbackMemoizer2.default)(false);\\n\\n    _this._invokeOnSectionRenderedHelper = function () {\\n      var _this$props = _this.props,\\n          cellLayoutManager = _this$props.cellLayoutManager,\\n          onSectionRendered = _this$props.onSectionRendered;\\n\\n\\n      _this._onSectionRenderedMemoizer({\\n        callback: onSectionRendered,\\n        indices: {\\n          indices: cellLayoutManager.getLastRenderedIndices()\\n        }\\n      });\\n    };\\n\\n    _this._setScrollingContainerRef = function (ref) {\\n      _this._scrollingContainer = ref;\\n    };\\n\\n    _this._updateScrollPositionForScrollToCell = function () {\\n      var _this$props2 = _this.props,\\n          cellLayoutManager = _this$props2.cellLayoutManager,\\n          height = _this$props2.height,\\n          scrollToAlignment = _this$props2.scrollToAlignment,\\n          scrollToCell = _this$props2.scrollToCell,\\n          width = _this$props2.width;\\n      var _this$state = _this.state,\\n          scrollLeft = _this$state.scrollLeft,\\n          scrollTop = _this$state.scrollTop;\\n\\n\\n      if (scrollToCell >= 0) {\\n        var scrollPosition = cellLayoutManager.getScrollPositionForCell({\\n          align: scrollToAlignment,\\n          cellIndex: scrollToCell,\\n          height: height,\\n          scrollLeft: scrollLeft,\\n          scrollTop: scrollTop,\\n          width: width\\n        });\\n\\n        if (scrollPosition.scrollLeft !== scrollLeft || scrollPosition.scrollTop !== scrollTop) {\\n          _this._setScrollPosition(scrollPosition);\\n        }\\n      }\\n    };\\n\\n    _this._onScroll = function (event) {\\n      // In certain edge-cases React dispatches an onScroll event with an invalid target.scrollLeft / target.scrollTop.\\n      // This invalid event can be detected by comparing event.target to this component's scrollable DOM element.\\n      // See issue #404 for more information.\\n      if (event.target !== _this._scrollingContainer) {\\n        return;\\n      }\\n\\n      // Prevent pointer events from interrupting a smooth scroll\\n      _this._enablePointerEventsAfterDelay();\\n\\n      // When this component is shrunk drastically, React dispatches a series of back-to-back scroll events,\\n      // Gradually converging on a scrollTop that is within the bounds of the new, smaller height.\\n      // This causes a series of rapid renders that is slow for long lists.\\n      // We can avoid that by doing some simple bounds checking to ensure that scrollTop never exceeds the total height.\\n      var _this$props3 = _this.props,\\n          cellLayoutManager = _this$props3.cellLayoutManager,\\n          height = _this$props3.height,\\n          isScrollingChange = _this$props3.isScrollingChange,\\n          width = _this$props3.width;\\n\\n      var scrollbarSize = _this._scrollbarSize;\\n\\n      var _cellLayoutManager$ge = cellLayoutManager.getTotalSize(),\\n          totalHeight = _cellLayoutManager$ge.height,\\n          totalWidth = _cellLayoutManager$ge.width;\\n\\n      var scrollLeft = Math.max(0, Math.min(totalWidth - width + scrollbarSize, event.target.scrollLeft));\\n      var scrollTop = Math.max(0, Math.min(totalHeight - height + scrollbarSize, event.target.scrollTop));\\n\\n      // Certain devices (like Apple touchpad) rapid-fire duplicate events.\\n      // Don't force a re-render if this is the case.\\n      // The mouse may move faster then the animation frame does.\\n      // Use requestAnimationFrame to avoid over-updating.\\n      if (_this.state.scrollLeft !== scrollLeft || _this.state.scrollTop !== scrollTop) {\\n        // Browsers with cancelable scroll events (eg. Firefox) interrupt scrolling animations if scrollTop/scrollLeft is set.\\n        // Other browsers (eg. Safari) don't scroll as well without the help under certain conditions (DOM or style changes during scrolling).\\n        // All things considered, this seems to be the best current work around that I'm aware of.\\n        // For more information see https://github.com/bvaughn/react-virtualized/pull/124\\n        var scrollPositionChangeReason = event.cancelable ? SCROLL_POSITION_CHANGE_REASONS.OBSERVED : SCROLL_POSITION_CHANGE_REASONS.REQUESTED;\\n\\n        // Synchronously set :isScrolling the first time (since _setNextState will reschedule its animation frame each time it's called)\\n        if (!_this.state.isScrolling) {\\n          isScrollingChange(true);\\n        }\\n\\n        _this.setState({\\n          isScrolling: true,\\n          scrollLeft: scrollLeft,\\n          scrollPositionChangeReason: scrollPositionChangeReason,\\n          scrollTop: scrollTop\\n        });\\n      }\\n\\n      _this._invokeOnScrollMemoizer({\\n        scrollLeft: scrollLeft,\\n        scrollTop: scrollTop,\\n        totalWidth: totalWidth,\\n        totalHeight: totalHeight\\n      });\\n    };\\n\\n    _this._scrollbarSize = (0, _scrollbarSize2.default)();\\n    if (_this._scrollbarSize === undefined) {\\n      _this._scrollbarSizeMeasured = false;\\n      _this._scrollbarSize = 0;\\n    } else {\\n      _this._scrollbarSizeMeasured = true;\\n    }\\n    return _this;\\n  }\\n\\n  /**\\n   * Forced recompute of cell sizes and positions.\\n   * This function should be called if cell sizes have changed but nothing else has.\\n   * Since cell positions are calculated by callbacks, the collection view has no way of detecting when the underlying data has changed.\\n   */\\n\\n\\n  (0, _createClass3.default)(CollectionView, [{\\n    key: 'recomputeCellSizesAndPositions',\\n    value: function recomputeCellSizesAndPositions() {\\n      this._calculateSizeAndPositionDataOnNextUpdate = true;\\n      this.forceUpdate();\\n    }\\n\\n    /* ---------------------------- Component lifecycle methods ---------------------------- */\\n\\n    /**\\n     * @private\\n     * This method updates scrollLeft/scrollTop in state for the following conditions:\\n     * 1) Empty content (0 rows or columns)\\n     * 2) New scroll props overriding the current state\\n     * 3) Cells-count or cells-size has changed, making previous scroll offsets invalid\\n     */\\n\\n  }, {\\n    key: 'componentDidMount',\\n    value: function componentDidMount() {\\n      var _props = this.props,\\n          cellLayoutManager = _props.cellLayoutManager,\\n          scrollLeft = _props.scrollLeft,\\n          scrollToCell = _props.scrollToCell,\\n          scrollTop = _props.scrollTop;\\n\\n      // If this component was first rendered server-side, scrollbar size will be undefined.\\n      // In that event we need to remeasure.\\n\\n      if (!this._scrollbarSizeMeasured) {\\n        this._scrollbarSize = (0, _scrollbarSize2.default)();\\n        this._scrollbarSizeMeasured = true;\\n        this.setState({});\\n      }\\n\\n      if (scrollToCell >= 0) {\\n        this._updateScrollPositionForScrollToCell();\\n      } else if (scrollLeft >= 0 || scrollTop >= 0) {\\n        this._setScrollPosition({ scrollLeft: scrollLeft, scrollTop: scrollTop });\\n      }\\n\\n      // Update onSectionRendered callback.\\n      this._invokeOnSectionRenderedHelper();\\n\\n      var _cellLayoutManager$ge2 = cellLayoutManager.getTotalSize(),\\n          totalHeight = _cellLayoutManager$ge2.height,\\n          totalWidth = _cellLayoutManager$ge2.width;\\n\\n      // Initialize onScroll callback.\\n\\n\\n      this._invokeOnScrollMemoizer({\\n        scrollLeft: scrollLeft || 0,\\n        scrollTop: scrollTop || 0,\\n        totalHeight: totalHeight,\\n        totalWidth: totalWidth\\n      });\\n    }\\n  }, {\\n    key: 'componentDidUpdate',\\n    value: function componentDidUpdate(prevProps, prevState) {\\n      var _props2 = this.props,\\n          height = _props2.height,\\n          scrollToAlignment = _props2.scrollToAlignment,\\n          scrollToCell = _props2.scrollToCell,\\n          width = _props2.width;\\n      var _state = this.state,\\n          scrollLeft = _state.scrollLeft,\\n          scrollPositionChangeReason = _state.scrollPositionChangeReason,\\n          scrollTop = _state.scrollTop;\\n\\n      // Make sure requested changes to :scrollLeft or :scrollTop get applied.\\n      // Assigning to scrollLeft/scrollTop tells the browser to interrupt any running scroll animations,\\n      // And to discard any pending async changes to the scroll position that may have happened in the meantime (e.g. on a separate scrolling thread).\\n      // So we only set these when we require an adjustment of the scroll position.\\n      // See issue #2 for more information.\\n\\n      if (scrollPositionChangeReason === SCROLL_POSITION_CHANGE_REASONS.REQUESTED) {\\n        if (scrollLeft >= 0 && scrollLeft !== prevState.scrollLeft && scrollLeft !== this._scrollingContainer.scrollLeft) {\\n          this._scrollingContainer.scrollLeft = scrollLeft;\\n        }\\n        if (scrollTop >= 0 && scrollTop !== prevState.scrollTop && scrollTop !== this._scrollingContainer.scrollTop) {\\n          this._scrollingContainer.scrollTop = scrollTop;\\n        }\\n      }\\n\\n      // Update scroll offsets if the current :scrollToCell values requires it\\n      if (height !== prevProps.height || scrollToAlignment !== prevProps.scrollToAlignment || scrollToCell !== prevProps.scrollToCell || width !== prevProps.width) {\\n        this._updateScrollPositionForScrollToCell();\\n      }\\n\\n      // Update onRowsRendered callback if start/stop indices have changed\\n      this._invokeOnSectionRenderedHelper();\\n    }\\n  }, {\\n    key: 'componentWillUnmount',\\n    value: function componentWillUnmount() {\\n      if (this._disablePointerEventsTimeoutId) {\\n        clearTimeout(this._disablePointerEventsTimeoutId);\\n      }\\n    }\\n  }, {\\n    key: 'render',\\n    value: function render() {\\n      var _props3 = this.props,\\n          autoHeight = _props3.autoHeight,\\n          cellCount = _props3.cellCount,\\n          cellLayoutManager = _props3.cellLayoutManager,\\n          className = _props3.className,\\n          height = _props3.height,\\n          horizontalOverscanSize = _props3.horizontalOverscanSize,\\n          id = _props3.id,\\n          noContentRenderer = _props3.noContentRenderer,\\n          style = _props3.style,\\n          verticalOverscanSize = _props3.verticalOverscanSize,\\n          width = _props3.width;\\n      var _state2 = this.state,\\n          isScrolling = _state2.isScrolling,\\n          scrollLeft = _state2.scrollLeft,\\n          scrollTop = _state2.scrollTop;\\n\\n      // Memoization reset\\n\\n      if (this._lastRenderedCellCount !== cellCount || this._lastRenderedCellLayoutManager !== cellLayoutManager || this._calculateSizeAndPositionDataOnNextUpdate) {\\n        this._lastRenderedCellCount = cellCount;\\n        this._lastRenderedCellLayoutManager = cellLayoutManager;\\n        this._calculateSizeAndPositionDataOnNextUpdate = false;\\n\\n        cellLayoutManager.calculateSizeAndPositionData();\\n      }\\n\\n      var _cellLayoutManager$ge3 = cellLayoutManager.getTotalSize(),\\n          totalHeight = _cellLayoutManager$ge3.height,\\n          totalWidth = _cellLayoutManager$ge3.width;\\n\\n      // Safely expand the rendered area by the specified overscan amount\\n\\n\\n      var left = Math.max(0, scrollLeft - horizontalOverscanSize);\\n      var top = Math.max(0, scrollTop - verticalOverscanSize);\\n      var right = Math.min(totalWidth, scrollLeft + width + horizontalOverscanSize);\\n      var bottom = Math.min(totalHeight, scrollTop + height + verticalOverscanSize);\\n\\n      var childrenToDisplay = height > 0 && width > 0 ? cellLayoutManager.cellRenderers({\\n        height: bottom - top,\\n        isScrolling: isScrolling,\\n        width: right - left,\\n        x: left,\\n        y: top\\n      }) : [];\\n\\n      var collectionStyle = {\\n        boxSizing: 'border-box',\\n        direction: 'ltr',\\n        height: autoHeight ? 'auto' : height,\\n        position: 'relative',\\n        WebkitOverflowScrolling: 'touch',\\n        width: width,\\n        willChange: 'transform'\\n      };\\n\\n      // Force browser to hide scrollbars when we know they aren't necessary.\\n      // Otherwise once scrollbars appear they may not disappear again.\\n      // For more info see issue #116\\n      var verticalScrollBarSize = totalHeight > height ? this._scrollbarSize : 0;\\n      var horizontalScrollBarSize = totalWidth > width ? this._scrollbarSize : 0;\\n\\n      // Also explicitly init styles to 'auto' if scrollbars are required.\\n      // This works around an obscure edge case where external CSS styles have not yet been loaded,\\n      // But an initial scroll index of offset is set as an external prop.\\n      // Without this style, Grid would render the correct range of cells but would NOT update its internal offset.\\n      // This was originally reported via clauderic/react-infinite-calendar/issues/23\\n      collectionStyle.overflowX = totalWidth + verticalScrollBarSize <= width ? 'hidden' : 'auto';\\n      collectionStyle.overflowY = totalHeight + horizontalScrollBarSize <= height ? 'hidden' : 'auto';\\n\\n      return React.createElement(\\n        'div',\\n        {\\n          ref: this._setScrollingContainerRef,\\n          'aria-label': this.props['aria-label'],\\n          className: (0, _classnames2.default)('ReactVirtualized__Collection', className),\\n          id: id,\\n          onScroll: this._onScroll,\\n          role: 'grid',\\n          style: (0, _extends3.default)({}, collectionStyle, style),\\n          tabIndex: 0 },\\n        cellCount > 0 && React.createElement(\\n          'div',\\n          {\\n            className: 'ReactVirtualized__Collection__innerScrollContainer',\\n            style: {\\n              height: totalHeight,\\n              maxHeight: totalHeight,\\n              maxWidth: totalWidth,\\n              overflow: 'hidden',\\n              pointerEvents: isScrolling ? 'none' : '',\\n              width: totalWidth\\n            } },\\n          childrenToDisplay\\n        ),\\n        cellCount === 0 && noContentRenderer()\\n      );\\n    }\\n\\n    /* ---------------------------- Helper methods ---------------------------- */\\n\\n    /**\\n     * Sets an :isScrolling flag for a small window of time.\\n     * This flag is used to disable pointer events on the scrollable portion of the Collection.\\n     * This prevents jerky/stuttery mouse-wheel scrolling.\\n     */\\n\\n  }, {\\n    key: '_enablePointerEventsAfterDelay',\\n    value: function _enablePointerEventsAfterDelay() {\\n      var _this2 = this;\\n\\n      if (this._disablePointerEventsTimeoutId) {\\n        clearTimeout(this._disablePointerEventsTimeoutId);\\n      }\\n\\n      this._disablePointerEventsTimeoutId = setTimeout(function () {\\n        var isScrollingChange = _this2.props.isScrollingChange;\\n\\n\\n        isScrollingChange(false);\\n\\n        _this2._disablePointerEventsTimeoutId = null;\\n        _this2.setState({\\n          isScrolling: false\\n        });\\n      }, IS_SCROLLING_TIMEOUT);\\n    }\\n  }, {\\n    key: '_invokeOnScrollMemoizer',\\n    value: function _invokeOnScrollMemoizer(_ref2) {\\n      var _this3 = this;\\n\\n      var scrollLeft = _ref2.scrollLeft,\\n          scrollTop = _ref2.scrollTop,\\n          totalHeight = _ref2.totalHeight,\\n          totalWidth = _ref2.totalWidth;\\n\\n      this._onScrollMemoizer({\\n        callback: function callback(_ref3) {\\n          var scrollLeft = _ref3.scrollLeft,\\n              scrollTop = _ref3.scrollTop;\\n          var _props4 = _this3.props,\\n              height = _props4.height,\\n              onScroll = _props4.onScroll,\\n              width = _props4.width;\\n\\n\\n          onScroll({\\n            clientHeight: height,\\n            clientWidth: width,\\n            scrollHeight: totalHeight,\\n            scrollLeft: scrollLeft,\\n            scrollTop: scrollTop,\\n            scrollWidth: totalWidth\\n          });\\n        },\\n        indices: {\\n          scrollLeft: scrollLeft,\\n          scrollTop: scrollTop\\n        }\\n      });\\n    }\\n  }, {\\n    key: '_setScrollPosition',\\n    value: function _setScrollPosition(_ref4) {\\n      var scrollLeft = _ref4.scrollLeft,\\n          scrollTop = _ref4.scrollTop;\\n\\n      var newState = {\\n        scrollPositionChangeReason: SCROLL_POSITION_CHANGE_REASONS.REQUESTED\\n      };\\n\\n      if (scrollLeft >= 0) {\\n        newState.scrollLeft = scrollLeft;\\n      }\\n\\n      if (scrollTop >= 0) {\\n        newState.scrollTop = scrollTop;\\n      }\\n\\n      if (scrollLeft >= 0 && scrollLeft !== this.state.scrollLeft || scrollTop >= 0 && scrollTop !== this.state.scrollTop) {\\n        this.setState(newState);\\n      }\\n    }\\n  }], [{\\n    key: 'getDerivedStateFromProps',\\n    value: function getDerivedStateFromProps(nextProps, prevState) {\\n      if (nextProps.cellCount === 0 && (prevState.scrollLeft !== 0 || prevState.scrollTop !== 0)) {\\n        return {\\n          scrollLeft: 0,\\n          scrollTop: 0\\n        };\\n      } else if (nextProps.scrollLeft !== prevState.scrollLeft || nextProps.scrollTop !== prevState.scrollTop) {\\n        return {\\n          scrollLeft: nextProps.scrollLeft != null ? nextProps.scrollLeft : prevState.scrollLeft,\\n          scrollTop: nextProps.scrollTop != null ? nextProps.scrollTop : prevState.scrollTop\\n        };\\n      }\\n\\n      return null;\\n    }\\n  }]);\\n  return CollectionView;\\n}(React.PureComponent);\\n\\nCollectionView.defaultProps = {\\n  'aria-label': 'grid',\\n  horizontalOverscanSize: 0,\\n  noContentRenderer: function noContentRenderer() {\\n    return null;\\n  },\\n  onScroll: function onScroll() {\\n    return null;\\n  },\\n  onSectionRendered: function onSectionRendered() {\\n    return null;\\n  },\\n  scrollToAlignment: 'auto',\\n  scrollToCell: -1,\\n  style: {},\\n  verticalOverscanSize: 0\\n};\\nCollectionView.propTypes = process.env.NODE_ENV !== \\\"production\\\" ? {\\n  'aria-label': _propTypes2.default.string,\\n\\n  /**\\n   * Removes fixed height from the scrollingContainer so that the total height\\n   * of rows can stretch the window. Intended for use with WindowScroller\\n   */\\n  autoHeight: _propTypes2.default.bool,\\n\\n  /**\\n   * Number of cells in collection.\\n   */\\n  cellCount: _propTypes2.default.number.isRequired,\\n\\n  /**\\n   * Calculates cell sizes and positions and manages rendering the appropriate cells given a specified window.\\n   */\\n  cellLayoutManager: _propTypes2.default.object.isRequired,\\n\\n  /**\\n   * Optional custom CSS class name to attach to root Collection element.\\n   */\\n  className: _propTypes2.default.string,\\n\\n  /**\\n   * Height of Collection; this property determines the number of visible (vs virtualized) rows.\\n   */\\n  height: _propTypes2.default.number.isRequired,\\n\\n  /**\\n   * Optional custom id to attach to root Collection element.\\n   */\\n  id: _propTypes2.default.string,\\n\\n  /**\\n   * Enables the `Collection` to horiontally \\\"overscan\\\" its content similar to how `Grid` does.\\n   * This can reduce flicker around the edges when a user scrolls quickly.\\n   */\\n  horizontalOverscanSize: _propTypes2.default.number.isRequired,\\n\\n  isScrollingChange: _propTypes2.default.func,\\n\\n  /**\\n   * Optional renderer to be used in place of rows when either :rowCount or :cellCount is 0.\\n   */\\n  noContentRenderer: _propTypes2.default.func.isRequired,\\n\\n  /**\\n   * Callback invoked whenever the scroll offset changes within the inner scrollable region.\\n   * This callback can be used to sync scrolling between lists, tables, or grids.\\n   * ({ clientHeight, clientWidth, scrollHeight, scrollLeft, scrollTop, scrollWidth }): void\\n   */\\n  onScroll: _propTypes2.default.func.isRequired,\\n\\n  /**\\n   * Callback invoked with information about the section of the Collection that was just rendered.\\n   * This callback is passed a named :indices parameter which is an Array of the most recently rendered section indices.\\n   */\\n  onSectionRendered: _propTypes2.default.func.isRequired,\\n\\n  /**\\n   * Horizontal offset.\\n   */\\n  scrollLeft: _propTypes2.default.number,\\n\\n  /**\\n   * Controls scroll-to-cell behavior of the Grid.\\n   * The default (\\\"auto\\\") scrolls the least amount possible to ensure that the specified cell is fully visible.\\n   * Use \\\"start\\\" to align cells to the top/left of the Grid and \\\"end\\\" to align bottom/right.\\n   */\\n  scrollToAlignment: _propTypes2.default.oneOf(['auto', 'end', 'start', 'center']).isRequired,\\n\\n  /**\\n   * Cell index to ensure visible (by forcefully scrolling if necessary).\\n   */\\n  scrollToCell: _propTypes2.default.number.isRequired,\\n\\n  /**\\n   * Vertical offset.\\n   */\\n  scrollTop: _propTypes2.default.number,\\n\\n  /**\\n   * Optional custom inline style to attach to root Collection element.\\n   */\\n  style: _propTypes2.default.object,\\n\\n  /**\\n   * Enables the `Collection` to vertically \\\"overscan\\\" its content similar to how `Grid` does.\\n   * This can reduce flicker around the edges when a user scrolls quickly.\\n   */\\n  verticalOverscanSize: _propTypes2.default.number.isRequired,\\n\\n  /**\\n   * Width of Collection; this property determines the number of visible (vs virtualized) columns.\\n   */\\n  width: _propTypes2.default.number.isRequired\\n} : {};\\n\\n\\n(0, _reactLifecyclesCompat.polyfill)(CollectionView);\\n\\nexports.default = CollectionView;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"process\",\"require\",\"module\",\"exports\",\"shadow$shims\",\"_interopRequireDefault\",\"obj\",\"__esModule\",\"default\",\"Object\",\"defineProperty\",\"value\",\"_extends2\",\"_extends3\",\"_getPrototypeOf\",\"_getPrototypeOf2\",\"_classCallCheck2\",\"_classCallCheck3\",\"_createClass2\",\"_createClass3\",\"_possibleConstructorReturn2\",\"_possibleConstructorReturn3\",\"_inherits2\",\"_inherits3\",\"_classnames\",\"_classnames2\",\"_propTypes\",\"React\",\"_interopRequireWildcard\",\"newObj\",\"key\",\"prototype\",\"hasOwnProperty\",\"call\",\"_react\",\"_reactLifecyclesCompat\",\"_createCallbackMemoizer\",\"_createCallbackMemoizer2\",\"_scrollbarSize\",\"_scrollbarSize2\",\"CollectionView\",\"_React$PureComponent\",\"_ref\",\"_len\",\"arguments\",\"length\",\"args\",\"Array\",\"_key\",\"_this\",\"__proto__\",\"apply\",\"concat\",\"state\",\"isScrolling\",\"scrollLeft\",\"scrollTop\",\"_calculateSizeAndPositionDataOnNextUpdate\",\"_onSectionRenderedMemoizer\",\"_onScrollMemoizer\",\"_invokeOnSectionRenderedHelper\",\"_this._invokeOnSectionRenderedHelper\",\"_this$props\",\"props\",\"callback\",\"onSectionRendered\",\"indices\",\"cellLayoutManager\",\"getLastRenderedIndices\",\"_setScrollingContainerRef\",\"_this._setScrollingContainerRef\",\"ref\",\"_scrollingContainer\",\"_updateScrollPositionForScrollToCell\",\"_this._updateScrollPositionForScrollToCell\",\"_this$props2\",\"height\",\"scrollToAlignment\",\"scrollToCell\",\"width\",\"_this$state\",\"scrollPosition\",\"getScrollPositionForCell\",\"align\",\"cellIndex\",\"_setScrollPosition\",\"_onScroll\",\"_this._onScroll\",\"event\",\"target\",\"_enablePointerEventsAfterDelay\",\"_this$props3\",\"isScrollingChange\",\"scrollbarSize\",\"_cellLayoutManager$ge\",\"getTotalSize\",\"totalHeight\",\"totalWidth\",\"Math\",\"max\",\"min\",\"scrollPositionChangeReason\",\"cancelable\",\"OBSERVED\",\"REQUESTED\",\"setState\",\"_invokeOnScrollMemoizer\",\"undefined\",\"_scrollbarSizeMeasured\",\"recomputeCellSizesAndPositions\",\"forceUpdate\",\"componentDidMount\",\"_props\",\"_cellLayoutManager$ge2\",\"componentDidUpdate\",\"prevProps\",\"prevState\",\"_props2\",\"_state\",\"componentWillUnmount\",\"_disablePointerEventsTimeoutId\",\"clearTimeout\",\"render\",\"_props3\",\"autoHeight\",\"cellCount\",\"className\",\"horizontalOverscanSize\",\"id\",\"noContentRenderer\",\"style\",\"verticalOverscanSize\",\"_state2\",\"_lastRenderedCellCount\",\"_lastRenderedCellLayoutManager\",\"calculateSizeAndPositionData\",\"_cellLayoutManager$ge3\",\"left\",\"top\",\"right\",\"bottom\",\"childrenToDisplay\",\"cellRenderers\",\"x\",\"y\",\"collectionStyle\",\"boxSizing\",\"direction\",\"position\",\"WebkitOverflowScrolling\",\"willChange\",\"horizontalScrollBarSize\",\"overflowX\",\"verticalScrollBarSize\",\"overflowY\",\"createElement\",\"onScroll\",\"role\",\"tabIndex\",\"maxHeight\",\"maxWidth\",\"overflow\",\"pointerEvents\",\"_this2\",\"setTimeout\",\"IS_SCROLLING_TIMEOUT\",\"_ref2\",\"_this3\",\"_ref3\",\"_props4\",\"clientHeight\",\"clientWidth\",\"scrollHeight\",\"scrollWidth\",\"_ref4\",\"newState\",\"getDerivedStateFromProps\",\"nextProps\",\"PureComponent\",\"defaultProps\",\"propTypes\",\"polyfill\"]\n}\n"]