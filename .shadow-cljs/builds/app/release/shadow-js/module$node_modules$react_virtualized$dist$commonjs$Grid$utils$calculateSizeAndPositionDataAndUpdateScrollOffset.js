["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/react-virtualized/dist/commonjs/Grid/utils/calculateSizeAndPositionDataAndUpdateScrollOffset.js"],"~:js","shadow$provide.module$node_modules$react_virtualized$dist$commonjs$Grid$utils$calculateSizeAndPositionDataAndUpdateScrollOffset=function(b,e,a,f,c,m){Object.defineProperty(c,\"__esModule\",{value:!0});c.default=function(a){var b=a.cellSize,c=a.computeMetadataCallback,d=a.computeMetadataCallbackProps,e=a.nextCellSize,f=a.nextScrollToIndex,q=a.scrollToIndex,g=a.updateScrollOffsetForScrollToIndex;if(a.cellCount!==a.nextCellsCount||(\"number\"===typeof b||\"number\"===typeof e)&&b!==e)c(d),0<=q&&q===f&&g()}}","~:source","shadow$provide[\"module$node_modules$react_virtualized$dist$commonjs$Grid$utils$calculateSizeAndPositionDataAndUpdateScrollOffset\"] = function(global,process,require,module,exports,shadow$shims) {\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = calculateSizeAndPositionDataAndUpdateScrollOffset;\nfunction calculateSizeAndPositionDataAndUpdateScrollOffset(_ref) {\n  var cellCount = _ref.cellCount,\n      cellSize = _ref.cellSize,\n      computeMetadataCallback = _ref.computeMetadataCallback,\n      computeMetadataCallbackProps = _ref.computeMetadataCallbackProps,\n      nextCellsCount = _ref.nextCellsCount,\n      nextCellSize = _ref.nextCellSize,\n      nextScrollToIndex = _ref.nextScrollToIndex,\n      scrollToIndex = _ref.scrollToIndex,\n      updateScrollOffsetForScrollToIndex = _ref.updateScrollOffsetForScrollToIndex;\n\n  // Don't compare cell sizes if they are functions because inline functions would cause infinite loops.\n  // In that event users should use the manual recompute methods to inform of changes.\n  if (cellCount !== nextCellsCount || (typeof cellSize === 'number' || typeof nextCellSize === 'number') && cellSize !== nextCellSize) {\n    computeMetadataCallback(computeMetadataCallbackProps);\n\n    // Updated cell metadata may have hidden the previous scrolled-to item.\n    // In this case we should also update the scrollTop to ensure it stays visible.\n    if (scrollToIndex >= 0 && scrollToIndex === nextScrollToIndex) {\n      updateScrollOffsetForScrollToIndex();\n    }\n  }\n}\n\n/**\n * Helper method that determines when to recalculate row or column metadata.\n */\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["__esModule","value","default"]],"~:compiled-at",1537815743247,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$react_virtualized$dist$commonjs$Grid$utils$calculateSizeAndPositionDataAndUpdateScrollOffset.js\",\n\"lineCount\":1,\n\"mappings\":\"AAAAA,cAAA,iHAAA,CAAqI,QAAQ,CAACC,CAAD,CAAQC,CAAR,CAAgBC,CAAhB,CAAwBC,CAAxB,CAA+BC,CAA/B,CAAuCC,CAAvC,CAAqD,CAGlMC,MAAAC,eAAA,CAAsBH,CAAtB,CAA+B,YAA/B,CAA6C,CAC3CI,MAAO,CAAA,CADoC,CAA7C,CAGAJ,EAAAK,QAAA,CACAC,QAA0D,CAACC,CAAD,CAAO,CAAA,IAE3DC,EAAWD,CAAAC,SAFgD,CAG3DC,EAA0BF,CAAAE,wBAHiC,CAI3DC,EAA+BH,CAAAG,6BAJ4B,CAM3DC,EAAeJ,CAAAI,aAN4C,CAO3DC,EAAoBL,CAAAK,kBAPuC,CAQ3DC,EAAgBN,CAAAM,cAR2C,CAS3DC,EAAqCP,CAAAO,mCAIzC,IAZgBP,CAAAQ,UAYhB,GARqBR,CAAAS,eAQrB,GAAyD,QAAzD,GAAqC,MAAOR,EAA5C,EAA6F,QAA7F,GAAqE,MAAOG,EAA5E,GAA0GH,CAA1G,GAAuHG,CAAvH,CACEF,CAAA,CAAwBC,CAAxB,CAIA,CAAqB,CAArB,EAAIG,CAAJ,EAA0BA,CAA1B,GAA4CD,CAA5C,EACEE,CAAA,EAnB2D,CAPiI;\",\n\"sources\":[\"node_modules/react-virtualized/dist/commonjs/Grid/utils/calculateSizeAndPositionDataAndUpdateScrollOffset.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$react_virtualized$dist$commonjs$Grid$utils$calculateSizeAndPositionDataAndUpdateScrollOffset\\\"] = function(global,process,require,module,exports,shadow$shims) {\\n'use strict';\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.default = calculateSizeAndPositionDataAndUpdateScrollOffset;\\nfunction calculateSizeAndPositionDataAndUpdateScrollOffset(_ref) {\\n  var cellCount = _ref.cellCount,\\n      cellSize = _ref.cellSize,\\n      computeMetadataCallback = _ref.computeMetadataCallback,\\n      computeMetadataCallbackProps = _ref.computeMetadataCallbackProps,\\n      nextCellsCount = _ref.nextCellsCount,\\n      nextCellSize = _ref.nextCellSize,\\n      nextScrollToIndex = _ref.nextScrollToIndex,\\n      scrollToIndex = _ref.scrollToIndex,\\n      updateScrollOffsetForScrollToIndex = _ref.updateScrollOffsetForScrollToIndex;\\n\\n  // Don't compare cell sizes if they are functions because inline functions would cause infinite loops.\\n  // In that event users should use the manual recompute methods to inform of changes.\\n  if (cellCount !== nextCellsCount || (typeof cellSize === 'number' || typeof nextCellSize === 'number') && cellSize !== nextCellSize) {\\n    computeMetadataCallback(computeMetadataCallbackProps);\\n\\n    // Updated cell metadata may have hidden the previous scrolled-to item.\\n    // In this case we should also update the scrollTop to ensure it stays visible.\\n    if (scrollToIndex >= 0 && scrollToIndex === nextScrollToIndex) {\\n      updateScrollOffsetForScrollToIndex();\\n    }\\n  }\\n}\\n\\n/**\\n * Helper method that determines when to recalculate row or column metadata.\\n */\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"process\",\"require\",\"module\",\"exports\",\"shadow$shims\",\"Object\",\"defineProperty\",\"value\",\"default\",\"calculateSizeAndPositionDataAndUpdateScrollOffset\",\"_ref\",\"cellSize\",\"computeMetadataCallback\",\"computeMetadataCallbackProps\",\"nextCellSize\",\"nextScrollToIndex\",\"scrollToIndex\",\"updateScrollOffsetForScrollToIndex\",\"cellCount\",\"nextCellsCount\"]\n}\n"]