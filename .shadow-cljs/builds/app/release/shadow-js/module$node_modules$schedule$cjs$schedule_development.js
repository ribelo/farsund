["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/schedule/cjs/schedule.development.js"],"~:js","shadow$provide.module$node_modules$schedule$cjs$schedule_development=function(b,e,a,f,c,m){}","~:source","shadow$provide[\"module$node_modules$schedule$cjs$schedule_development\"] = function(global,process,require,module,exports,shadow$shims) {\n/** @license React v16.5.2\n * schedule.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\n\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function() {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n/* eslint-disable no-var */\n\n// TODO: Currently there's only a single priority level, Deferred. Will add\n// additional priorities.\nvar DEFERRED_TIMEOUT = 5000;\n\n// Callbacks are stored as a circular, doubly linked list.\nvar firstCallbackNode = null;\n\nvar isPerformingWork = false;\n\nvar isHostCallbackScheduled = false;\n\nvar hasNativePerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';\n\nvar timeRemaining;\nif (hasNativePerformanceNow) {\n  timeRemaining = function () {\n    // We assume that if we have a performance timer that the rAF callback\n    // gets a performance timer value. Not sure if this is always true.\n    var remaining = getFrameDeadline() - performance.now();\n    return remaining > 0 ? remaining : 0;\n  };\n} else {\n  timeRemaining = function () {\n    // Fallback to Date.now()\n    var remaining = getFrameDeadline() - Date.now();\n    return remaining > 0 ? remaining : 0;\n  };\n}\n\nvar deadlineObject = {\n  timeRemaining: timeRemaining,\n  didTimeout: false\n};\n\nfunction ensureHostCallbackIsScheduled() {\n  if (isPerformingWork) {\n    // Don't schedule work yet; wait until the next time we yield.\n    return;\n  }\n  // Schedule the host callback using the earliest timeout in the list.\n  var timesOutAt = firstCallbackNode.timesOutAt;\n  if (!isHostCallbackScheduled) {\n    isHostCallbackScheduled = true;\n  } else {\n    // Cancel the existing host callback.\n    cancelCallback();\n  }\n  requestCallback(flushWork, timesOutAt);\n}\n\nfunction flushFirstCallback(node) {\n  var flushedNode = firstCallbackNode;\n\n  // Remove the node from the list before calling the callback. That way the\n  // list is in a consistent state even if the callback throws.\n  var next = firstCallbackNode.next;\n  if (firstCallbackNode === next) {\n    // This is the last callback in the list.\n    firstCallbackNode = null;\n    next = null;\n  } else {\n    var previous = firstCallbackNode.previous;\n    firstCallbackNode = previous.next = next;\n    next.previous = previous;\n  }\n\n  flushedNode.next = flushedNode.previous = null;\n\n  // Now it's safe to call the callback.\n  var callback = flushedNode.callback;\n  callback(deadlineObject);\n}\n\nfunction flushWork(didTimeout) {\n  isPerformingWork = true;\n  deadlineObject.didTimeout = didTimeout;\n  try {\n    if (didTimeout) {\n      // Flush all the timed out callbacks without yielding.\n      while (firstCallbackNode !== null) {\n        // Read the current time. Flush all the callbacks that expire at or\n        // earlier than that time. Then read the current time again and repeat.\n        // This optimizes for as few performance.now calls as possible.\n        var currentTime = exports.unstable_now();\n        if (firstCallbackNode.timesOutAt <= currentTime) {\n          do {\n            flushFirstCallback();\n          } while (firstCallbackNode !== null && firstCallbackNode.timesOutAt <= currentTime);\n          continue;\n        }\n        break;\n      }\n    } else {\n      // Keep flushing callbacks until we run out of time in the frame.\n      if (firstCallbackNode !== null) {\n        do {\n          flushFirstCallback();\n        } while (firstCallbackNode !== null && getFrameDeadline() - exports.unstable_now() > 0);\n      }\n    }\n  } finally {\n    isPerformingWork = false;\n    if (firstCallbackNode !== null) {\n      // There's still work remaining. Request another callback.\n      ensureHostCallbackIsScheduled(firstCallbackNode);\n    } else {\n      isHostCallbackScheduled = false;\n    }\n  }\n}\n\nfunction unstable_scheduleWork(callback, options) {\n  var currentTime = exports.unstable_now();\n\n  var timesOutAt;\n  if (options !== undefined && options !== null && options.timeout !== null && options.timeout !== undefined) {\n    // Check for an explicit timeout\n    timesOutAt = currentTime + options.timeout;\n  } else {\n    // Compute an absolute timeout using the default constant.\n    timesOutAt = currentTime + DEFERRED_TIMEOUT;\n  }\n\n  var newNode = {\n    callback: callback,\n    timesOutAt: timesOutAt,\n    next: null,\n    previous: null\n  };\n\n  // Insert the new callback into the list, sorted by its timeout.\n  if (firstCallbackNode === null) {\n    // This is the first callback in the list.\n    firstCallbackNode = newNode.next = newNode.previous = newNode;\n    ensureHostCallbackIsScheduled(firstCallbackNode);\n  } else {\n    var next = null;\n    var node = firstCallbackNode;\n    do {\n      if (node.timesOutAt > timesOutAt) {\n        // The new callback times out before this one.\n        next = node;\n        break;\n      }\n      node = node.next;\n    } while (node !== firstCallbackNode);\n\n    if (next === null) {\n      // No callback with a later timeout was found, which means the new\n      // callback has the latest timeout in the list.\n      next = firstCallbackNode;\n    } else if (next === firstCallbackNode) {\n      // The new callback has the earliest timeout in the entire list.\n      firstCallbackNode = newNode;\n      ensureHostCallbackIsScheduled(firstCallbackNode);\n    }\n\n    var previous = next.previous;\n    previous.next = next.previous = newNode;\n    newNode.next = next;\n    newNode.previous = previous;\n  }\n\n  return newNode;\n}\n\nfunction unstable_cancelScheduledWork(callbackNode) {\n  var next = callbackNode.next;\n  if (next === null) {\n    // Already cancelled.\n    return;\n  }\n\n  if (next === callbackNode) {\n    // This is the only scheduled callback. Clear the list.\n    firstCallbackNode = null;\n  } else {\n    // Remove the callback from its position in the list.\n    if (callbackNode === firstCallbackNode) {\n      firstCallbackNode = next;\n    }\n    var previous = callbackNode.previous;\n    previous.next = next;\n    next.previous = previous;\n  }\n\n  callbackNode.next = callbackNode.previous = null;\n}\n\n// The remaining code is essentially a polyfill for requestIdleCallback. It\n// works by scheduling a requestAnimationFrame, storing the time for the start\n// of the frame, then scheduling a postMessage which gets scheduled after paint.\n// Within the postMessage handler do as much work as possible until time + frame\n// rate. By separating the idle call into a separate event tick we ensure that\n// layout, paint and other browser work is counted against the available time.\n// The frame rate is dynamically adjusted.\n\n// We capture a local reference to any global, in case it gets polyfilled after\n// this module is initially evaluated. We want to be using a\n// consistent implementation.\nvar localDate = Date;\n\n// This initialization code may run even on server environments if a component\n// just imports ReactDOM (e.g. for findDOMNode). Some environments might not\n// have setTimeout or clearTimeout. However, we always expect them to be defined\n// on the client. https://github.com/facebook/react/pull/13088\nvar localSetTimeout = typeof setTimeout === 'function' ? setTimeout : undefined;\nvar localClearTimeout = typeof clearTimeout === 'function' ? clearTimeout : undefined;\n\n// We don't expect either of these to necessarily be defined, but we will error\n// later if they are missing on the client.\nvar localRequestAnimationFrame = typeof requestAnimationFrame === 'function' ? requestAnimationFrame : undefined;\nvar localCancelAnimationFrame = typeof cancelAnimationFrame === 'function' ? cancelAnimationFrame : undefined;\n\n// requestAnimationFrame does not run when the tab is in the background. If\n// we're backgrounded we prefer for that work to happen so that the page\n// continues to load in the background. So we also schedule a 'setTimeout' as\n// a fallback.\n// TODO: Need a better heuristic for backgrounded work.\nvar ANIMATION_FRAME_TIMEOUT = 100;\nvar rAFID;\nvar rAFTimeoutID;\nvar requestAnimationFrameWithTimeout = function (callback) {\n  // schedule rAF and also a setTimeout\n  rAFID = localRequestAnimationFrame(function (timestamp) {\n    // cancel the setTimeout\n    localClearTimeout(rAFTimeoutID);\n    callback(timestamp);\n  });\n  rAFTimeoutID = localSetTimeout(function () {\n    // cancel the requestAnimationFrame\n    localCancelAnimationFrame(rAFID);\n    callback(exports.unstable_now());\n  }, ANIMATION_FRAME_TIMEOUT);\n};\n\nif (hasNativePerformanceNow) {\n  var Performance = performance;\n  exports.unstable_now = function () {\n    return Performance.now();\n  };\n} else {\n  exports.unstable_now = function () {\n    return localDate.now();\n  };\n}\n\nvar requestCallback;\nvar cancelCallback;\nvar getFrameDeadline;\n\nif (typeof window === 'undefined') {\n  // If this accidentally gets imported in a non-browser environment, fallback\n  // to a naive implementation.\n  var timeoutID = -1;\n  requestCallback = function (callback, absoluteTimeout) {\n    timeoutID = setTimeout(callback, 0, true);\n  };\n  cancelCallback = function () {\n    clearTimeout(timeoutID);\n  };\n  getFrameDeadline = function () {\n    return 0;\n  };\n} else if (window._schedMock) {\n  // Dynamic injection, only for testing purposes.\n  var impl = window._schedMock;\n  requestCallback = impl[0];\n  cancelCallback = impl[1];\n  getFrameDeadline = impl[2];\n} else {\n  if (typeof console !== 'undefined') {\n    if (typeof localRequestAnimationFrame !== 'function') {\n      console.error(\"This browser doesn't support requestAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\n    }\n    if (typeof localCancelAnimationFrame !== 'function') {\n      console.error(\"This browser doesn't support cancelAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\n    }\n  }\n\n  var scheduledCallback = null;\n  var isIdleScheduled = false;\n  var timeoutTime = -1;\n\n  var isAnimationFrameScheduled = false;\n\n  var isPerformingIdleWork = false;\n\n  var frameDeadline = 0;\n  // We start out assuming that we run at 30fps but then the heuristic tracking\n  // will adjust this value to a faster fps if we get more frequent animation\n  // frames.\n  var previousFrameTime = 33;\n  var activeFrameTime = 33;\n\n  getFrameDeadline = function () {\n    return frameDeadline;\n  };\n\n  // We use the postMessage trick to defer idle work until after the repaint.\n  var messageKey = '__reactIdleCallback$' + Math.random().toString(36).slice(2);\n  var idleTick = function (event) {\n    if (event.source !== window || event.data !== messageKey) {\n      return;\n    }\n\n    isIdleScheduled = false;\n\n    var currentTime = exports.unstable_now();\n\n    var didTimeout = false;\n    if (frameDeadline - currentTime <= 0) {\n      // There's no time left in this idle period. Check if the callback has\n      // a timeout and whether it's been exceeded.\n      if (timeoutTime !== -1 && timeoutTime <= currentTime) {\n        // Exceeded the timeout. Invoke the callback even though there's no\n        // time left.\n        didTimeout = true;\n      } else {\n        // No timeout.\n        if (!isAnimationFrameScheduled) {\n          // Schedule another animation callback so we retry later.\n          isAnimationFrameScheduled = true;\n          requestAnimationFrameWithTimeout(animationTick);\n        }\n        // Exit without invoking the callback.\n        return;\n      }\n    }\n\n    timeoutTime = -1;\n    var callback = scheduledCallback;\n    scheduledCallback = null;\n    if (callback !== null) {\n      isPerformingIdleWork = true;\n      try {\n        callback(didTimeout);\n      } finally {\n        isPerformingIdleWork = false;\n      }\n    }\n  };\n  // Assumes that we have addEventListener in this environment. Might need\n  // something better for old IE.\n  window.addEventListener('message', idleTick, false);\n\n  var animationTick = function (rafTime) {\n    isAnimationFrameScheduled = false;\n    var nextFrameTime = rafTime - frameDeadline + activeFrameTime;\n    if (nextFrameTime < activeFrameTime && previousFrameTime < activeFrameTime) {\n      if (nextFrameTime < 8) {\n        // Defensive coding. We don't support higher frame rates than 120hz.\n        // If we get lower than that, it is probably a bug.\n        nextFrameTime = 8;\n      }\n      // If one frame goes long, then the next one can be short to catch up.\n      // If two frames are short in a row, then that's an indication that we\n      // actually have a higher frame rate than what we're currently optimizing.\n      // We adjust our heuristic dynamically accordingly. For example, if we're\n      // running on 120hz display or 90hz VR display.\n      // Take the max of the two in case one of them was an anomaly due to\n      // missed frame deadlines.\n      activeFrameTime = nextFrameTime < previousFrameTime ? previousFrameTime : nextFrameTime;\n    } else {\n      previousFrameTime = nextFrameTime;\n    }\n    frameDeadline = rafTime + activeFrameTime;\n    if (!isIdleScheduled) {\n      isIdleScheduled = true;\n      window.postMessage(messageKey, '*');\n    }\n  };\n\n  requestCallback = function (callback, absoluteTimeout) {\n    scheduledCallback = callback;\n    timeoutTime = absoluteTimeout;\n    if (isPerformingIdleWork) {\n      // If we're already performing idle work, an error must have been thrown.\n      // Don't wait for the next frame. Continue working ASAP, in a new event.\n      window.postMessage(messageKey, '*');\n    } else if (!isAnimationFrameScheduled) {\n      // If rAF didn't already schedule one, we need to schedule a frame.\n      // TODO: If this rAF doesn't materialize because the browser throttles, we\n      // might want to still have setTimeout trigger rIC as a backup to ensure\n      // that we keep performing work.\n      isAnimationFrameScheduled = true;\n      requestAnimationFrameWithTimeout(animationTick);\n    }\n  };\n\n  cancelCallback = function () {\n    scheduledCallback = null;\n    isIdleScheduled = false;\n    timeoutTime = -1;\n  };\n}\n\nexports.unstable_scheduleWork = unstable_scheduleWork;\nexports.unstable_cancelScheduledWork = unstable_cancelScheduledWork;\n  })();\n}\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",[]],"~:compiled-at",1537815742921,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$schedule$cjs$schedule_development.js\",\n\"lineCount\":1,\n\"mappings\":\"AAAAA,cAAA,sDAAA,CAA0E,QAAQ,CAACC,CAAD,CAAQC,CAAR,CAAgBC,CAAhB,CAAwBC,CAAxB,CAA+BC,CAA/B,CAAuCC,CAAvC,CAAqD;\",\n\"sources\":[\"node_modules/schedule/cjs/schedule.development.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$schedule$cjs$schedule_development\\\"] = function(global,process,require,module,exports,shadow$shims) {\\n/** @license React v16.5.2\\n * schedule.development.js\\n *\\n * Copyright (c) Facebook, Inc. and its affiliates.\\n *\\n * This source code is licensed under the MIT license found in the\\n * LICENSE file in the root directory of this source tree.\\n */\\n\\n'use strict';\\n\\n\\n\\nif (process.env.NODE_ENV !== \\\"production\\\") {\\n  (function() {\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', { value: true });\\n\\n/* eslint-disable no-var */\\n\\n// TODO: Currently there's only a single priority level, Deferred. Will add\\n// additional priorities.\\nvar DEFERRED_TIMEOUT = 5000;\\n\\n// Callbacks are stored as a circular, doubly linked list.\\nvar firstCallbackNode = null;\\n\\nvar isPerformingWork = false;\\n\\nvar isHostCallbackScheduled = false;\\n\\nvar hasNativePerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';\\n\\nvar timeRemaining;\\nif (hasNativePerformanceNow) {\\n  timeRemaining = function () {\\n    // We assume that if we have a performance timer that the rAF callback\\n    // gets a performance timer value. Not sure if this is always true.\\n    var remaining = getFrameDeadline() - performance.now();\\n    return remaining > 0 ? remaining : 0;\\n  };\\n} else {\\n  timeRemaining = function () {\\n    // Fallback to Date.now()\\n    var remaining = getFrameDeadline() - Date.now();\\n    return remaining > 0 ? remaining : 0;\\n  };\\n}\\n\\nvar deadlineObject = {\\n  timeRemaining: timeRemaining,\\n  didTimeout: false\\n};\\n\\nfunction ensureHostCallbackIsScheduled() {\\n  if (isPerformingWork) {\\n    // Don't schedule work yet; wait until the next time we yield.\\n    return;\\n  }\\n  // Schedule the host callback using the earliest timeout in the list.\\n  var timesOutAt = firstCallbackNode.timesOutAt;\\n  if (!isHostCallbackScheduled) {\\n    isHostCallbackScheduled = true;\\n  } else {\\n    // Cancel the existing host callback.\\n    cancelCallback();\\n  }\\n  requestCallback(flushWork, timesOutAt);\\n}\\n\\nfunction flushFirstCallback(node) {\\n  var flushedNode = firstCallbackNode;\\n\\n  // Remove the node from the list before calling the callback. That way the\\n  // list is in a consistent state even if the callback throws.\\n  var next = firstCallbackNode.next;\\n  if (firstCallbackNode === next) {\\n    // This is the last callback in the list.\\n    firstCallbackNode = null;\\n    next = null;\\n  } else {\\n    var previous = firstCallbackNode.previous;\\n    firstCallbackNode = previous.next = next;\\n    next.previous = previous;\\n  }\\n\\n  flushedNode.next = flushedNode.previous = null;\\n\\n  // Now it's safe to call the callback.\\n  var callback = flushedNode.callback;\\n  callback(deadlineObject);\\n}\\n\\nfunction flushWork(didTimeout) {\\n  isPerformingWork = true;\\n  deadlineObject.didTimeout = didTimeout;\\n  try {\\n    if (didTimeout) {\\n      // Flush all the timed out callbacks without yielding.\\n      while (firstCallbackNode !== null) {\\n        // Read the current time. Flush all the callbacks that expire at or\\n        // earlier than that time. Then read the current time again and repeat.\\n        // This optimizes for as few performance.now calls as possible.\\n        var currentTime = exports.unstable_now();\\n        if (firstCallbackNode.timesOutAt <= currentTime) {\\n          do {\\n            flushFirstCallback();\\n          } while (firstCallbackNode !== null && firstCallbackNode.timesOutAt <= currentTime);\\n          continue;\\n        }\\n        break;\\n      }\\n    } else {\\n      // Keep flushing callbacks until we run out of time in the frame.\\n      if (firstCallbackNode !== null) {\\n        do {\\n          flushFirstCallback();\\n        } while (firstCallbackNode !== null && getFrameDeadline() - exports.unstable_now() > 0);\\n      }\\n    }\\n  } finally {\\n    isPerformingWork = false;\\n    if (firstCallbackNode !== null) {\\n      // There's still work remaining. Request another callback.\\n      ensureHostCallbackIsScheduled(firstCallbackNode);\\n    } else {\\n      isHostCallbackScheduled = false;\\n    }\\n  }\\n}\\n\\nfunction unstable_scheduleWork(callback, options) {\\n  var currentTime = exports.unstable_now();\\n\\n  var timesOutAt;\\n  if (options !== undefined && options !== null && options.timeout !== null && options.timeout !== undefined) {\\n    // Check for an explicit timeout\\n    timesOutAt = currentTime + options.timeout;\\n  } else {\\n    // Compute an absolute timeout using the default constant.\\n    timesOutAt = currentTime + DEFERRED_TIMEOUT;\\n  }\\n\\n  var newNode = {\\n    callback: callback,\\n    timesOutAt: timesOutAt,\\n    next: null,\\n    previous: null\\n  };\\n\\n  // Insert the new callback into the list, sorted by its timeout.\\n  if (firstCallbackNode === null) {\\n    // This is the first callback in the list.\\n    firstCallbackNode = newNode.next = newNode.previous = newNode;\\n    ensureHostCallbackIsScheduled(firstCallbackNode);\\n  } else {\\n    var next = null;\\n    var node = firstCallbackNode;\\n    do {\\n      if (node.timesOutAt > timesOutAt) {\\n        // The new callback times out before this one.\\n        next = node;\\n        break;\\n      }\\n      node = node.next;\\n    } while (node !== firstCallbackNode);\\n\\n    if (next === null) {\\n      // No callback with a later timeout was found, which means the new\\n      // callback has the latest timeout in the list.\\n      next = firstCallbackNode;\\n    } else if (next === firstCallbackNode) {\\n      // The new callback has the earliest timeout in the entire list.\\n      firstCallbackNode = newNode;\\n      ensureHostCallbackIsScheduled(firstCallbackNode);\\n    }\\n\\n    var previous = next.previous;\\n    previous.next = next.previous = newNode;\\n    newNode.next = next;\\n    newNode.previous = previous;\\n  }\\n\\n  return newNode;\\n}\\n\\nfunction unstable_cancelScheduledWork(callbackNode) {\\n  var next = callbackNode.next;\\n  if (next === null) {\\n    // Already cancelled.\\n    return;\\n  }\\n\\n  if (next === callbackNode) {\\n    // This is the only scheduled callback. Clear the list.\\n    firstCallbackNode = null;\\n  } else {\\n    // Remove the callback from its position in the list.\\n    if (callbackNode === firstCallbackNode) {\\n      firstCallbackNode = next;\\n    }\\n    var previous = callbackNode.previous;\\n    previous.next = next;\\n    next.previous = previous;\\n  }\\n\\n  callbackNode.next = callbackNode.previous = null;\\n}\\n\\n// The remaining code is essentially a polyfill for requestIdleCallback. It\\n// works by scheduling a requestAnimationFrame, storing the time for the start\\n// of the frame, then scheduling a postMessage which gets scheduled after paint.\\n// Within the postMessage handler do as much work as possible until time + frame\\n// rate. By separating the idle call into a separate event tick we ensure that\\n// layout, paint and other browser work is counted against the available time.\\n// The frame rate is dynamically adjusted.\\n\\n// We capture a local reference to any global, in case it gets polyfilled after\\n// this module is initially evaluated. We want to be using a\\n// consistent implementation.\\nvar localDate = Date;\\n\\n// This initialization code may run even on server environments if a component\\n// just imports ReactDOM (e.g. for findDOMNode). Some environments might not\\n// have setTimeout or clearTimeout. However, we always expect them to be defined\\n// on the client. https://github.com/facebook/react/pull/13088\\nvar localSetTimeout = typeof setTimeout === 'function' ? setTimeout : undefined;\\nvar localClearTimeout = typeof clearTimeout === 'function' ? clearTimeout : undefined;\\n\\n// We don't expect either of these to necessarily be defined, but we will error\\n// later if they are missing on the client.\\nvar localRequestAnimationFrame = typeof requestAnimationFrame === 'function' ? requestAnimationFrame : undefined;\\nvar localCancelAnimationFrame = typeof cancelAnimationFrame === 'function' ? cancelAnimationFrame : undefined;\\n\\n// requestAnimationFrame does not run when the tab is in the background. If\\n// we're backgrounded we prefer for that work to happen so that the page\\n// continues to load in the background. So we also schedule a 'setTimeout' as\\n// a fallback.\\n// TODO: Need a better heuristic for backgrounded work.\\nvar ANIMATION_FRAME_TIMEOUT = 100;\\nvar rAFID;\\nvar rAFTimeoutID;\\nvar requestAnimationFrameWithTimeout = function (callback) {\\n  // schedule rAF and also a setTimeout\\n  rAFID = localRequestAnimationFrame(function (timestamp) {\\n    // cancel the setTimeout\\n    localClearTimeout(rAFTimeoutID);\\n    callback(timestamp);\\n  });\\n  rAFTimeoutID = localSetTimeout(function () {\\n    // cancel the requestAnimationFrame\\n    localCancelAnimationFrame(rAFID);\\n    callback(exports.unstable_now());\\n  }, ANIMATION_FRAME_TIMEOUT);\\n};\\n\\nif (hasNativePerformanceNow) {\\n  var Performance = performance;\\n  exports.unstable_now = function () {\\n    return Performance.now();\\n  };\\n} else {\\n  exports.unstable_now = function () {\\n    return localDate.now();\\n  };\\n}\\n\\nvar requestCallback;\\nvar cancelCallback;\\nvar getFrameDeadline;\\n\\nif (typeof window === 'undefined') {\\n  // If this accidentally gets imported in a non-browser environment, fallback\\n  // to a naive implementation.\\n  var timeoutID = -1;\\n  requestCallback = function (callback, absoluteTimeout) {\\n    timeoutID = setTimeout(callback, 0, true);\\n  };\\n  cancelCallback = function () {\\n    clearTimeout(timeoutID);\\n  };\\n  getFrameDeadline = function () {\\n    return 0;\\n  };\\n} else if (window._schedMock) {\\n  // Dynamic injection, only for testing purposes.\\n  var impl = window._schedMock;\\n  requestCallback = impl[0];\\n  cancelCallback = impl[1];\\n  getFrameDeadline = impl[2];\\n} else {\\n  if (typeof console !== 'undefined') {\\n    if (typeof localRequestAnimationFrame !== 'function') {\\n      console.error(\\\"This browser doesn't support requestAnimationFrame. \\\" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\\n    }\\n    if (typeof localCancelAnimationFrame !== 'function') {\\n      console.error(\\\"This browser doesn't support cancelAnimationFrame. \\\" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\\n    }\\n  }\\n\\n  var scheduledCallback = null;\\n  var isIdleScheduled = false;\\n  var timeoutTime = -1;\\n\\n  var isAnimationFrameScheduled = false;\\n\\n  var isPerformingIdleWork = false;\\n\\n  var frameDeadline = 0;\\n  // We start out assuming that we run at 30fps but then the heuristic tracking\\n  // will adjust this value to a faster fps if we get more frequent animation\\n  // frames.\\n  var previousFrameTime = 33;\\n  var activeFrameTime = 33;\\n\\n  getFrameDeadline = function () {\\n    return frameDeadline;\\n  };\\n\\n  // We use the postMessage trick to defer idle work until after the repaint.\\n  var messageKey = '__reactIdleCallback$' + Math.random().toString(36).slice(2);\\n  var idleTick = function (event) {\\n    if (event.source !== window || event.data !== messageKey) {\\n      return;\\n    }\\n\\n    isIdleScheduled = false;\\n\\n    var currentTime = exports.unstable_now();\\n\\n    var didTimeout = false;\\n    if (frameDeadline - currentTime <= 0) {\\n      // There's no time left in this idle period. Check if the callback has\\n      // a timeout and whether it's been exceeded.\\n      if (timeoutTime !== -1 && timeoutTime <= currentTime) {\\n        // Exceeded the timeout. Invoke the callback even though there's no\\n        // time left.\\n        didTimeout = true;\\n      } else {\\n        // No timeout.\\n        if (!isAnimationFrameScheduled) {\\n          // Schedule another animation callback so we retry later.\\n          isAnimationFrameScheduled = true;\\n          requestAnimationFrameWithTimeout(animationTick);\\n        }\\n        // Exit without invoking the callback.\\n        return;\\n      }\\n    }\\n\\n    timeoutTime = -1;\\n    var callback = scheduledCallback;\\n    scheduledCallback = null;\\n    if (callback !== null) {\\n      isPerformingIdleWork = true;\\n      try {\\n        callback(didTimeout);\\n      } finally {\\n        isPerformingIdleWork = false;\\n      }\\n    }\\n  };\\n  // Assumes that we have addEventListener in this environment. Might need\\n  // something better for old IE.\\n  window.addEventListener('message', idleTick, false);\\n\\n  var animationTick = function (rafTime) {\\n    isAnimationFrameScheduled = false;\\n    var nextFrameTime = rafTime - frameDeadline + activeFrameTime;\\n    if (nextFrameTime < activeFrameTime && previousFrameTime < activeFrameTime) {\\n      if (nextFrameTime < 8) {\\n        // Defensive coding. We don't support higher frame rates than 120hz.\\n        // If we get lower than that, it is probably a bug.\\n        nextFrameTime = 8;\\n      }\\n      // If one frame goes long, then the next one can be short to catch up.\\n      // If two frames are short in a row, then that's an indication that we\\n      // actually have a higher frame rate than what we're currently optimizing.\\n      // We adjust our heuristic dynamically accordingly. For example, if we're\\n      // running on 120hz display or 90hz VR display.\\n      // Take the max of the two in case one of them was an anomaly due to\\n      // missed frame deadlines.\\n      activeFrameTime = nextFrameTime < previousFrameTime ? previousFrameTime : nextFrameTime;\\n    } else {\\n      previousFrameTime = nextFrameTime;\\n    }\\n    frameDeadline = rafTime + activeFrameTime;\\n    if (!isIdleScheduled) {\\n      isIdleScheduled = true;\\n      window.postMessage(messageKey, '*');\\n    }\\n  };\\n\\n  requestCallback = function (callback, absoluteTimeout) {\\n    scheduledCallback = callback;\\n    timeoutTime = absoluteTimeout;\\n    if (isPerformingIdleWork) {\\n      // If we're already performing idle work, an error must have been thrown.\\n      // Don't wait for the next frame. Continue working ASAP, in a new event.\\n      window.postMessage(messageKey, '*');\\n    } else if (!isAnimationFrameScheduled) {\\n      // If rAF didn't already schedule one, we need to schedule a frame.\\n      // TODO: If this rAF doesn't materialize because the browser throttles, we\\n      // might want to still have setTimeout trigger rIC as a backup to ensure\\n      // that we keep performing work.\\n      isAnimationFrameScheduled = true;\\n      requestAnimationFrameWithTimeout(animationTick);\\n    }\\n  };\\n\\n  cancelCallback = function () {\\n    scheduledCallback = null;\\n    isIdleScheduled = false;\\n    timeoutTime = -1;\\n  };\\n}\\n\\nexports.unstable_scheduleWork = unstable_scheduleWork;\\nexports.unstable_cancelScheduledWork = unstable_cancelScheduledWork;\\n  })();\\n}\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"process\",\"require\",\"module\",\"exports\",\"shadow$shims\"]\n}\n"]