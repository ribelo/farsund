["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/react-virtualized/dist/commonjs/Grid/utils/updateScrollIndexHelper.js"],"~:js","shadow$provide.module$node_modules$react_virtualized$dist$commonjs$Grid$utils$updateScrollIndexHelper=function(b,e,a,f,c,m){Object.defineProperty(c,\"__esModule\",{value:!0});c.default=function(a){var b=a.cellSize,c=a.cellSizeAndPositionManager,d=a.previousCellsCount,e=a.previousCellSize,f=a.previousScrollToAlignment,m=a.previousScrollToIndex,g=a.previousSize,n=a.scrollOffset,v=a.scrollToAlignment,y=a.scrollToIndex,w=a.size,x=a.sizeJustIncreasedFromZero;a=a.updateScrollIndexCallback;var u=c.getCellCount(),\nt=0<=y&&y<u;t&&(w!==g||x||!e||\"number\"===typeof b&&b!==e||v!==f||y!==m)?a(y):!t&&0<u&&(w<g||u<d)&&n>c.getTotalSize()-w&&a(u-1)};a(\"module$node_modules$react_virtualized$dist$commonjs$Grid$utils$ScalingCellSizeAndPositionManager\");a(\"module$node_modules$react_virtualized$dist$commonjs$Grid$types\")}","~:source","shadow$provide[\"module$node_modules$react_virtualized$dist$commonjs$Grid$utils$updateScrollIndexHelper\"] = function(global,process,require,module,exports,shadow$shims) {\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = updateScrollIndexHelper;\n\nvar _ScalingCellSizeAndPositionManager = require('./ScalingCellSizeAndPositionManager.js');\n\nvar _ScalingCellSizeAndPositionManager2 = _interopRequireDefault(_ScalingCellSizeAndPositionManager);\n\nvar _types = require('../types');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Helper function that determines when to update scroll offsets to ensure that a scroll-to-index remains visible.\n * This function also ensures that the scroll ofset isn't past the last column/row of cells.\n */\n\nfunction updateScrollIndexHelper(_ref) {\n  var cellSize = _ref.cellSize,\n      cellSizeAndPositionManager = _ref.cellSizeAndPositionManager,\n      previousCellsCount = _ref.previousCellsCount,\n      previousCellSize = _ref.previousCellSize,\n      previousScrollToAlignment = _ref.previousScrollToAlignment,\n      previousScrollToIndex = _ref.previousScrollToIndex,\n      previousSize = _ref.previousSize,\n      scrollOffset = _ref.scrollOffset,\n      scrollToAlignment = _ref.scrollToAlignment,\n      scrollToIndex = _ref.scrollToIndex,\n      size = _ref.size,\n      sizeJustIncreasedFromZero = _ref.sizeJustIncreasedFromZero,\n      updateScrollIndexCallback = _ref.updateScrollIndexCallback;\n\n  var cellCount = cellSizeAndPositionManager.getCellCount();\n  var hasScrollToIndex = scrollToIndex >= 0 && scrollToIndex < cellCount;\n  var sizeHasChanged = size !== previousSize || sizeJustIncreasedFromZero || !previousCellSize || typeof cellSize === 'number' && cellSize !== previousCellSize;\n\n  // If we have a new scroll target OR if height/row-height has changed,\n  // We should ensure that the scroll target is visible.\n  if (hasScrollToIndex && (sizeHasChanged || scrollToAlignment !== previousScrollToAlignment || scrollToIndex !== previousScrollToIndex)) {\n    updateScrollIndexCallback(scrollToIndex);\n\n    // If we don't have a selected item but list size or number of children have decreased,\n    // Make sure we aren't scrolled too far past the current content.\n  } else if (!hasScrollToIndex && cellCount > 0 && (size < previousSize || cellCount < previousCellsCount)) {\n    // We need to ensure that the current scroll offset is still within the collection's range.\n    // To do this, we don't need to measure everything; CellMeasurer would perform poorly.\n    // Just check to make sure we're still okay.\n    // Only adjust the scroll position if we've scrolled below the last set of rows.\n    if (scrollOffset > cellSizeAndPositionManager.getTotalSize() - size) {\n      updateScrollIndexCallback(cellCount - 1);\n    }\n  }\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$react_virtualized$dist$commonjs$Grid$types","~$shadow.js","~$module$node_modules$react_virtualized$dist$commonjs$Grid$utils$ScalingCellSizeAndPositionManager"]],"~:properties",["^5",["__esModule","value","default"]],"~:compiled-at",1537815743250,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$react_virtualized$dist$commonjs$Grid$utils$updateScrollIndexHelper.js\",\n\"lineCount\":2,\n\"mappings\":\"AAAAA,cAAA,uFAAA,CAA2G,QAAQ,CAACC,CAAD,CAAQC,CAAR,CAAgBC,CAAhB,CAAwBC,CAAxB,CAA+BC,CAA/B,CAAuCC,CAAvC,CAAqD,CAGxKC,MAAAC,eAAA,CAAsBH,CAAtB,CAA+B,YAA/B,CAA6C,CAC3CI,MAAO,CAAA,CADoC,CAA7C,CAGAJ,EAAAK,QAAA,CAeAC,QAAgC,CAACC,CAAD,CAAO,CAAA,IACjCC,EAAWD,CAAAC,SADsB,CAEjCC,EAA6BF,CAAAE,2BAFI,CAGjCC,EAAqBH,CAAAG,mBAHY,CAIjCC,EAAmBJ,CAAAI,iBAJc,CAKjCC,EAA4BL,CAAAK,0BALK,CAMjCC,EAAwBN,CAAAM,sBANS,CAOjCC,EAAeP,CAAAO,aAPkB,CAQjCC,EAAeR,CAAAQ,aARkB,CASjCC,EAAoBT,CAAAS,kBATa,CAUjCC,EAAgBV,CAAAU,cAViB,CAWjCC,EAAOX,CAAAW,KAX0B,CAYjCC,EAA4BZ,CAAAY,0BAC5BC,EAAAA,CAA4Bb,CAAAa,0BAEhC,KAAIC,EAAYZ,CAAAa,aAAA,EAAhB;AACIC,EAAoC,CAApCA,EAAmBN,CAAnBM,EAAyCN,CAAzCM,CAAyDF,CAKzDE,EAAJ,GAJqBL,CAIrB,GAJ8BJ,CAI9B,EAJ8CK,CAI9C,EAJ2E,CAACR,CAI5E,EAJoH,QAIpH,GAJgG,MAAOH,EAIvG,EAJgIA,CAIhI,GAJ6IG,CAI7I,EAA2CK,CAA3C,GAAiEJ,CAAjE,EAA8FK,CAA9F,GAAgHJ,CAAhH,EACEO,CAAA,CAA0BH,CAA1B,CADF,CAKW,CAACM,CALZ,EAK4C,CAL5C,CAKgCF,CALhC,GAKkDH,CALlD,CAKyDJ,CALzD,EAKyEO,CALzE,CAKqFX,CALrF,GAUMK,CAVN,CAUqBN,CAAAe,aAAA,EAVrB,CAUiEN,CAVjE,EAWIE,CAAA,CAA0BC,CAA1B,CAAsC,CAAtC,CAhCiC,CAbEvB,EAAA,CAAQ,kGAAR,CAI5BA,EAAA,CAAQ,gEAAR,CAZ2J;\",\n\"sources\":[\"node_modules/react-virtualized/dist/commonjs/Grid/utils/updateScrollIndexHelper.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$react_virtualized$dist$commonjs$Grid$utils$updateScrollIndexHelper\\\"] = function(global,process,require,module,exports,shadow$shims) {\\n'use strict';\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.default = updateScrollIndexHelper;\\n\\nvar _ScalingCellSizeAndPositionManager = require('./ScalingCellSizeAndPositionManager.js');\\n\\nvar _ScalingCellSizeAndPositionManager2 = _interopRequireDefault(_ScalingCellSizeAndPositionManager);\\n\\nvar _types = require('../types');\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\\n\\n/**\\n * Helper function that determines when to update scroll offsets to ensure that a scroll-to-index remains visible.\\n * This function also ensures that the scroll ofset isn't past the last column/row of cells.\\n */\\n\\nfunction updateScrollIndexHelper(_ref) {\\n  var cellSize = _ref.cellSize,\\n      cellSizeAndPositionManager = _ref.cellSizeAndPositionManager,\\n      previousCellsCount = _ref.previousCellsCount,\\n      previousCellSize = _ref.previousCellSize,\\n      previousScrollToAlignment = _ref.previousScrollToAlignment,\\n      previousScrollToIndex = _ref.previousScrollToIndex,\\n      previousSize = _ref.previousSize,\\n      scrollOffset = _ref.scrollOffset,\\n      scrollToAlignment = _ref.scrollToAlignment,\\n      scrollToIndex = _ref.scrollToIndex,\\n      size = _ref.size,\\n      sizeJustIncreasedFromZero = _ref.sizeJustIncreasedFromZero,\\n      updateScrollIndexCallback = _ref.updateScrollIndexCallback;\\n\\n  var cellCount = cellSizeAndPositionManager.getCellCount();\\n  var hasScrollToIndex = scrollToIndex >= 0 && scrollToIndex < cellCount;\\n  var sizeHasChanged = size !== previousSize || sizeJustIncreasedFromZero || !previousCellSize || typeof cellSize === 'number' && cellSize !== previousCellSize;\\n\\n  // If we have a new scroll target OR if height/row-height has changed,\\n  // We should ensure that the scroll target is visible.\\n  if (hasScrollToIndex && (sizeHasChanged || scrollToAlignment !== previousScrollToAlignment || scrollToIndex !== previousScrollToIndex)) {\\n    updateScrollIndexCallback(scrollToIndex);\\n\\n    // If we don't have a selected item but list size or number of children have decreased,\\n    // Make sure we aren't scrolled too far past the current content.\\n  } else if (!hasScrollToIndex && cellCount > 0 && (size < previousSize || cellCount < previousCellsCount)) {\\n    // We need to ensure that the current scroll offset is still within the collection's range.\\n    // To do this, we don't need to measure everything; CellMeasurer would perform poorly.\\n    // Just check to make sure we're still okay.\\n    // Only adjust the scroll position if we've scrolled below the last set of rows.\\n    if (scrollOffset > cellSizeAndPositionManager.getTotalSize() - size) {\\n      updateScrollIndexCallback(cellCount - 1);\\n    }\\n  }\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"process\",\"require\",\"module\",\"exports\",\"shadow$shims\",\"Object\",\"defineProperty\",\"value\",\"default\",\"updateScrollIndexHelper\",\"_ref\",\"cellSize\",\"cellSizeAndPositionManager\",\"previousCellsCount\",\"previousCellSize\",\"previousScrollToAlignment\",\"previousScrollToIndex\",\"previousSize\",\"scrollOffset\",\"scrollToAlignment\",\"scrollToIndex\",\"size\",\"sizeJustIncreasedFromZero\",\"updateScrollIndexCallback\",\"cellCount\",\"getCellCount\",\"hasScrollToIndex\",\"getTotalSize\"]\n}\n"]