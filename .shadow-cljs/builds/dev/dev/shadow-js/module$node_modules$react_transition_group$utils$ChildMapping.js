["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/react-transition-group/utils/ChildMapping.js"],"~:js","shadow$provide.module$node_modules$react_transition_group$utils$ChildMapping=function(global,process,require,module,exports,shadow$shims){function getChildMapping(children,mapFn){var result=Object.create(null);children&&_react.Children.map(children,function(c){return c}).forEach(function(child){var JSCompiler_temp_const=child.key;child=mapFn&&(0,_react.isValidElement)(child)?mapFn(child):child;result[JSCompiler_temp_const]=child});return result}function mergeChildMappings(prev,next){function getValueForKey(key){return key in\nnext?next[key]:prev[key]}prev=prev||{};next=next||{};var nextKeysPending=Object.create(null),pendingKeys=[];for(prevKey in prev)prevKey in next?pendingKeys.length&&(nextKeysPending[prevKey]=pendingKeys,pendingKeys=[]):pendingKeys.push(prevKey);var prevKey=void 0;var childMapping={},nextKey;for(nextKey in next){if(nextKeysPending[nextKey])for(prevKey=0;prevKey<nextKeysPending[nextKey].length;prevKey++)childMapping[nextKeysPending[nextKey][prevKey]]=getValueForKey(nextKeysPending[nextKey][prevKey]);\nchildMapping[nextKey]=getValueForKey(nextKey)}for(prevKey=0;prevKey<pendingKeys.length;prevKey++)childMapping[pendingKeys[prevKey]]=getValueForKey(pendingKeys[prevKey]);return childMapping}function getProp(child,prop,props){return null!=props[prop]?props[prop]:child.props[prop]}exports.__esModule=!0;exports.getChildMapping=getChildMapping;exports.mergeChildMappings=mergeChildMappings;exports.getInitialChildMapping=function(props,onExited){return getChildMapping(props.children,function(child){return(0,\n_react.cloneElement)(child,{onExited:onExited.bind(null,child),in:!0,appear:getProp(child,\"appear\",props),enter:getProp(child,\"enter\",props),exit:getProp(child,\"exit\",props)})})};exports.getNextChildMapping=function(nextProps,prevChildMapping,onExited){var nextChildMapping=getChildMapping(nextProps.children),children=mergeChildMappings(prevChildMapping,nextChildMapping);Object.keys(children).forEach(function(key){var child=children[key];if((0,_react.isValidElement)(child)){var hasPrev=key in prevChildMapping,\nhasNext=key in nextChildMapping,prevChild=prevChildMapping[key],isLeaving=(0,_react.isValidElement)(prevChild)&&!prevChild.props.in;!hasNext||hasPrev&&!isLeaving?hasNext||!hasPrev||isLeaving?hasNext&&hasPrev&&(0,_react.isValidElement)(prevChild)&&(children[key]=(0,_react.cloneElement)(child,{onExited:onExited.bind(null,child),in:prevChild.props.in,exit:getProp(child,\"exit\",nextProps),enter:getProp(child,\"enter\",nextProps)})):children[key]=(0,_react.cloneElement)(child,{in:!1}):children[key]=(0,_react.cloneElement)(child,\n{onExited:onExited.bind(null,child),in:!0,exit:getProp(child,\"exit\",nextProps),enter:getProp(child,\"enter\",nextProps)})}});return children};var _react=require(\"module$node_modules$react$index\")}","~:source","shadow$provide[\"module$node_modules$react_transition_group$utils$ChildMapping\"] = function(global,process,require,module,exports,shadow$shims) {\n'use strict';\n\nexports.__esModule = true;\nexports.getChildMapping = getChildMapping;\nexports.mergeChildMappings = mergeChildMappings;\nexports.getInitialChildMapping = getInitialChildMapping;\nexports.getNextChildMapping = getNextChildMapping;\n\nvar _react = require('react');\n\n/**\n * Given `this.props.children`, return an object mapping key to child.\n *\n * @param {*} children `this.props.children`\n * @return {object} Mapping of key to child\n */\nfunction getChildMapping(children, mapFn) {\n  var mapper = function mapper(child) {\n    return mapFn && (0, _react.isValidElement)(child) ? mapFn(child) : child;\n  };\n\n  var result = Object.create(null);\n  if (children) _react.Children.map(children, function (c) {\n    return c;\n  }).forEach(function (child) {\n    // run the map function here instead so that the key is the computed one\n    result[child.key] = mapper(child);\n  });\n  return result;\n}\n\n/**\n * When you're adding or removing children some may be added or removed in the\n * same render pass. We want to show *both* since we want to simultaneously\n * animate elements in and out. This function takes a previous set of keys\n * and a new set of keys and merges them with its best guess of the correct\n * ordering. In the future we may expose some of the utilities in\n * ReactMultiChild to make this easy, but for now React itself does not\n * directly have this concept of the union of prevChildren and nextChildren\n * so we implement it here.\n *\n * @param {object} prev prev children as returned from\n * `ReactTransitionChildMapping.getChildMapping()`.\n * @param {object} next next children as returned from\n * `ReactTransitionChildMapping.getChildMapping()`.\n * @return {object} a key set that contains all keys in `prev` and all keys\n * in `next` in a reasonable order.\n */\nfunction mergeChildMappings(prev, next) {\n  prev = prev || {};\n  next = next || {};\n\n  function getValueForKey(key) {\n    return key in next ? next[key] : prev[key];\n  }\n\n  // For each key of `next`, the list of keys to insert before that key in\n  // the combined list\n  var nextKeysPending = Object.create(null);\n\n  var pendingKeys = [];\n  for (var prevKey in prev) {\n    if (prevKey in next) {\n      if (pendingKeys.length) {\n        nextKeysPending[prevKey] = pendingKeys;\n        pendingKeys = [];\n      }\n    } else {\n      pendingKeys.push(prevKey);\n    }\n  }\n\n  var i = void 0;\n  var childMapping = {};\n  for (var nextKey in next) {\n    if (nextKeysPending[nextKey]) {\n      for (i = 0; i < nextKeysPending[nextKey].length; i++) {\n        var pendingNextKey = nextKeysPending[nextKey][i];\n        childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);\n      }\n    }\n    childMapping[nextKey] = getValueForKey(nextKey);\n  }\n\n  // Finally, add the keys which didn't appear before any key in `next`\n  for (i = 0; i < pendingKeys.length; i++) {\n    childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);\n  }\n\n  return childMapping;\n}\n\nfunction getProp(child, prop, props) {\n  return props[prop] != null ? props[prop] : child.props[prop];\n}\n\nfunction getInitialChildMapping(props, onExited) {\n  return getChildMapping(props.children, function (child) {\n    return (0, _react.cloneElement)(child, {\n      onExited: onExited.bind(null, child),\n      in: true,\n      appear: getProp(child, 'appear', props),\n      enter: getProp(child, 'enter', props),\n      exit: getProp(child, 'exit', props)\n    });\n  });\n}\n\nfunction getNextChildMapping(nextProps, prevChildMapping, onExited) {\n  var nextChildMapping = getChildMapping(nextProps.children);\n  var children = mergeChildMappings(prevChildMapping, nextChildMapping);\n\n  Object.keys(children).forEach(function (key) {\n    var child = children[key];\n\n    if (!(0, _react.isValidElement)(child)) return;\n\n    var hasPrev = key in prevChildMapping;\n    var hasNext = key in nextChildMapping;\n\n    var prevChild = prevChildMapping[key];\n    var isLeaving = (0, _react.isValidElement)(prevChild) && !prevChild.props.in;\n\n    // item is new (entering)\n    if (hasNext && (!hasPrev || isLeaving)) {\n      // console.log('entering', key)\n      children[key] = (0, _react.cloneElement)(child, {\n        onExited: onExited.bind(null, child),\n        in: true,\n        exit: getProp(child, 'exit', nextProps),\n        enter: getProp(child, 'enter', nextProps)\n      });\n    } else if (!hasNext && hasPrev && !isLeaving) {\n      // item is old (exiting)\n      // console.log('leaving', key)\n      children[key] = (0, _react.cloneElement)(child, { in: false });\n    } else if (hasNext && hasPrev && (0, _react.isValidElement)(prevChild)) {\n      // item hasn't changed transition states\n      // copy over the last transition props;\n      // console.log('unchanged', key)\n      children[key] = (0, _react.cloneElement)(child, {\n        onExited: onExited.bind(null, child),\n        in: prevChild.props.in,\n        exit: getProp(child, 'exit', nextProps),\n        enter: getProp(child, 'enter', nextProps)\n      });\n    }\n  });\n\n  return children;\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$react$index","~$shadow.js"]],"~:properties",["^5",["appear","onExited","__esModule","getNextChildMapping","getInitialChildMapping","getChildMapping","exit","mergeChildMappings","enter","in"]],"~:compiled-at",1537561386602,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$react_transition_group$utils$ChildMapping.js\",\n\"lineCount\":6,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/react-transition-group/utils/ChildMapping.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$react_transition_group$utils$ChildMapping\\\"] = function(global,process,require,module,exports,shadow$shims) {\\n'use strict';\\n\\nexports.__esModule = true;\\nexports.getChildMapping = getChildMapping;\\nexports.mergeChildMappings = mergeChildMappings;\\nexports.getInitialChildMapping = getInitialChildMapping;\\nexports.getNextChildMapping = getNextChildMapping;\\n\\nvar _react = require('react');\\n\\n/**\\n * Given `this.props.children`, return an object mapping key to child.\\n *\\n * @param {*} children `this.props.children`\\n * @return {object} Mapping of key to child\\n */\\nfunction getChildMapping(children, mapFn) {\\n  var mapper = function mapper(child) {\\n    return mapFn && (0, _react.isValidElement)(child) ? mapFn(child) : child;\\n  };\\n\\n  var result = Object.create(null);\\n  if (children) _react.Children.map(children, function (c) {\\n    return c;\\n  }).forEach(function (child) {\\n    // run the map function here instead so that the key is the computed one\\n    result[child.key] = mapper(child);\\n  });\\n  return result;\\n}\\n\\n/**\\n * When you're adding or removing children some may be added or removed in the\\n * same render pass. We want to show *both* since we want to simultaneously\\n * animate elements in and out. This function takes a previous set of keys\\n * and a new set of keys and merges them with its best guess of the correct\\n * ordering. In the future we may expose some of the utilities in\\n * ReactMultiChild to make this easy, but for now React itself does not\\n * directly have this concept of the union of prevChildren and nextChildren\\n * so we implement it here.\\n *\\n * @param {object} prev prev children as returned from\\n * `ReactTransitionChildMapping.getChildMapping()`.\\n * @param {object} next next children as returned from\\n * `ReactTransitionChildMapping.getChildMapping()`.\\n * @return {object} a key set that contains all keys in `prev` and all keys\\n * in `next` in a reasonable order.\\n */\\nfunction mergeChildMappings(prev, next) {\\n  prev = prev || {};\\n  next = next || {};\\n\\n  function getValueForKey(key) {\\n    return key in next ? next[key] : prev[key];\\n  }\\n\\n  // For each key of `next`, the list of keys to insert before that key in\\n  // the combined list\\n  var nextKeysPending = Object.create(null);\\n\\n  var pendingKeys = [];\\n  for (var prevKey in prev) {\\n    if (prevKey in next) {\\n      if (pendingKeys.length) {\\n        nextKeysPending[prevKey] = pendingKeys;\\n        pendingKeys = [];\\n      }\\n    } else {\\n      pendingKeys.push(prevKey);\\n    }\\n  }\\n\\n  var i = void 0;\\n  var childMapping = {};\\n  for (var nextKey in next) {\\n    if (nextKeysPending[nextKey]) {\\n      for (i = 0; i < nextKeysPending[nextKey].length; i++) {\\n        var pendingNextKey = nextKeysPending[nextKey][i];\\n        childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);\\n      }\\n    }\\n    childMapping[nextKey] = getValueForKey(nextKey);\\n  }\\n\\n  // Finally, add the keys which didn't appear before any key in `next`\\n  for (i = 0; i < pendingKeys.length; i++) {\\n    childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);\\n  }\\n\\n  return childMapping;\\n}\\n\\nfunction getProp(child, prop, props) {\\n  return props[prop] != null ? props[prop] : child.props[prop];\\n}\\n\\nfunction getInitialChildMapping(props, onExited) {\\n  return getChildMapping(props.children, function (child) {\\n    return (0, _react.cloneElement)(child, {\\n      onExited: onExited.bind(null, child),\\n      in: true,\\n      appear: getProp(child, 'appear', props),\\n      enter: getProp(child, 'enter', props),\\n      exit: getProp(child, 'exit', props)\\n    });\\n  });\\n}\\n\\nfunction getNextChildMapping(nextProps, prevChildMapping, onExited) {\\n  var nextChildMapping = getChildMapping(nextProps.children);\\n  var children = mergeChildMappings(prevChildMapping, nextChildMapping);\\n\\n  Object.keys(children).forEach(function (key) {\\n    var child = children[key];\\n\\n    if (!(0, _react.isValidElement)(child)) return;\\n\\n    var hasPrev = key in prevChildMapping;\\n    var hasNext = key in nextChildMapping;\\n\\n    var prevChild = prevChildMapping[key];\\n    var isLeaving = (0, _react.isValidElement)(prevChild) && !prevChild.props.in;\\n\\n    // item is new (entering)\\n    if (hasNext && (!hasPrev || isLeaving)) {\\n      // console.log('entering', key)\\n      children[key] = (0, _react.cloneElement)(child, {\\n        onExited: onExited.bind(null, child),\\n        in: true,\\n        exit: getProp(child, 'exit', nextProps),\\n        enter: getProp(child, 'enter', nextProps)\\n      });\\n    } else if (!hasNext && hasPrev && !isLeaving) {\\n      // item is old (exiting)\\n      // console.log('leaving', key)\\n      children[key] = (0, _react.cloneElement)(child, { in: false });\\n    } else if (hasNext && hasPrev && (0, _react.isValidElement)(prevChild)) {\\n      // item hasn't changed transition states\\n      // copy over the last transition props;\\n      // console.log('unchanged', key)\\n      children[key] = (0, _react.cloneElement)(child, {\\n        onExited: onExited.bind(null, child),\\n        in: prevChild.props.in,\\n        exit: getProp(child, 'exit', nextProps),\\n        enter: getProp(child, 'enter', nextProps)\\n      });\\n    }\\n  });\\n\\n  return children;\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"process\",\"require\",\"module\",\"exports\",\"shadow$shims\",\"getChildMapping\",\"children\",\"mapFn\",\"result\",\"Object\",\"create\",\"_react\",\"Children\",\"map\",\"c\",\"forEach\",\"child\",\"key\",\"isValidElement\",\"mergeChildMappings\",\"prev\",\"next\",\"getValueForKey\",\"nextKeysPending\",\"pendingKeys\",\"prevKey\",\"length\",\"push\",\"i\",\"childMapping\",\"nextKey\",\"pendingNextKey\",\"getProp\",\"prop\",\"props\",\"__esModule\",\"getInitialChildMapping\",\"onExited\",\"cloneElement\",\"bind\",\"in\",\"appear\",\"enter\",\"exit\",\"getNextChildMapping\",\"nextProps\",\"prevChildMapping\",\"nextChildMapping\",\"keys\",\"hasPrev\",\"hasNext\",\"prevChild\",\"isLeaving\"]\n}\n"]