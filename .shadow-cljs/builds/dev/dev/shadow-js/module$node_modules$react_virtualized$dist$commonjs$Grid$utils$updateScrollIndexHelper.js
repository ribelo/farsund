["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/react-virtualized/dist/commonjs/Grid/utils/updateScrollIndexHelper.js"],"~:js","shadow$provide.module$node_modules$react_virtualized$dist$commonjs$Grid$utils$updateScrollIndexHelper=function(global,process,require,module,exports,shadow$shims){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.default=function(_ref){var cellSize=_ref.cellSize,cellSizeAndPositionManager=_ref.cellSizeAndPositionManager,previousCellsCount=_ref.previousCellsCount,previousCellSize=_ref.previousCellSize,previousScrollToAlignment=_ref.previousScrollToAlignment,previousScrollToIndex=_ref.previousScrollToIndex,\npreviousSize=_ref.previousSize,scrollOffset=_ref.scrollOffset,scrollToAlignment=_ref.scrollToAlignment,scrollToIndex=_ref.scrollToIndex,size=_ref.size,sizeJustIncreasedFromZero=_ref.sizeJustIncreasedFromZero;_ref=_ref.updateScrollIndexCallback;var cellCount=cellSizeAndPositionManager.getCellCount(),hasScrollToIndex=0<=scrollToIndex&&scrollToIndex<cellCount;hasScrollToIndex&&(size!==previousSize||sizeJustIncreasedFromZero||!previousCellSize||\"number\"===typeof cellSize&&cellSize!==previousCellSize||\nscrollToAlignment!==previousScrollToAlignment||scrollToIndex!==previousScrollToIndex)?_ref(scrollToIndex):!hasScrollToIndex&&0<cellCount&&(size<previousSize||cellCount<previousCellsCount)&&scrollOffset>cellSizeAndPositionManager.getTotalSize()-size&&_ref(cellCount-1)};require(\"module$node_modules$react_virtualized$dist$commonjs$Grid$utils$ScalingCellSizeAndPositionManager\");require(\"module$node_modules$react_virtualized$dist$commonjs$Grid$types\")}","~:source","shadow$provide[\"module$node_modules$react_virtualized$dist$commonjs$Grid$utils$updateScrollIndexHelper\"] = function(global,process,require,module,exports,shadow$shims) {\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = updateScrollIndexHelper;\n\nvar _ScalingCellSizeAndPositionManager = require('./ScalingCellSizeAndPositionManager.js');\n\nvar _ScalingCellSizeAndPositionManager2 = _interopRequireDefault(_ScalingCellSizeAndPositionManager);\n\nvar _types = require('../types');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Helper function that determines when to update scroll offsets to ensure that a scroll-to-index remains visible.\n * This function also ensures that the scroll ofset isn't past the last column/row of cells.\n */\n\nfunction updateScrollIndexHelper(_ref) {\n  var cellSize = _ref.cellSize,\n      cellSizeAndPositionManager = _ref.cellSizeAndPositionManager,\n      previousCellsCount = _ref.previousCellsCount,\n      previousCellSize = _ref.previousCellSize,\n      previousScrollToAlignment = _ref.previousScrollToAlignment,\n      previousScrollToIndex = _ref.previousScrollToIndex,\n      previousSize = _ref.previousSize,\n      scrollOffset = _ref.scrollOffset,\n      scrollToAlignment = _ref.scrollToAlignment,\n      scrollToIndex = _ref.scrollToIndex,\n      size = _ref.size,\n      sizeJustIncreasedFromZero = _ref.sizeJustIncreasedFromZero,\n      updateScrollIndexCallback = _ref.updateScrollIndexCallback;\n\n  var cellCount = cellSizeAndPositionManager.getCellCount();\n  var hasScrollToIndex = scrollToIndex >= 0 && scrollToIndex < cellCount;\n  var sizeHasChanged = size !== previousSize || sizeJustIncreasedFromZero || !previousCellSize || typeof cellSize === 'number' && cellSize !== previousCellSize;\n\n  // If we have a new scroll target OR if height/row-height has changed,\n  // We should ensure that the scroll target is visible.\n  if (hasScrollToIndex && (sizeHasChanged || scrollToAlignment !== previousScrollToAlignment || scrollToIndex !== previousScrollToIndex)) {\n    updateScrollIndexCallback(scrollToIndex);\n\n    // If we don't have a selected item but list size or number of children have decreased,\n    // Make sure we aren't scrolled too far past the current content.\n  } else if (!hasScrollToIndex && cellCount > 0 && (size < previousSize || cellCount < previousCellsCount)) {\n    // We need to ensure that the current scroll offset is still within the collection's range.\n    // To do this, we don't need to measure everything; CellMeasurer would perform poorly.\n    // Just check to make sure we're still okay.\n    // Only adjust the scroll position if we've scrolled below the last set of rows.\n    if (scrollOffset > cellSizeAndPositionManager.getTotalSize() - size) {\n      updateScrollIndexCallback(cellCount - 1);\n    }\n  }\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$react_virtualized$dist$commonjs$Grid$types","~$shadow.js","~$module$node_modules$react_virtualized$dist$commonjs$Grid$utils$ScalingCellSizeAndPositionManager"]],"~:properties",["^5",["__esModule","value","default"]],"~:compiled-at",1537791607614,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$react_virtualized$dist$commonjs$Grid$utils$updateScrollIndexHelper.js\",\n\"lineCount\":3,\n\"mappings\":\"AAAAA,cAAA,uFAAA,CAA2G,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,OAAhB,CAAwBC,MAAxB,CAA+BC,OAA/B,CAAuCC,YAAvC,CAAqD,CAGxKC,MAAAC,eAAA,CAAsBH,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CI,MAAO,CAAA,CADoC,CAA7C,CAGAJ,QAAAK,QAAA,CAeAC,QAAgC,CAACC,IAAD,CAAO,CAAA,IACjCC,SAAWD,IAAAC,SADsB,CAEjCC,2BAA6BF,IAAAE,2BAFI,CAGjCC,mBAAqBH,IAAAG,mBAHY,CAIjCC,iBAAmBJ,IAAAI,iBAJc,CAKjCC,0BAA4BL,IAAAK,0BALK,CAMjCC,sBAAwBN,IAAAM,sBANS;AAOjCC,aAAeP,IAAAO,aAPkB,CAQjCC,aAAeR,IAAAQ,aARkB,CASjCC,kBAAoBT,IAAAS,kBATa,CAUjCC,cAAgBV,IAAAU,cAViB,CAWjCC,KAAOX,IAAAW,KAX0B,CAYjCC,0BAA4BZ,IAAAY,0BAC5BC,KAAAA,CAA4Bb,IAAAa,0BAEhC,KAAIC,UAAYZ,0BAAAa,aAAA,EAAhB,CACIC,iBAAoC,CAApCA,EAAmBN,aAAnBM,EAAyCN,aAAzCM,CAAyDF,SAKzDE,iBAAJ,GAJqBL,IAIrB,GAJ8BJ,YAI9B,EAJ8CK,yBAI9C,EAJ2E,CAACR,gBAI5E,EAJoH,QAIpH,GAJgG,MAAOH,SAIvG,EAJgIA,QAIhI,GAJ6IG,gBAI7I;AAA2CK,iBAA3C,GAAiEJ,yBAAjE,EAA8FK,aAA9F,GAAgHJ,qBAAhH,EACEO,IAAA,CAA0BH,aAA1B,CADF,CAKW,CAACM,gBALZ,EAK4C,CAL5C,CAKgCF,SALhC,GAKkDH,IALlD,CAKyDJ,YALzD,EAKyEO,SALzE,CAKqFX,kBALrF,GAUMK,YAVN,CAUqBN,0BAAAe,aAAA,EAVrB,CAUiEN,IAVjE,EAWIE,IAAA,CAA0BC,SAA1B,CAAsC,CAAtC,CAhCiC,CAbEvB,QAAA,CAAQ,kGAAR,CAI5BA,QAAA,CAAQ,gEAAR,CAZ2J;\",\n\"sources\":[\"node_modules/react-virtualized/dist/commonjs/Grid/utils/updateScrollIndexHelper.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$react_virtualized$dist$commonjs$Grid$utils$updateScrollIndexHelper\\\"] = function(global,process,require,module,exports,shadow$shims) {\\n'use strict';\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.default = updateScrollIndexHelper;\\n\\nvar _ScalingCellSizeAndPositionManager = require('./ScalingCellSizeAndPositionManager.js');\\n\\nvar _ScalingCellSizeAndPositionManager2 = _interopRequireDefault(_ScalingCellSizeAndPositionManager);\\n\\nvar _types = require('../types');\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\\n\\n/**\\n * Helper function that determines when to update scroll offsets to ensure that a scroll-to-index remains visible.\\n * This function also ensures that the scroll ofset isn't past the last column/row of cells.\\n */\\n\\nfunction updateScrollIndexHelper(_ref) {\\n  var cellSize = _ref.cellSize,\\n      cellSizeAndPositionManager = _ref.cellSizeAndPositionManager,\\n      previousCellsCount = _ref.previousCellsCount,\\n      previousCellSize = _ref.previousCellSize,\\n      previousScrollToAlignment = _ref.previousScrollToAlignment,\\n      previousScrollToIndex = _ref.previousScrollToIndex,\\n      previousSize = _ref.previousSize,\\n      scrollOffset = _ref.scrollOffset,\\n      scrollToAlignment = _ref.scrollToAlignment,\\n      scrollToIndex = _ref.scrollToIndex,\\n      size = _ref.size,\\n      sizeJustIncreasedFromZero = _ref.sizeJustIncreasedFromZero,\\n      updateScrollIndexCallback = _ref.updateScrollIndexCallback;\\n\\n  var cellCount = cellSizeAndPositionManager.getCellCount();\\n  var hasScrollToIndex = scrollToIndex >= 0 && scrollToIndex < cellCount;\\n  var sizeHasChanged = size !== previousSize || sizeJustIncreasedFromZero || !previousCellSize || typeof cellSize === 'number' && cellSize !== previousCellSize;\\n\\n  // If we have a new scroll target OR if height/row-height has changed,\\n  // We should ensure that the scroll target is visible.\\n  if (hasScrollToIndex && (sizeHasChanged || scrollToAlignment !== previousScrollToAlignment || scrollToIndex !== previousScrollToIndex)) {\\n    updateScrollIndexCallback(scrollToIndex);\\n\\n    // If we don't have a selected item but list size or number of children have decreased,\\n    // Make sure we aren't scrolled too far past the current content.\\n  } else if (!hasScrollToIndex && cellCount > 0 && (size < previousSize || cellCount < previousCellsCount)) {\\n    // We need to ensure that the current scroll offset is still within the collection's range.\\n    // To do this, we don't need to measure everything; CellMeasurer would perform poorly.\\n    // Just check to make sure we're still okay.\\n    // Only adjust the scroll position if we've scrolled below the last set of rows.\\n    if (scrollOffset > cellSizeAndPositionManager.getTotalSize() - size) {\\n      updateScrollIndexCallback(cellCount - 1);\\n    }\\n  }\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"process\",\"require\",\"module\",\"exports\",\"shadow$shims\",\"Object\",\"defineProperty\",\"value\",\"default\",\"updateScrollIndexHelper\",\"_ref\",\"cellSize\",\"cellSizeAndPositionManager\",\"previousCellsCount\",\"previousCellSize\",\"previousScrollToAlignment\",\"previousScrollToIndex\",\"previousSize\",\"scrollOffset\",\"scrollToAlignment\",\"scrollToIndex\",\"size\",\"sizeJustIncreasedFromZero\",\"updateScrollIndexCallback\",\"cellCount\",\"getCellCount\",\"hasScrollToIndex\",\"getTotalSize\"]\n}\n"]