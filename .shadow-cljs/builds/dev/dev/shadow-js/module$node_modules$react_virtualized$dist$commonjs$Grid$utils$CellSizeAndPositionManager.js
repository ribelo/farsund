["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/react-virtualized/dist/commonjs/Grid/utils/CellSizeAndPositionManager.js"],"~:js","shadow$provide.module$node_modules$react_virtualized$dist$commonjs$Grid$utils$CellSizeAndPositionManager=function(global,process,require,module,exports,shadow$shims){Object.defineProperty(exports,\"__esModule\",{value:!0});var _classCallCheck3=(global=require(\"module$node_modules$babel_runtime$helpers$classCallCheck\"))&&global.__esModule?global:{default:global},_createClass3=(global=require(\"module$node_modules$babel_runtime$helpers$createClass\"))&&global.__esModule?global:{default:global};require(\"module$node_modules$react_virtualized$dist$commonjs$Grid$types\");\nrequire=function(){function CellSizeAndPositionManager(_ref){var cellCount=_ref.cellCount,cellSizeGetter=_ref.cellSizeGetter;_ref=_ref.estimatedCellSize;(0,_classCallCheck3.default)(this,CellSizeAndPositionManager);this._cellSizeAndPositionData={};this._lastBatchedIndex=this._lastMeasuredIndex=-1;this._cellSizeGetter=cellSizeGetter;this._cellCount=cellCount;this._estimatedCellSize=_ref}(0,_createClass3.default)(CellSizeAndPositionManager,[{key:\"areOffsetsAdjusted\",value:function(){return!1}},{key:\"configure\",\nvalue:function(_ref2){var estimatedCellSize=_ref2.estimatedCellSize,cellSizeGetter=_ref2.cellSizeGetter;this._cellCount=_ref2.cellCount;this._estimatedCellSize=estimatedCellSize;this._cellSizeGetter=cellSizeGetter}},{key:\"getCellCount\",value:function(){return this._cellCount}},{key:\"getEstimatedCellSize\",value:function(){return this._estimatedCellSize}},{key:\"getLastMeasuredIndex\",value:function(){return this._lastMeasuredIndex}},{key:\"getOffsetAdjustment\",value:function(){return 0}},{key:\"getSizeAndPositionOfCell\",\nvalue:function(index){if(0>index||index>=this._cellCount)throw Error(\"Requested index \"+index+\" is outside of range 0..\"+this._cellCount);if(index>this._lastMeasuredIndex){var lastMeasuredCellSizeAndPosition=this.getSizeAndPositionOfLastMeasuredCell();lastMeasuredCellSizeAndPosition=lastMeasuredCellSizeAndPosition.offset+lastMeasuredCellSizeAndPosition.size;for(var i=this._lastMeasuredIndex+1;i<=index;i++){var _size=this._cellSizeGetter({index:i});if(void 0===_size||isNaN(_size))throw Error(\"Invalid size returned for cell \"+\ni+\" of value \"+_size);null===_size?(this._cellSizeAndPositionData[i]={offset:lastMeasuredCellSizeAndPosition,size:0},this._lastBatchedIndex=index):(this._cellSizeAndPositionData[i]={offset:lastMeasuredCellSizeAndPosition,size:_size},lastMeasuredCellSizeAndPosition+=_size,this._lastMeasuredIndex=index)}}return this._cellSizeAndPositionData[index]}},{key:\"getSizeAndPositionOfLastMeasuredCell\",value:function(){return 0<=this._lastMeasuredIndex?this._cellSizeAndPositionData[this._lastMeasuredIndex]:{offset:0,\nsize:0}}},{key:\"getTotalSize\",value:function(){var lastMeasuredCellSizeAndPosition=this.getSizeAndPositionOfLastMeasuredCell();return lastMeasuredCellSizeAndPosition.offset+lastMeasuredCellSizeAndPosition.size+(this._cellCount-this._lastMeasuredIndex-1)*this._estimatedCellSize}},{key:\"getUpdatedOffsetForIndex\",value:function(_ref3){var _ref3$align=_ref3.align,align=void 0===_ref3$align?\"auto\":_ref3$align;_ref3$align=_ref3.containerSize;var currentOffset=_ref3.currentOffset;if(0>=_ref3$align)return 0;\n_ref3=this.getSizeAndPositionOfCell(_ref3.targetIndex);var maxOffset=_ref3.offset,minOffset=maxOffset-_ref3$align+_ref3.size;switch(align){case \"start\":align=maxOffset;break;case \"end\":align=minOffset;break;case \"center\":align=maxOffset-(_ref3$align-_ref3.size)/2;break;default:align=Math.max(minOffset,Math.min(maxOffset,currentOffset))}currentOffset=this.getTotalSize();return Math.max(0,Math.min(currentOffset-_ref3$align,align))}},{key:\"getVisibleCellRange\",value:function(params){var containerSize=\nparams.containerSize;params=params.offset;if(0===this.getTotalSize())return{};containerSize=params+containerSize;var start=this._findNearestCell(params);params=this.getSizeAndPositionOfCell(start);params=params.offset+params.size;for(var stop=start;params<containerSize&&stop<this._cellCount-1;)stop++,params+=this.getSizeAndPositionOfCell(stop).size;return{start:start,stop:stop}}},{key:\"resetCell\",value:function(index){this._lastMeasuredIndex=Math.min(this._lastMeasuredIndex,index-1)}},{key:\"_binarySearch\",\nvalue:function(high,low,offset){for(;low<=high;){var middle=low+Math.floor((high-low)/2),_currentOffset=this.getSizeAndPositionOfCell(middle).offset;if(_currentOffset===offset)return middle;_currentOffset<offset?low=middle+1:_currentOffset>offset&&(high=middle-1)}return 0<low?low-1:0}},{key:\"_exponentialSearch\",value:function(index,offset){for(var interval=1;index<this._cellCount&&this.getSizeAndPositionOfCell(index).offset<offset;)index+=interval,interval*=2;return this._binarySearch(Math.min(index,\nthis._cellCount-1),Math.floor(index/2),offset)}},{key:\"_findNearestCell\",value:function(offset){if(isNaN(offset))throw Error(\"Invalid offset \"+offset+\" specified\");offset=Math.max(0,offset);var lastMeasuredCellSizeAndPosition=this.getSizeAndPositionOfLastMeasuredCell(),lastMeasuredIndex=Math.max(0,this._lastMeasuredIndex);return lastMeasuredCellSizeAndPosition.offset>=offset?this._binarySearch(lastMeasuredIndex,0,offset):this._exponentialSearch(lastMeasuredIndex,offset)}}]);return CellSizeAndPositionManager}();\nexports.default=require}","~:source","shadow$provide[\"module$node_modules$react_virtualized$dist$commonjs$Grid$utils$CellSizeAndPositionManager\"] = function(global,process,require,module,exports,shadow$shims) {\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _types = require('../types');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Just-in-time calculates and caches size and position information for a collection of cells.\n */\n\nvar CellSizeAndPositionManager = function () {\n\n  // Used in deferred mode to track which cells have been queued for measurement.\n\n  // Cache of size and position data for cells, mapped by cell index.\n  // Note that invalid values may exist in this map so only rely on cells up to this._lastMeasuredIndex\n  function CellSizeAndPositionManager(_ref) {\n    var cellCount = _ref.cellCount,\n        cellSizeGetter = _ref.cellSizeGetter,\n        estimatedCellSize = _ref.estimatedCellSize;\n    (0, _classCallCheck3.default)(this, CellSizeAndPositionManager);\n    this._cellSizeAndPositionData = {};\n    this._lastMeasuredIndex = -1;\n    this._lastBatchedIndex = -1;\n\n    this._cellSizeGetter = cellSizeGetter;\n    this._cellCount = cellCount;\n    this._estimatedCellSize = estimatedCellSize;\n  }\n\n  // Measurements for cells up to this index can be trusted; cells afterward should be estimated.\n\n\n  (0, _createClass3.default)(CellSizeAndPositionManager, [{\n    key: 'areOffsetsAdjusted',\n    value: function areOffsetsAdjusted() {\n      return false;\n    }\n  }, {\n    key: 'configure',\n    value: function configure(_ref2) {\n      var cellCount = _ref2.cellCount,\n          estimatedCellSize = _ref2.estimatedCellSize,\n          cellSizeGetter = _ref2.cellSizeGetter;\n\n      this._cellCount = cellCount;\n      this._estimatedCellSize = estimatedCellSize;\n      this._cellSizeGetter = cellSizeGetter;\n    }\n  }, {\n    key: 'getCellCount',\n    value: function getCellCount() {\n      return this._cellCount;\n    }\n  }, {\n    key: 'getEstimatedCellSize',\n    value: function getEstimatedCellSize() {\n      return this._estimatedCellSize;\n    }\n  }, {\n    key: 'getLastMeasuredIndex',\n    value: function getLastMeasuredIndex() {\n      return this._lastMeasuredIndex;\n    }\n  }, {\n    key: 'getOffsetAdjustment',\n    value: function getOffsetAdjustment() {\n      return 0;\n    }\n\n    /**\n     * This method returns the size and position for the cell at the specified index.\n     * It just-in-time calculates (or used cached values) for cells leading up to the index.\n     */\n\n  }, {\n    key: 'getSizeAndPositionOfCell',\n    value: function getSizeAndPositionOfCell(index) {\n      if (index < 0 || index >= this._cellCount) {\n        throw Error('Requested index ' + index + ' is outside of range 0..' + this._cellCount);\n      }\n\n      if (index > this._lastMeasuredIndex) {\n        var lastMeasuredCellSizeAndPosition = this.getSizeAndPositionOfLastMeasuredCell();\n        var _offset = lastMeasuredCellSizeAndPosition.offset + lastMeasuredCellSizeAndPosition.size;\n\n        for (var i = this._lastMeasuredIndex + 1; i <= index; i++) {\n          var _size = this._cellSizeGetter({ index: i });\n\n          // undefined or NaN probably means a logic error in the size getter.\n          // null means we're using CellMeasurer and haven't yet measured a given index.\n          if (_size === undefined || isNaN(_size)) {\n            throw Error('Invalid size returned for cell ' + i + ' of value ' + _size);\n          } else if (_size === null) {\n            this._cellSizeAndPositionData[i] = {\n              offset: _offset,\n              size: 0\n            };\n\n            this._lastBatchedIndex = index;\n          } else {\n            this._cellSizeAndPositionData[i] = {\n              offset: _offset,\n              size: _size\n            };\n\n            _offset += _size;\n\n            this._lastMeasuredIndex = index;\n          }\n        }\n      }\n\n      return this._cellSizeAndPositionData[index];\n    }\n  }, {\n    key: 'getSizeAndPositionOfLastMeasuredCell',\n    value: function getSizeAndPositionOfLastMeasuredCell() {\n      return this._lastMeasuredIndex >= 0 ? this._cellSizeAndPositionData[this._lastMeasuredIndex] : {\n        offset: 0,\n        size: 0\n      };\n    }\n\n    /**\n     * Total size of all cells being measured.\n     * This value will be completely estimated initially.\n     * As cells are measured, the estimate will be updated.\n     */\n\n  }, {\n    key: 'getTotalSize',\n    value: function getTotalSize() {\n      var lastMeasuredCellSizeAndPosition = this.getSizeAndPositionOfLastMeasuredCell();\n      var totalSizeOfMeasuredCells = lastMeasuredCellSizeAndPosition.offset + lastMeasuredCellSizeAndPosition.size;\n      var numUnmeasuredCells = this._cellCount - this._lastMeasuredIndex - 1;\n      var totalSizeOfUnmeasuredCells = numUnmeasuredCells * this._estimatedCellSize;\n      return totalSizeOfMeasuredCells + totalSizeOfUnmeasuredCells;\n    }\n\n    /**\n     * Determines a new offset that ensures a certain cell is visible, given the current offset.\n     * If the cell is already visible then the current offset will be returned.\n     * If the current offset is too great or small, it will be adjusted just enough to ensure the specified index is visible.\n     *\n     * @param align Desired alignment within container; one of \"auto\" (default), \"start\", or \"end\"\n     * @param containerSize Size (width or height) of the container viewport\n     * @param currentOffset Container's current (x or y) offset\n     * @param totalSize Total size (width or height) of all cells\n     * @return Offset to use to ensure the specified cell is visible\n     */\n\n  }, {\n    key: 'getUpdatedOffsetForIndex',\n    value: function getUpdatedOffsetForIndex(_ref3) {\n      var _ref3$align = _ref3.align,\n          align = _ref3$align === undefined ? 'auto' : _ref3$align,\n          containerSize = _ref3.containerSize,\n          currentOffset = _ref3.currentOffset,\n          targetIndex = _ref3.targetIndex;\n\n      if (containerSize <= 0) {\n        return 0;\n      }\n\n      var datum = this.getSizeAndPositionOfCell(targetIndex);\n      var maxOffset = datum.offset;\n      var minOffset = maxOffset - containerSize + datum.size;\n\n      var idealOffset = void 0;\n\n      switch (align) {\n        case 'start':\n          idealOffset = maxOffset;\n          break;\n        case 'end':\n          idealOffset = minOffset;\n          break;\n        case 'center':\n          idealOffset = maxOffset - (containerSize - datum.size) / 2;\n          break;\n        default:\n          idealOffset = Math.max(minOffset, Math.min(maxOffset, currentOffset));\n          break;\n      }\n\n      var totalSize = this.getTotalSize();\n\n      return Math.max(0, Math.min(totalSize - containerSize, idealOffset));\n    }\n  }, {\n    key: 'getVisibleCellRange',\n    value: function getVisibleCellRange(params) {\n      var containerSize = params.containerSize,\n          offset = params.offset;\n\n\n      var totalSize = this.getTotalSize();\n\n      if (totalSize === 0) {\n        return {};\n      }\n\n      var maxOffset = offset + containerSize;\n      var start = this._findNearestCell(offset);\n\n      var datum = this.getSizeAndPositionOfCell(start);\n      offset = datum.offset + datum.size;\n\n      var stop = start;\n\n      while (offset < maxOffset && stop < this._cellCount - 1) {\n        stop++;\n\n        offset += this.getSizeAndPositionOfCell(stop).size;\n      }\n\n      return {\n        start: start,\n        stop: stop\n      };\n    }\n\n    /**\n     * Clear all cached values for cells after the specified index.\n     * This method should be called for any cell that has changed its size.\n     * It will not immediately perform any calculations; they'll be performed the next time getSizeAndPositionOfCell() is called.\n     */\n\n  }, {\n    key: 'resetCell',\n    value: function resetCell(index) {\n      this._lastMeasuredIndex = Math.min(this._lastMeasuredIndex, index - 1);\n    }\n  }, {\n    key: '_binarySearch',\n    value: function _binarySearch(high, low, offset) {\n      while (low <= high) {\n        var middle = low + Math.floor((high - low) / 2);\n        var _currentOffset = this.getSizeAndPositionOfCell(middle).offset;\n\n        if (_currentOffset === offset) {\n          return middle;\n        } else if (_currentOffset < offset) {\n          low = middle + 1;\n        } else if (_currentOffset > offset) {\n          high = middle - 1;\n        }\n      }\n\n      if (low > 0) {\n        return low - 1;\n      } else {\n        return 0;\n      }\n    }\n  }, {\n    key: '_exponentialSearch',\n    value: function _exponentialSearch(index, offset) {\n      var interval = 1;\n\n      while (index < this._cellCount && this.getSizeAndPositionOfCell(index).offset < offset) {\n        index += interval;\n        interval *= 2;\n      }\n\n      return this._binarySearch(Math.min(index, this._cellCount - 1), Math.floor(index / 2), offset);\n    }\n\n    /**\n     * Searches for the cell (index) nearest the specified offset.\n     *\n     * If no exact match is found the next lowest cell index will be returned.\n     * This allows partially visible cells (with offsets just before/above the fold) to be visible.\n     */\n\n  }, {\n    key: '_findNearestCell',\n    value: function _findNearestCell(offset) {\n      if (isNaN(offset)) {\n        throw Error('Invalid offset ' + offset + ' specified');\n      }\n\n      // Our search algorithms find the nearest match at or below the specified offset.\n      // So make sure the offset is at least 0 or no match will be found.\n      offset = Math.max(0, offset);\n\n      var lastMeasuredCellSizeAndPosition = this.getSizeAndPositionOfLastMeasuredCell();\n      var lastMeasuredIndex = Math.max(0, this._lastMeasuredIndex);\n\n      if (lastMeasuredCellSizeAndPosition.offset >= offset) {\n        // If we've already measured cells within this range just use a binary search as it's faster.\n        return this._binarySearch(lastMeasuredIndex, 0, offset);\n      } else {\n        // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n        // The exponential search avoids pre-computing sizes for the full set of cells as a binary search would.\n        // The overall complexity for this approach is O(log n).\n        return this._exponentialSearch(lastMeasuredIndex, offset);\n      }\n    }\n  }]);\n  return CellSizeAndPositionManager;\n}();\n\nexports.default = CellSizeAndPositionManager;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$react_virtualized$dist$commonjs$Grid$types","~$shadow.js","~$module$node_modules$babel_runtime$helpers$classCallCheck","~$module$node_modules$babel_runtime$helpers$createClass"]],"~:properties",["^5",["stop","_cellCount","_cellSizeGetter","index","offset","key","__esModule","_lastBatchedIndex","value","_estimatedCellSize","start","_lastMeasuredIndex","size","default","_cellSizeAndPositionData"]],"~:compiled-at",1537791607600,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$react_virtualized$dist$commonjs$Grid$utils$CellSizeAndPositionManager.js\",\n\"lineCount\":11,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/react-virtualized/dist/commonjs/Grid/utils/CellSizeAndPositionManager.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$react_virtualized$dist$commonjs$Grid$utils$CellSizeAndPositionManager\\\"] = function(global,process,require,module,exports,shadow$shims) {\\n'use strict';\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\n\\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\\n\\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\\n\\nvar _createClass2 = require('babel-runtime/helpers/createClass');\\n\\nvar _createClass3 = _interopRequireDefault(_createClass2);\\n\\nvar _types = require('../types');\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\\n\\n/**\\n * Just-in-time calculates and caches size and position information for a collection of cells.\\n */\\n\\nvar CellSizeAndPositionManager = function () {\\n\\n  // Used in deferred mode to track which cells have been queued for measurement.\\n\\n  // Cache of size and position data for cells, mapped by cell index.\\n  // Note that invalid values may exist in this map so only rely on cells up to this._lastMeasuredIndex\\n  function CellSizeAndPositionManager(_ref) {\\n    var cellCount = _ref.cellCount,\\n        cellSizeGetter = _ref.cellSizeGetter,\\n        estimatedCellSize = _ref.estimatedCellSize;\\n    (0, _classCallCheck3.default)(this, CellSizeAndPositionManager);\\n    this._cellSizeAndPositionData = {};\\n    this._lastMeasuredIndex = -1;\\n    this._lastBatchedIndex = -1;\\n\\n    this._cellSizeGetter = cellSizeGetter;\\n    this._cellCount = cellCount;\\n    this._estimatedCellSize = estimatedCellSize;\\n  }\\n\\n  // Measurements for cells up to this index can be trusted; cells afterward should be estimated.\\n\\n\\n  (0, _createClass3.default)(CellSizeAndPositionManager, [{\\n    key: 'areOffsetsAdjusted',\\n    value: function areOffsetsAdjusted() {\\n      return false;\\n    }\\n  }, {\\n    key: 'configure',\\n    value: function configure(_ref2) {\\n      var cellCount = _ref2.cellCount,\\n          estimatedCellSize = _ref2.estimatedCellSize,\\n          cellSizeGetter = _ref2.cellSizeGetter;\\n\\n      this._cellCount = cellCount;\\n      this._estimatedCellSize = estimatedCellSize;\\n      this._cellSizeGetter = cellSizeGetter;\\n    }\\n  }, {\\n    key: 'getCellCount',\\n    value: function getCellCount() {\\n      return this._cellCount;\\n    }\\n  }, {\\n    key: 'getEstimatedCellSize',\\n    value: function getEstimatedCellSize() {\\n      return this._estimatedCellSize;\\n    }\\n  }, {\\n    key: 'getLastMeasuredIndex',\\n    value: function getLastMeasuredIndex() {\\n      return this._lastMeasuredIndex;\\n    }\\n  }, {\\n    key: 'getOffsetAdjustment',\\n    value: function getOffsetAdjustment() {\\n      return 0;\\n    }\\n\\n    /**\\n     * This method returns the size and position for the cell at the specified index.\\n     * It just-in-time calculates (or used cached values) for cells leading up to the index.\\n     */\\n\\n  }, {\\n    key: 'getSizeAndPositionOfCell',\\n    value: function getSizeAndPositionOfCell(index) {\\n      if (index < 0 || index >= this._cellCount) {\\n        throw Error('Requested index ' + index + ' is outside of range 0..' + this._cellCount);\\n      }\\n\\n      if (index > this._lastMeasuredIndex) {\\n        var lastMeasuredCellSizeAndPosition = this.getSizeAndPositionOfLastMeasuredCell();\\n        var _offset = lastMeasuredCellSizeAndPosition.offset + lastMeasuredCellSizeAndPosition.size;\\n\\n        for (var i = this._lastMeasuredIndex + 1; i <= index; i++) {\\n          var _size = this._cellSizeGetter({ index: i });\\n\\n          // undefined or NaN probably means a logic error in the size getter.\\n          // null means we're using CellMeasurer and haven't yet measured a given index.\\n          if (_size === undefined || isNaN(_size)) {\\n            throw Error('Invalid size returned for cell ' + i + ' of value ' + _size);\\n          } else if (_size === null) {\\n            this._cellSizeAndPositionData[i] = {\\n              offset: _offset,\\n              size: 0\\n            };\\n\\n            this._lastBatchedIndex = index;\\n          } else {\\n            this._cellSizeAndPositionData[i] = {\\n              offset: _offset,\\n              size: _size\\n            };\\n\\n            _offset += _size;\\n\\n            this._lastMeasuredIndex = index;\\n          }\\n        }\\n      }\\n\\n      return this._cellSizeAndPositionData[index];\\n    }\\n  }, {\\n    key: 'getSizeAndPositionOfLastMeasuredCell',\\n    value: function getSizeAndPositionOfLastMeasuredCell() {\\n      return this._lastMeasuredIndex >= 0 ? this._cellSizeAndPositionData[this._lastMeasuredIndex] : {\\n        offset: 0,\\n        size: 0\\n      };\\n    }\\n\\n    /**\\n     * Total size of all cells being measured.\\n     * This value will be completely estimated initially.\\n     * As cells are measured, the estimate will be updated.\\n     */\\n\\n  }, {\\n    key: 'getTotalSize',\\n    value: function getTotalSize() {\\n      var lastMeasuredCellSizeAndPosition = this.getSizeAndPositionOfLastMeasuredCell();\\n      var totalSizeOfMeasuredCells = lastMeasuredCellSizeAndPosition.offset + lastMeasuredCellSizeAndPosition.size;\\n      var numUnmeasuredCells = this._cellCount - this._lastMeasuredIndex - 1;\\n      var totalSizeOfUnmeasuredCells = numUnmeasuredCells * this._estimatedCellSize;\\n      return totalSizeOfMeasuredCells + totalSizeOfUnmeasuredCells;\\n    }\\n\\n    /**\\n     * Determines a new offset that ensures a certain cell is visible, given the current offset.\\n     * If the cell is already visible then the current offset will be returned.\\n     * If the current offset is too great or small, it will be adjusted just enough to ensure the specified index is visible.\\n     *\\n     * @param align Desired alignment within container; one of \\\"auto\\\" (default), \\\"start\\\", or \\\"end\\\"\\n     * @param containerSize Size (width or height) of the container viewport\\n     * @param currentOffset Container's current (x or y) offset\\n     * @param totalSize Total size (width or height) of all cells\\n     * @return Offset to use to ensure the specified cell is visible\\n     */\\n\\n  }, {\\n    key: 'getUpdatedOffsetForIndex',\\n    value: function getUpdatedOffsetForIndex(_ref3) {\\n      var _ref3$align = _ref3.align,\\n          align = _ref3$align === undefined ? 'auto' : _ref3$align,\\n          containerSize = _ref3.containerSize,\\n          currentOffset = _ref3.currentOffset,\\n          targetIndex = _ref3.targetIndex;\\n\\n      if (containerSize <= 0) {\\n        return 0;\\n      }\\n\\n      var datum = this.getSizeAndPositionOfCell(targetIndex);\\n      var maxOffset = datum.offset;\\n      var minOffset = maxOffset - containerSize + datum.size;\\n\\n      var idealOffset = void 0;\\n\\n      switch (align) {\\n        case 'start':\\n          idealOffset = maxOffset;\\n          break;\\n        case 'end':\\n          idealOffset = minOffset;\\n          break;\\n        case 'center':\\n          idealOffset = maxOffset - (containerSize - datum.size) / 2;\\n          break;\\n        default:\\n          idealOffset = Math.max(minOffset, Math.min(maxOffset, currentOffset));\\n          break;\\n      }\\n\\n      var totalSize = this.getTotalSize();\\n\\n      return Math.max(0, Math.min(totalSize - containerSize, idealOffset));\\n    }\\n  }, {\\n    key: 'getVisibleCellRange',\\n    value: function getVisibleCellRange(params) {\\n      var containerSize = params.containerSize,\\n          offset = params.offset;\\n\\n\\n      var totalSize = this.getTotalSize();\\n\\n      if (totalSize === 0) {\\n        return {};\\n      }\\n\\n      var maxOffset = offset + containerSize;\\n      var start = this._findNearestCell(offset);\\n\\n      var datum = this.getSizeAndPositionOfCell(start);\\n      offset = datum.offset + datum.size;\\n\\n      var stop = start;\\n\\n      while (offset < maxOffset && stop < this._cellCount - 1) {\\n        stop++;\\n\\n        offset += this.getSizeAndPositionOfCell(stop).size;\\n      }\\n\\n      return {\\n        start: start,\\n        stop: stop\\n      };\\n    }\\n\\n    /**\\n     * Clear all cached values for cells after the specified index.\\n     * This method should be called for any cell that has changed its size.\\n     * It will not immediately perform any calculations; they'll be performed the next time getSizeAndPositionOfCell() is called.\\n     */\\n\\n  }, {\\n    key: 'resetCell',\\n    value: function resetCell(index) {\\n      this._lastMeasuredIndex = Math.min(this._lastMeasuredIndex, index - 1);\\n    }\\n  }, {\\n    key: '_binarySearch',\\n    value: function _binarySearch(high, low, offset) {\\n      while (low <= high) {\\n        var middle = low + Math.floor((high - low) / 2);\\n        var _currentOffset = this.getSizeAndPositionOfCell(middle).offset;\\n\\n        if (_currentOffset === offset) {\\n          return middle;\\n        } else if (_currentOffset < offset) {\\n          low = middle + 1;\\n        } else if (_currentOffset > offset) {\\n          high = middle - 1;\\n        }\\n      }\\n\\n      if (low > 0) {\\n        return low - 1;\\n      } else {\\n        return 0;\\n      }\\n    }\\n  }, {\\n    key: '_exponentialSearch',\\n    value: function _exponentialSearch(index, offset) {\\n      var interval = 1;\\n\\n      while (index < this._cellCount && this.getSizeAndPositionOfCell(index).offset < offset) {\\n        index += interval;\\n        interval *= 2;\\n      }\\n\\n      return this._binarySearch(Math.min(index, this._cellCount - 1), Math.floor(index / 2), offset);\\n    }\\n\\n    /**\\n     * Searches for the cell (index) nearest the specified offset.\\n     *\\n     * If no exact match is found the next lowest cell index will be returned.\\n     * This allows partially visible cells (with offsets just before/above the fold) to be visible.\\n     */\\n\\n  }, {\\n    key: '_findNearestCell',\\n    value: function _findNearestCell(offset) {\\n      if (isNaN(offset)) {\\n        throw Error('Invalid offset ' + offset + ' specified');\\n      }\\n\\n      // Our search algorithms find the nearest match at or below the specified offset.\\n      // So make sure the offset is at least 0 or no match will be found.\\n      offset = Math.max(0, offset);\\n\\n      var lastMeasuredCellSizeAndPosition = this.getSizeAndPositionOfLastMeasuredCell();\\n      var lastMeasuredIndex = Math.max(0, this._lastMeasuredIndex);\\n\\n      if (lastMeasuredCellSizeAndPosition.offset >= offset) {\\n        // If we've already measured cells within this range just use a binary search as it's faster.\\n        return this._binarySearch(lastMeasuredIndex, 0, offset);\\n      } else {\\n        // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\\n        // The exponential search avoids pre-computing sizes for the full set of cells as a binary search would.\\n        // The overall complexity for this approach is O(log n).\\n        return this._exponentialSearch(lastMeasuredIndex, offset);\\n      }\\n    }\\n  }]);\\n  return CellSizeAndPositionManager;\\n}();\\n\\nexports.default = CellSizeAndPositionManager;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"process\",\"require\",\"module\",\"exports\",\"shadow$shims\",\"Object\",\"defineProperty\",\"value\",\"_classCallCheck3\",\"_classCallCheck2\",\"__esModule\",\"default\",\"_createClass3\",\"_createClass2\",\"CellSizeAndPositionManager\",\"_ref\",\"cellCount\",\"cellSizeGetter\",\"estimatedCellSize\",\"_cellSizeAndPositionData\",\"_lastBatchedIndex\",\"_lastMeasuredIndex\",\"_cellSizeGetter\",\"_cellCount\",\"_estimatedCellSize\",\"key\",\"areOffsetsAdjusted\",\"configure\",\"_ref2\",\"getCellCount\",\"getEstimatedCellSize\",\"getLastMeasuredIndex\",\"getOffsetAdjustment\",\"getSizeAndPositionOfCell\",\"index\",\"Error\",\"lastMeasuredCellSizeAndPosition\",\"getSizeAndPositionOfLastMeasuredCell\",\"_offset\",\"offset\",\"size\",\"i\",\"_size\",\"undefined\",\"isNaN\",\"getTotalSize\",\"getUpdatedOffsetForIndex\",\"_ref3\",\"_ref3$align\",\"align\",\"containerSize\",\"currentOffset\",\"datum\",\"targetIndex\",\"maxOffset\",\"minOffset\",\"idealOffset\",\"Math\",\"max\",\"min\",\"totalSize\",\"getVisibleCellRange\",\"params\",\"start\",\"_findNearestCell\",\"stop\",\"resetCell\",\"_binarySearch\",\"high\",\"low\",\"middle\",\"floor\",\"_currentOffset\",\"_exponentialSearch\",\"interval\",\"lastMeasuredIndex\"]\n}\n"]