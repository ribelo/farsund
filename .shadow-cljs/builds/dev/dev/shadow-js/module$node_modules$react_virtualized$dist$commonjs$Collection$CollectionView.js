["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/react-virtualized/dist/commonjs/Collection/CollectionView.js"],"~:js","shadow$provide.module$node_modules$react_virtualized$dist$commonjs$Collection$CollectionView=function(global,process,require,module,exports,shadow$shims){function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}Object.defineProperty(exports,\"__esModule\",{value:!0});global=require(\"module$node_modules$babel_runtime$helpers$extends\");var _extends3=_interopRequireDefault(global);global=require(\"module$node_modules$babel_runtime$core_js$object$get_prototype_of\");var _getPrototypeOf2=\n_interopRequireDefault(global);global=require(\"module$node_modules$babel_runtime$helpers$classCallCheck\");var _classCallCheck3=_interopRequireDefault(global);global=require(\"module$node_modules$babel_runtime$helpers$createClass\");var _createClass3=_interopRequireDefault(global);global=require(\"module$node_modules$babel_runtime$helpers$possibleConstructorReturn\");var _possibleConstructorReturn3=_interopRequireDefault(global);global=require(\"module$node_modules$babel_runtime$helpers$inherits\");var _inherits3=\n_interopRequireDefault(global);global=require(\"module$node_modules$classnames$index\");var _classnames2=_interopRequireDefault(global);global=require(\"module$node_modules$prop_types$index\");global=_interopRequireDefault(global);var React=function(obj){if(obj&&obj.__esModule)return obj;var newObj={};if(null!=obj)for(var key in obj)Object.prototype.hasOwnProperty.call(obj,key)&&(newObj[key]=obj[key]);newObj.default=obj;return newObj}(require(\"module$node_modules$react$index\"));process=require(\"module$node_modules$react_lifecycles_compat$react_lifecycles_compat_cjs\");\nmodule=require(\"module$node_modules$react_virtualized$dist$commonjs$utils$createCallbackMemoizer\");var _createCallbackMemoizer2=_interopRequireDefault(module);require=require(\"module$node_modules$dom_helpers$util$scrollbarSize\");var _scrollbarSize2=_interopRequireDefault(require);require=function(_React$PureComponent){function CollectionView(){var _ref;(0,_classCallCheck3.default)(this,CollectionView);for(var _len=arguments.length,args=Array(_len),_key=0;_key<_len;_key++)args[_key]=arguments[_key];\nvar _this=(0,_possibleConstructorReturn3.default)(this,(_ref=CollectionView.__proto__||(0,_getPrototypeOf2.default)(CollectionView)).call.apply(_ref,[this].concat(args)));_this.state={isScrolling:!1,scrollLeft:0,scrollTop:0};_this._calculateSizeAndPositionDataOnNextUpdate=!1;_this._onSectionRenderedMemoizer=(0,_createCallbackMemoizer2.default)();_this._onScrollMemoizer=(0,_createCallbackMemoizer2.default)(!1);_this._invokeOnSectionRenderedHelper=function(){var _this$props=_this.props;_this._onSectionRenderedMemoizer({callback:_this$props.onSectionRendered,\nindices:{indices:_this$props.cellLayoutManager.getLastRenderedIndices()}})};_this._setScrollingContainerRef=function(ref){_this._scrollingContainer=ref};_this._updateScrollPositionForScrollToCell=function(){var _this$props2=_this.props,cellLayoutManager=_this$props2.cellLayoutManager,height=_this$props2.height,scrollToAlignment=_this$props2.scrollToAlignment,scrollToCell=_this$props2.scrollToCell,width=_this$props2.width,_this$state=_this.state;_this$props2=_this$state.scrollLeft;_this$state=_this$state.scrollTop;\n0<=scrollToCell&&(cellLayoutManager=cellLayoutManager.getScrollPositionForCell({align:scrollToAlignment,cellIndex:scrollToCell,height:height,scrollLeft:_this$props2,scrollTop:_this$state,width:width}),cellLayoutManager.scrollLeft===_this$props2&&cellLayoutManager.scrollTop===_this$state||_this._setScrollPosition(cellLayoutManager))};_this._onScroll=function(event){if(event.target===_this._scrollingContainer){_this._enablePointerEventsAfterDelay();var _this$props3=_this.props,height=_this$props3.height,\nisScrollingChange=_this$props3.isScrollingChange,width=_this$props3.width,scrollbarSize=_this._scrollbarSize,_cellLayoutManager$ge=_this$props3.cellLayoutManager.getTotalSize();_this$props3=_cellLayoutManager$ge.height;_cellLayoutManager$ge=_cellLayoutManager$ge.width;width=Math.max(0,Math.min(_cellLayoutManager$ge-width+scrollbarSize,event.target.scrollLeft));height=Math.max(0,Math.min(_this$props3-height+scrollbarSize,event.target.scrollTop));if(_this.state.scrollLeft!==width||_this.state.scrollTop!==\nheight)event=event.cancelable?\"observed\":\"requested\",_this.state.isScrolling||isScrollingChange(!0),_this.setState({isScrolling:!0,scrollLeft:width,scrollPositionChangeReason:event,scrollTop:height});_this._invokeOnScrollMemoizer({scrollLeft:width,scrollTop:height,totalWidth:_cellLayoutManager$ge,totalHeight:_this$props3})}};_this._scrollbarSize=(0,_scrollbarSize2.default)();void 0===_this._scrollbarSize?(_this._scrollbarSizeMeasured=!1,_this._scrollbarSize=0):_this._scrollbarSizeMeasured=!0;return _this}\n(0,_inherits3.default)(CollectionView,_React$PureComponent);(0,_createClass3.default)(CollectionView,[{key:\"recomputeCellSizesAndPositions\",value:function(){this._calculateSizeAndPositionDataOnNextUpdate=!0;this.forceUpdate()}},{key:\"componentDidMount\",value:function(){var _props=this.props,cellLayoutManager=_props.cellLayoutManager,scrollLeft=_props.scrollLeft,scrollToCell=_props.scrollToCell;_props=_props.scrollTop;this._scrollbarSizeMeasured||(this._scrollbarSize=(0,_scrollbarSize2.default)(),\nthis._scrollbarSizeMeasured=!0,this.setState({}));0<=scrollToCell?this._updateScrollPositionForScrollToCell():(0<=scrollLeft||0<=_props)&&this._setScrollPosition({scrollLeft:scrollLeft,scrollTop:_props});this._invokeOnSectionRenderedHelper();cellLayoutManager=cellLayoutManager.getTotalSize();this._invokeOnScrollMemoizer({scrollLeft:scrollLeft||0,scrollTop:_props||0,totalHeight:cellLayoutManager.height,totalWidth:cellLayoutManager.width})}},{key:\"componentDidUpdate\",value:function(prevProps,prevState){var _props2=\nthis.props,height=_props2.height,scrollToAlignment=_props2.scrollToAlignment,scrollToCell=_props2.scrollToCell;_props2=_props2.width;var _state=this.state,scrollLeft=_state.scrollLeft,scrollTop=_state.scrollTop;\"requested\"===_state.scrollPositionChangeReason&&(0<=scrollLeft&&scrollLeft!==prevState.scrollLeft&&scrollLeft!==this._scrollingContainer.scrollLeft&&(this._scrollingContainer.scrollLeft=scrollLeft),0<=scrollTop&&scrollTop!==prevState.scrollTop&&scrollTop!==this._scrollingContainer.scrollTop&&\n(this._scrollingContainer.scrollTop=scrollTop));height===prevProps.height&&scrollToAlignment===prevProps.scrollToAlignment&&scrollToCell===prevProps.scrollToCell&&_props2===prevProps.width||this._updateScrollPositionForScrollToCell();this._invokeOnSectionRenderedHelper()}},{key:\"componentWillUnmount\",value:function(){this._disablePointerEventsTimeoutId&&clearTimeout(this._disablePointerEventsTimeoutId)}},{key:\"render\",value:function(){var _props3=this.props,autoHeight=_props3.autoHeight,cellCount=\n_props3.cellCount,cellLayoutManager=_props3.cellLayoutManager,className=_props3.className,height=_props3.height,horizontalOverscanSize=_props3.horizontalOverscanSize,id=_props3.id,noContentRenderer=_props3.noContentRenderer,style=_props3.style,verticalOverscanSize=_props3.verticalOverscanSize;_props3=_props3.width;var _state2=this.state,isScrolling=_state2.isScrolling,scrollLeft=_state2.scrollLeft,scrollTop=_state2.scrollTop;if(this._lastRenderedCellCount!==cellCount||this._lastRenderedCellLayoutManager!==\ncellLayoutManager||this._calculateSizeAndPositionDataOnNextUpdate)this._lastRenderedCellCount=cellCount,this._lastRenderedCellLayoutManager=cellLayoutManager,this._calculateSizeAndPositionDataOnNextUpdate=!1,cellLayoutManager.calculateSizeAndPositionData();var _cellLayoutManager$ge3=cellLayoutManager.getTotalSize();_state2=_cellLayoutManager$ge3.height;_cellLayoutManager$ge3=_cellLayoutManager$ge3.width;var left=Math.max(0,scrollLeft-horizontalOverscanSize),top=Math.max(0,scrollTop-verticalOverscanSize);\nhorizontalOverscanSize=Math.min(_cellLayoutManager$ge3,scrollLeft+_props3+horizontalOverscanSize);verticalOverscanSize=Math.min(_state2,scrollTop+height+verticalOverscanSize);cellLayoutManager=0<height&&0<_props3?cellLayoutManager.cellRenderers({height:verticalOverscanSize-top,isScrolling:isScrolling,width:horizontalOverscanSize-left,x:left,y:top}):[];autoHeight={boxSizing:\"border-box\",direction:\"ltr\",height:autoHeight?\"auto\":height,position:\"relative\",WebkitOverflowScrolling:\"touch\",width:_props3,\nwillChange:\"transform\"};verticalOverscanSize=_cellLayoutManager$ge3>_props3?this._scrollbarSize:0;autoHeight.overflowX=_cellLayoutManager$ge3+(_state2>height?this._scrollbarSize:0)<=_props3?\"hidden\":\"auto\";autoHeight.overflowY=_state2+verticalOverscanSize<=height?\"hidden\":\"auto\";return React.createElement(\"div\",{ref:this._setScrollingContainerRef,\"aria-label\":this.props[\"aria-label\"],className:(0,_classnames2.default)(\"ReactVirtualized__Collection\",className),id:id,onScroll:this._onScroll,role:\"grid\",\nstyle:(0,_extends3.default)({},autoHeight,style),tabIndex:0},0<cellCount&&React.createElement(\"div\",{className:\"ReactVirtualized__Collection__innerScrollContainer\",style:{height:_state2,maxHeight:_state2,maxWidth:_cellLayoutManager$ge3,overflow:\"hidden\",pointerEvents:isScrolling?\"none\":\"\",width:_cellLayoutManager$ge3}},cellLayoutManager),0===cellCount&&noContentRenderer())}},{key:\"_enablePointerEventsAfterDelay\",value:function(){var _this2=this;this._disablePointerEventsTimeoutId&&clearTimeout(this._disablePointerEventsTimeoutId);\nthis._disablePointerEventsTimeoutId=setTimeout(function(){var isScrollingChange=_this2.props.isScrollingChange;isScrollingChange(!1);_this2._disablePointerEventsTimeoutId=null;_this2.setState({isScrolling:!1})},150)}},{key:\"_invokeOnScrollMemoizer\",value:function(_ref2){var _this3=this,totalHeight=_ref2.totalHeight,totalWidth=_ref2.totalWidth;this._onScrollMemoizer({callback:function(_ref3){var _props4=_this3.props,onScroll=_props4.onScroll;onScroll({clientHeight:_props4.height,clientWidth:_props4.width,\nscrollHeight:totalHeight,scrollLeft:_ref3.scrollLeft,scrollTop:_ref3.scrollTop,scrollWidth:totalWidth})},indices:{scrollLeft:_ref2.scrollLeft,scrollTop:_ref2.scrollTop}})}},{key:\"_setScrollPosition\",value:function(_ref4){var scrollLeft=_ref4.scrollLeft;_ref4=_ref4.scrollTop;var newState={scrollPositionChangeReason:\"requested\"};0<=scrollLeft&&(newState.scrollLeft=scrollLeft);0<=_ref4&&(newState.scrollTop=_ref4);(0<=scrollLeft&&scrollLeft!==this.state.scrollLeft||0<=_ref4&&_ref4!==this.state.scrollTop)&&\nthis.setState(newState)}}],[{key:\"getDerivedStateFromProps\",value:function(nextProps,prevState){return 0!==nextProps.cellCount||0===prevState.scrollLeft&&0===prevState.scrollTop?nextProps.scrollLeft!==prevState.scrollLeft||nextProps.scrollTop!==prevState.scrollTop?{scrollLeft:null!=nextProps.scrollLeft?nextProps.scrollLeft:prevState.scrollLeft,scrollTop:null!=nextProps.scrollTop?nextProps.scrollTop:prevState.scrollTop}:null:{scrollLeft:0,scrollTop:0}}}]);return CollectionView}(React.PureComponent);\nrequire.defaultProps={\"aria-label\":\"grid\",horizontalOverscanSize:0,noContentRenderer:function(){return null},onScroll:function(){return null},onSectionRendered:function(){return null},scrollToAlignment:\"auto\",scrollToCell:-1,style:{},verticalOverscanSize:0};require.propTypes={\"aria-label\":global.default.string,autoHeight:global.default.bool,cellCount:global.default.number.isRequired,cellLayoutManager:global.default.object.isRequired,className:global.default.string,height:global.default.number.isRequired,\nid:global.default.string,horizontalOverscanSize:global.default.number.isRequired,isScrollingChange:global.default.func,noContentRenderer:global.default.func.isRequired,onScroll:global.default.func.isRequired,onSectionRendered:global.default.func.isRequired,scrollLeft:global.default.number,scrollToAlignment:global.default.oneOf([\"auto\",\"end\",\"start\",\"center\"]).isRequired,scrollToCell:global.default.number.isRequired,scrollTop:global.default.number,style:global.default.object,verticalOverscanSize:global.default.number.isRequired,\nwidth:global.default.number.isRequired};(0,process.polyfill)(require);exports.default=require}","~:source","shadow$provide[\"module$node_modules$react_virtualized$dist$commonjs$Collection$CollectionView\"] = function(global,process,require,module,exports,shadow$shims) {\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends2 = require('babel-runtime/helpers/extends');\n\nvar _extends3 = _interopRequireDefault(_extends2);\n\nvar _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = require('babel-runtime/helpers/inherits');\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _classnames = require('classnames');\n\nvar _classnames2 = _interopRequireDefault(_classnames);\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _react = require('react');\n\nvar React = _interopRequireWildcard(_react);\n\nvar _reactLifecyclesCompat = require('react-lifecycles-compat');\n\nvar _createCallbackMemoizer = require('../utils/createCallbackMemoizer');\n\nvar _createCallbackMemoizer2 = _interopRequireDefault(_createCallbackMemoizer);\n\nvar _scrollbarSize = require('dom-helpers/util/scrollbarSize');\n\nvar _scrollbarSize2 = _interopRequireDefault(_scrollbarSize);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// @TODO Merge Collection and CollectionView\n\n/**\n * Specifies the number of milliseconds during which to disable pointer events while a scroll is in progress.\n * This improves performance and makes scrolling smoother.\n */\nvar IS_SCROLLING_TIMEOUT = 150;\n\n/**\n * Controls whether the Grid updates the DOM element's scrollLeft/scrollTop based on the current state or just observes it.\n * This prevents Grid from interrupting mouse-wheel animations (see issue #2).\n */\nvar SCROLL_POSITION_CHANGE_REASONS = {\n  OBSERVED: 'observed',\n  REQUESTED: 'requested'\n};\n\n/**\n * Monitors changes in properties (eg. cellCount) and state (eg. scroll offsets) to determine when rendering needs to occur.\n * This component does not render any visible content itself; it defers to the specified :cellLayoutManager.\n */\n\nvar CollectionView = function (_React$PureComponent) {\n  (0, _inherits3.default)(CollectionView, _React$PureComponent);\n\n  // Invokes callbacks only when their values have changed.\n  function CollectionView() {\n    var _ref;\n\n    (0, _classCallCheck3.default)(this, CollectionView);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    // If this component is being rendered server-side, getScrollbarSize() will return undefined.\n    // We handle this case in componentDidMount()\n    var _this = (0, _possibleConstructorReturn3.default)(this, (_ref = CollectionView.__proto__ || (0, _getPrototypeOf2.default)(CollectionView)).call.apply(_ref, [this].concat(args)));\n\n    _this.state = {\n      isScrolling: false,\n      scrollLeft: 0,\n      scrollTop: 0\n    };\n    _this._calculateSizeAndPositionDataOnNextUpdate = false;\n    _this._onSectionRenderedMemoizer = (0, _createCallbackMemoizer2.default)();\n    _this._onScrollMemoizer = (0, _createCallbackMemoizer2.default)(false);\n\n    _this._invokeOnSectionRenderedHelper = function () {\n      var _this$props = _this.props,\n          cellLayoutManager = _this$props.cellLayoutManager,\n          onSectionRendered = _this$props.onSectionRendered;\n\n\n      _this._onSectionRenderedMemoizer({\n        callback: onSectionRendered,\n        indices: {\n          indices: cellLayoutManager.getLastRenderedIndices()\n        }\n      });\n    };\n\n    _this._setScrollingContainerRef = function (ref) {\n      _this._scrollingContainer = ref;\n    };\n\n    _this._updateScrollPositionForScrollToCell = function () {\n      var _this$props2 = _this.props,\n          cellLayoutManager = _this$props2.cellLayoutManager,\n          height = _this$props2.height,\n          scrollToAlignment = _this$props2.scrollToAlignment,\n          scrollToCell = _this$props2.scrollToCell,\n          width = _this$props2.width;\n      var _this$state = _this.state,\n          scrollLeft = _this$state.scrollLeft,\n          scrollTop = _this$state.scrollTop;\n\n\n      if (scrollToCell >= 0) {\n        var scrollPosition = cellLayoutManager.getScrollPositionForCell({\n          align: scrollToAlignment,\n          cellIndex: scrollToCell,\n          height: height,\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          width: width\n        });\n\n        if (scrollPosition.scrollLeft !== scrollLeft || scrollPosition.scrollTop !== scrollTop) {\n          _this._setScrollPosition(scrollPosition);\n        }\n      }\n    };\n\n    _this._onScroll = function (event) {\n      // In certain edge-cases React dispatches an onScroll event with an invalid target.scrollLeft / target.scrollTop.\n      // This invalid event can be detected by comparing event.target to this component's scrollable DOM element.\n      // See issue #404 for more information.\n      if (event.target !== _this._scrollingContainer) {\n        return;\n      }\n\n      // Prevent pointer events from interrupting a smooth scroll\n      _this._enablePointerEventsAfterDelay();\n\n      // When this component is shrunk drastically, React dispatches a series of back-to-back scroll events,\n      // Gradually converging on a scrollTop that is within the bounds of the new, smaller height.\n      // This causes a series of rapid renders that is slow for long lists.\n      // We can avoid that by doing some simple bounds checking to ensure that scrollTop never exceeds the total height.\n      var _this$props3 = _this.props,\n          cellLayoutManager = _this$props3.cellLayoutManager,\n          height = _this$props3.height,\n          isScrollingChange = _this$props3.isScrollingChange,\n          width = _this$props3.width;\n\n      var scrollbarSize = _this._scrollbarSize;\n\n      var _cellLayoutManager$ge = cellLayoutManager.getTotalSize(),\n          totalHeight = _cellLayoutManager$ge.height,\n          totalWidth = _cellLayoutManager$ge.width;\n\n      var scrollLeft = Math.max(0, Math.min(totalWidth - width + scrollbarSize, event.target.scrollLeft));\n      var scrollTop = Math.max(0, Math.min(totalHeight - height + scrollbarSize, event.target.scrollTop));\n\n      // Certain devices (like Apple touchpad) rapid-fire duplicate events.\n      // Don't force a re-render if this is the case.\n      // The mouse may move faster then the animation frame does.\n      // Use requestAnimationFrame to avoid over-updating.\n      if (_this.state.scrollLeft !== scrollLeft || _this.state.scrollTop !== scrollTop) {\n        // Browsers with cancelable scroll events (eg. Firefox) interrupt scrolling animations if scrollTop/scrollLeft is set.\n        // Other browsers (eg. Safari) don't scroll as well without the help under certain conditions (DOM or style changes during scrolling).\n        // All things considered, this seems to be the best current work around that I'm aware of.\n        // For more information see https://github.com/bvaughn/react-virtualized/pull/124\n        var scrollPositionChangeReason = event.cancelable ? SCROLL_POSITION_CHANGE_REASONS.OBSERVED : SCROLL_POSITION_CHANGE_REASONS.REQUESTED;\n\n        // Synchronously set :isScrolling the first time (since _setNextState will reschedule its animation frame each time it's called)\n        if (!_this.state.isScrolling) {\n          isScrollingChange(true);\n        }\n\n        _this.setState({\n          isScrolling: true,\n          scrollLeft: scrollLeft,\n          scrollPositionChangeReason: scrollPositionChangeReason,\n          scrollTop: scrollTop\n        });\n      }\n\n      _this._invokeOnScrollMemoizer({\n        scrollLeft: scrollLeft,\n        scrollTop: scrollTop,\n        totalWidth: totalWidth,\n        totalHeight: totalHeight\n      });\n    };\n\n    _this._scrollbarSize = (0, _scrollbarSize2.default)();\n    if (_this._scrollbarSize === undefined) {\n      _this._scrollbarSizeMeasured = false;\n      _this._scrollbarSize = 0;\n    } else {\n      _this._scrollbarSizeMeasured = true;\n    }\n    return _this;\n  }\n\n  /**\n   * Forced recompute of cell sizes and positions.\n   * This function should be called if cell sizes have changed but nothing else has.\n   * Since cell positions are calculated by callbacks, the collection view has no way of detecting when the underlying data has changed.\n   */\n\n\n  (0, _createClass3.default)(CollectionView, [{\n    key: 'recomputeCellSizesAndPositions',\n    value: function recomputeCellSizesAndPositions() {\n      this._calculateSizeAndPositionDataOnNextUpdate = true;\n      this.forceUpdate();\n    }\n\n    /* ---------------------------- Component lifecycle methods ---------------------------- */\n\n    /**\n     * @private\n     * This method updates scrollLeft/scrollTop in state for the following conditions:\n     * 1) Empty content (0 rows or columns)\n     * 2) New scroll props overriding the current state\n     * 3) Cells-count or cells-size has changed, making previous scroll offsets invalid\n     */\n\n  }, {\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      var _props = this.props,\n          cellLayoutManager = _props.cellLayoutManager,\n          scrollLeft = _props.scrollLeft,\n          scrollToCell = _props.scrollToCell,\n          scrollTop = _props.scrollTop;\n\n      // If this component was first rendered server-side, scrollbar size will be undefined.\n      // In that event we need to remeasure.\n\n      if (!this._scrollbarSizeMeasured) {\n        this._scrollbarSize = (0, _scrollbarSize2.default)();\n        this._scrollbarSizeMeasured = true;\n        this.setState({});\n      }\n\n      if (scrollToCell >= 0) {\n        this._updateScrollPositionForScrollToCell();\n      } else if (scrollLeft >= 0 || scrollTop >= 0) {\n        this._setScrollPosition({ scrollLeft: scrollLeft, scrollTop: scrollTop });\n      }\n\n      // Update onSectionRendered callback.\n      this._invokeOnSectionRenderedHelper();\n\n      var _cellLayoutManager$ge2 = cellLayoutManager.getTotalSize(),\n          totalHeight = _cellLayoutManager$ge2.height,\n          totalWidth = _cellLayoutManager$ge2.width;\n\n      // Initialize onScroll callback.\n\n\n      this._invokeOnScrollMemoizer({\n        scrollLeft: scrollLeft || 0,\n        scrollTop: scrollTop || 0,\n        totalHeight: totalHeight,\n        totalWidth: totalWidth\n      });\n    }\n  }, {\n    key: 'componentDidUpdate',\n    value: function componentDidUpdate(prevProps, prevState) {\n      var _props2 = this.props,\n          height = _props2.height,\n          scrollToAlignment = _props2.scrollToAlignment,\n          scrollToCell = _props2.scrollToCell,\n          width = _props2.width;\n      var _state = this.state,\n          scrollLeft = _state.scrollLeft,\n          scrollPositionChangeReason = _state.scrollPositionChangeReason,\n          scrollTop = _state.scrollTop;\n\n      // Make sure requested changes to :scrollLeft or :scrollTop get applied.\n      // Assigning to scrollLeft/scrollTop tells the browser to interrupt any running scroll animations,\n      // And to discard any pending async changes to the scroll position that may have happened in the meantime (e.g. on a separate scrolling thread).\n      // So we only set these when we require an adjustment of the scroll position.\n      // See issue #2 for more information.\n\n      if (scrollPositionChangeReason === SCROLL_POSITION_CHANGE_REASONS.REQUESTED) {\n        if (scrollLeft >= 0 && scrollLeft !== prevState.scrollLeft && scrollLeft !== this._scrollingContainer.scrollLeft) {\n          this._scrollingContainer.scrollLeft = scrollLeft;\n        }\n        if (scrollTop >= 0 && scrollTop !== prevState.scrollTop && scrollTop !== this._scrollingContainer.scrollTop) {\n          this._scrollingContainer.scrollTop = scrollTop;\n        }\n      }\n\n      // Update scroll offsets if the current :scrollToCell values requires it\n      if (height !== prevProps.height || scrollToAlignment !== prevProps.scrollToAlignment || scrollToCell !== prevProps.scrollToCell || width !== prevProps.width) {\n        this._updateScrollPositionForScrollToCell();\n      }\n\n      // Update onRowsRendered callback if start/stop indices have changed\n      this._invokeOnSectionRenderedHelper();\n    }\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      if (this._disablePointerEventsTimeoutId) {\n        clearTimeout(this._disablePointerEventsTimeoutId);\n      }\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _props3 = this.props,\n          autoHeight = _props3.autoHeight,\n          cellCount = _props3.cellCount,\n          cellLayoutManager = _props3.cellLayoutManager,\n          className = _props3.className,\n          height = _props3.height,\n          horizontalOverscanSize = _props3.horizontalOverscanSize,\n          id = _props3.id,\n          noContentRenderer = _props3.noContentRenderer,\n          style = _props3.style,\n          verticalOverscanSize = _props3.verticalOverscanSize,\n          width = _props3.width;\n      var _state2 = this.state,\n          isScrolling = _state2.isScrolling,\n          scrollLeft = _state2.scrollLeft,\n          scrollTop = _state2.scrollTop;\n\n      // Memoization reset\n\n      if (this._lastRenderedCellCount !== cellCount || this._lastRenderedCellLayoutManager !== cellLayoutManager || this._calculateSizeAndPositionDataOnNextUpdate) {\n        this._lastRenderedCellCount = cellCount;\n        this._lastRenderedCellLayoutManager = cellLayoutManager;\n        this._calculateSizeAndPositionDataOnNextUpdate = false;\n\n        cellLayoutManager.calculateSizeAndPositionData();\n      }\n\n      var _cellLayoutManager$ge3 = cellLayoutManager.getTotalSize(),\n          totalHeight = _cellLayoutManager$ge3.height,\n          totalWidth = _cellLayoutManager$ge3.width;\n\n      // Safely expand the rendered area by the specified overscan amount\n\n\n      var left = Math.max(0, scrollLeft - horizontalOverscanSize);\n      var top = Math.max(0, scrollTop - verticalOverscanSize);\n      var right = Math.min(totalWidth, scrollLeft + width + horizontalOverscanSize);\n      var bottom = Math.min(totalHeight, scrollTop + height + verticalOverscanSize);\n\n      var childrenToDisplay = height > 0 && width > 0 ? cellLayoutManager.cellRenderers({\n        height: bottom - top,\n        isScrolling: isScrolling,\n        width: right - left,\n        x: left,\n        y: top\n      }) : [];\n\n      var collectionStyle = {\n        boxSizing: 'border-box',\n        direction: 'ltr',\n        height: autoHeight ? 'auto' : height,\n        position: 'relative',\n        WebkitOverflowScrolling: 'touch',\n        width: width,\n        willChange: 'transform'\n      };\n\n      // Force browser to hide scrollbars when we know they aren't necessary.\n      // Otherwise once scrollbars appear they may not disappear again.\n      // For more info see issue #116\n      var verticalScrollBarSize = totalHeight > height ? this._scrollbarSize : 0;\n      var horizontalScrollBarSize = totalWidth > width ? this._scrollbarSize : 0;\n\n      // Also explicitly init styles to 'auto' if scrollbars are required.\n      // This works around an obscure edge case where external CSS styles have not yet been loaded,\n      // But an initial scroll index of offset is set as an external prop.\n      // Without this style, Grid would render the correct range of cells but would NOT update its internal offset.\n      // This was originally reported via clauderic/react-infinite-calendar/issues/23\n      collectionStyle.overflowX = totalWidth + verticalScrollBarSize <= width ? 'hidden' : 'auto';\n      collectionStyle.overflowY = totalHeight + horizontalScrollBarSize <= height ? 'hidden' : 'auto';\n\n      return React.createElement(\n        'div',\n        {\n          ref: this._setScrollingContainerRef,\n          'aria-label': this.props['aria-label'],\n          className: (0, _classnames2.default)('ReactVirtualized__Collection', className),\n          id: id,\n          onScroll: this._onScroll,\n          role: 'grid',\n          style: (0, _extends3.default)({}, collectionStyle, style),\n          tabIndex: 0 },\n        cellCount > 0 && React.createElement(\n          'div',\n          {\n            className: 'ReactVirtualized__Collection__innerScrollContainer',\n            style: {\n              height: totalHeight,\n              maxHeight: totalHeight,\n              maxWidth: totalWidth,\n              overflow: 'hidden',\n              pointerEvents: isScrolling ? 'none' : '',\n              width: totalWidth\n            } },\n          childrenToDisplay\n        ),\n        cellCount === 0 && noContentRenderer()\n      );\n    }\n\n    /* ---------------------------- Helper methods ---------------------------- */\n\n    /**\n     * Sets an :isScrolling flag for a small window of time.\n     * This flag is used to disable pointer events on the scrollable portion of the Collection.\n     * This prevents jerky/stuttery mouse-wheel scrolling.\n     */\n\n  }, {\n    key: '_enablePointerEventsAfterDelay',\n    value: function _enablePointerEventsAfterDelay() {\n      var _this2 = this;\n\n      if (this._disablePointerEventsTimeoutId) {\n        clearTimeout(this._disablePointerEventsTimeoutId);\n      }\n\n      this._disablePointerEventsTimeoutId = setTimeout(function () {\n        var isScrollingChange = _this2.props.isScrollingChange;\n\n\n        isScrollingChange(false);\n\n        _this2._disablePointerEventsTimeoutId = null;\n        _this2.setState({\n          isScrolling: false\n        });\n      }, IS_SCROLLING_TIMEOUT);\n    }\n  }, {\n    key: '_invokeOnScrollMemoizer',\n    value: function _invokeOnScrollMemoizer(_ref2) {\n      var _this3 = this;\n\n      var scrollLeft = _ref2.scrollLeft,\n          scrollTop = _ref2.scrollTop,\n          totalHeight = _ref2.totalHeight,\n          totalWidth = _ref2.totalWidth;\n\n      this._onScrollMemoizer({\n        callback: function callback(_ref3) {\n          var scrollLeft = _ref3.scrollLeft,\n              scrollTop = _ref3.scrollTop;\n          var _props4 = _this3.props,\n              height = _props4.height,\n              onScroll = _props4.onScroll,\n              width = _props4.width;\n\n\n          onScroll({\n            clientHeight: height,\n            clientWidth: width,\n            scrollHeight: totalHeight,\n            scrollLeft: scrollLeft,\n            scrollTop: scrollTop,\n            scrollWidth: totalWidth\n          });\n        },\n        indices: {\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop\n        }\n      });\n    }\n  }, {\n    key: '_setScrollPosition',\n    value: function _setScrollPosition(_ref4) {\n      var scrollLeft = _ref4.scrollLeft,\n          scrollTop = _ref4.scrollTop;\n\n      var newState = {\n        scrollPositionChangeReason: SCROLL_POSITION_CHANGE_REASONS.REQUESTED\n      };\n\n      if (scrollLeft >= 0) {\n        newState.scrollLeft = scrollLeft;\n      }\n\n      if (scrollTop >= 0) {\n        newState.scrollTop = scrollTop;\n      }\n\n      if (scrollLeft >= 0 && scrollLeft !== this.state.scrollLeft || scrollTop >= 0 && scrollTop !== this.state.scrollTop) {\n        this.setState(newState);\n      }\n    }\n  }], [{\n    key: 'getDerivedStateFromProps',\n    value: function getDerivedStateFromProps(nextProps, prevState) {\n      if (nextProps.cellCount === 0 && (prevState.scrollLeft !== 0 || prevState.scrollTop !== 0)) {\n        return {\n          scrollLeft: 0,\n          scrollTop: 0\n        };\n      } else if (nextProps.scrollLeft !== prevState.scrollLeft || nextProps.scrollTop !== prevState.scrollTop) {\n        return {\n          scrollLeft: nextProps.scrollLeft != null ? nextProps.scrollLeft : prevState.scrollLeft,\n          scrollTop: nextProps.scrollTop != null ? nextProps.scrollTop : prevState.scrollTop\n        };\n      }\n\n      return null;\n    }\n  }]);\n  return CollectionView;\n}(React.PureComponent);\n\nCollectionView.defaultProps = {\n  'aria-label': 'grid',\n  horizontalOverscanSize: 0,\n  noContentRenderer: function noContentRenderer() {\n    return null;\n  },\n  onScroll: function onScroll() {\n    return null;\n  },\n  onSectionRendered: function onSectionRendered() {\n    return null;\n  },\n  scrollToAlignment: 'auto',\n  scrollToCell: -1,\n  style: {},\n  verticalOverscanSize: 0\n};\nCollectionView.propTypes = process.env.NODE_ENV !== \"production\" ? {\n  'aria-label': _propTypes2.default.string,\n\n  /**\n   * Removes fixed height from the scrollingContainer so that the total height\n   * of rows can stretch the window. Intended for use with WindowScroller\n   */\n  autoHeight: _propTypes2.default.bool,\n\n  /**\n   * Number of cells in collection.\n   */\n  cellCount: _propTypes2.default.number.isRequired,\n\n  /**\n   * Calculates cell sizes and positions and manages rendering the appropriate cells given a specified window.\n   */\n  cellLayoutManager: _propTypes2.default.object.isRequired,\n\n  /**\n   * Optional custom CSS class name to attach to root Collection element.\n   */\n  className: _propTypes2.default.string,\n\n  /**\n   * Height of Collection; this property determines the number of visible (vs virtualized) rows.\n   */\n  height: _propTypes2.default.number.isRequired,\n\n  /**\n   * Optional custom id to attach to root Collection element.\n   */\n  id: _propTypes2.default.string,\n\n  /**\n   * Enables the `Collection` to horiontally \"overscan\" its content similar to how `Grid` does.\n   * This can reduce flicker around the edges when a user scrolls quickly.\n   */\n  horizontalOverscanSize: _propTypes2.default.number.isRequired,\n\n  isScrollingChange: _propTypes2.default.func,\n\n  /**\n   * Optional renderer to be used in place of rows when either :rowCount or :cellCount is 0.\n   */\n  noContentRenderer: _propTypes2.default.func.isRequired,\n\n  /**\n   * Callback invoked whenever the scroll offset changes within the inner scrollable region.\n   * This callback can be used to sync scrolling between lists, tables, or grids.\n   * ({ clientHeight, clientWidth, scrollHeight, scrollLeft, scrollTop, scrollWidth }): void\n   */\n  onScroll: _propTypes2.default.func.isRequired,\n\n  /**\n   * Callback invoked with information about the section of the Collection that was just rendered.\n   * This callback is passed a named :indices parameter which is an Array of the most recently rendered section indices.\n   */\n  onSectionRendered: _propTypes2.default.func.isRequired,\n\n  /**\n   * Horizontal offset.\n   */\n  scrollLeft: _propTypes2.default.number,\n\n  /**\n   * Controls scroll-to-cell behavior of the Grid.\n   * The default (\"auto\") scrolls the least amount possible to ensure that the specified cell is fully visible.\n   * Use \"start\" to align cells to the top/left of the Grid and \"end\" to align bottom/right.\n   */\n  scrollToAlignment: _propTypes2.default.oneOf(['auto', 'end', 'start', 'center']).isRequired,\n\n  /**\n   * Cell index to ensure visible (by forcefully scrolling if necessary).\n   */\n  scrollToCell: _propTypes2.default.number.isRequired,\n\n  /**\n   * Vertical offset.\n   */\n  scrollTop: _propTypes2.default.number,\n\n  /**\n   * Optional custom inline style to attach to root Collection element.\n   */\n  style: _propTypes2.default.object,\n\n  /**\n   * Enables the `Collection` to vertically \"overscan\" its content similar to how `Grid` does.\n   * This can reduce flicker around the edges when a user scrolls quickly.\n   */\n  verticalOverscanSize: _propTypes2.default.number.isRequired,\n\n  /**\n   * Width of Collection; this property determines the number of visible (vs virtualized) columns.\n   */\n  width: _propTypes2.default.number.isRequired\n} : {};\n\n\n(0, _reactLifecyclesCompat.polyfill)(CollectionView);\n\nexports.default = CollectionView;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$react_virtualized$dist$commonjs$utils$createCallbackMemoizer","~$module$node_modules$react_lifecycles_compat$react_lifecycles_compat_cjs","~$module$node_modules$babel_runtime$helpers$possibleConstructorReturn","~$module$node_modules$react$index","~$module$node_modules$prop_types$index","~$shadow.js","~$module$node_modules$babel_runtime$helpers$inherits","~$module$node_modules$babel_runtime$core_js$object$get_prototype_of","~$module$node_modules$classnames$index","~$module$node_modules$dom_helpers$util$scrollbarSize","~$module$node_modules$babel_runtime$helpers$extends","~$module$node_modules$babel_runtime$helpers$classCallCheck","~$module$node_modules$babel_runtime$helpers$createClass"]],"~:properties",["^5",["scrollWidth","overflowX","callback","role","width","scrollPositionChangeReason","align","autoHeight","clientHeight","cellLayoutManager","_scrollbarSizeMeasured","height","tabIndex","overflowY","_setScrollingContainerRef","willChange","scrollLeft","className","key","scrollToAlignment","x","__esModule","isScrolling","id","maxHeight","propTypes","position","_lastRenderedCellCount","style","value","scrollToCell","_lastRenderedCellLayoutManager","boxSizing","direction","_onScroll","_updateScrollPositionForScrollToCell","_calculateSizeAndPositionDataOnNextUpdate","_onSectionRenderedMemoizer","onSectionRendered","defaultProps","isScrollingChange","clientWidth","_onScrollMemoizer","overflow","cellCount","y","verticalOverscanSize","_invokeOnSectionRenderedHelper","state","ref","totalHeight","horizontalOverscanSize","_scrollingContainer","_disablePointerEventsTimeoutId","maxWidth","totalWidth","onScroll","_scrollbarSize","scrollTop","scrollHeight","noContentRenderer","default","WebkitOverflowScrolling","pointerEvents","cellIndex","indices"]],"~:compiled-at",1537791607674,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$react_virtualized$dist$commonjs$Collection$CollectionView.js\",\n\"lineCount\":24,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/react-virtualized/dist/commonjs/Collection/CollectionView.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$react_virtualized$dist$commonjs$Collection$CollectionView\\\"] = function(global,process,require,module,exports,shadow$shims) {\\n'use strict';\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\n\\nvar _extends2 = require('babel-runtime/helpers/extends');\\n\\nvar _extends3 = _interopRequireDefault(_extends2);\\n\\nvar _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');\\n\\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\\n\\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\\n\\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\\n\\nvar _createClass2 = require('babel-runtime/helpers/createClass');\\n\\nvar _createClass3 = _interopRequireDefault(_createClass2);\\n\\nvar _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');\\n\\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\\n\\nvar _inherits2 = require('babel-runtime/helpers/inherits');\\n\\nvar _inherits3 = _interopRequireDefault(_inherits2);\\n\\nvar _classnames = require('classnames');\\n\\nvar _classnames2 = _interopRequireDefault(_classnames);\\n\\nvar _propTypes = require('prop-types');\\n\\nvar _propTypes2 = _interopRequireDefault(_propTypes);\\n\\nvar _react = require('react');\\n\\nvar React = _interopRequireWildcard(_react);\\n\\nvar _reactLifecyclesCompat = require('react-lifecycles-compat');\\n\\nvar _createCallbackMemoizer = require('../utils/createCallbackMemoizer');\\n\\nvar _createCallbackMemoizer2 = _interopRequireDefault(_createCallbackMemoizer);\\n\\nvar _scrollbarSize = require('dom-helpers/util/scrollbarSize');\\n\\nvar _scrollbarSize2 = _interopRequireDefault(_scrollbarSize);\\n\\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\\n\\n// @TODO Merge Collection and CollectionView\\n\\n/**\\n * Specifies the number of milliseconds during which to disable pointer events while a scroll is in progress.\\n * This improves performance and makes scrolling smoother.\\n */\\nvar IS_SCROLLING_TIMEOUT = 150;\\n\\n/**\\n * Controls whether the Grid updates the DOM element's scrollLeft/scrollTop based on the current state or just observes it.\\n * This prevents Grid from interrupting mouse-wheel animations (see issue #2).\\n */\\nvar SCROLL_POSITION_CHANGE_REASONS = {\\n  OBSERVED: 'observed',\\n  REQUESTED: 'requested'\\n};\\n\\n/**\\n * Monitors changes in properties (eg. cellCount) and state (eg. scroll offsets) to determine when rendering needs to occur.\\n * This component does not render any visible content itself; it defers to the specified :cellLayoutManager.\\n */\\n\\nvar CollectionView = function (_React$PureComponent) {\\n  (0, _inherits3.default)(CollectionView, _React$PureComponent);\\n\\n  // Invokes callbacks only when their values have changed.\\n  function CollectionView() {\\n    var _ref;\\n\\n    (0, _classCallCheck3.default)(this, CollectionView);\\n\\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\\n      args[_key] = arguments[_key];\\n    }\\n\\n    // If this component is being rendered server-side, getScrollbarSize() will return undefined.\\n    // We handle this case in componentDidMount()\\n    var _this = (0, _possibleConstructorReturn3.default)(this, (_ref = CollectionView.__proto__ || (0, _getPrototypeOf2.default)(CollectionView)).call.apply(_ref, [this].concat(args)));\\n\\n    _this.state = {\\n      isScrolling: false,\\n      scrollLeft: 0,\\n      scrollTop: 0\\n    };\\n    _this._calculateSizeAndPositionDataOnNextUpdate = false;\\n    _this._onSectionRenderedMemoizer = (0, _createCallbackMemoizer2.default)();\\n    _this._onScrollMemoizer = (0, _createCallbackMemoizer2.default)(false);\\n\\n    _this._invokeOnSectionRenderedHelper = function () {\\n      var _this$props = _this.props,\\n          cellLayoutManager = _this$props.cellLayoutManager,\\n          onSectionRendered = _this$props.onSectionRendered;\\n\\n\\n      _this._onSectionRenderedMemoizer({\\n        callback: onSectionRendered,\\n        indices: {\\n          indices: cellLayoutManager.getLastRenderedIndices()\\n        }\\n      });\\n    };\\n\\n    _this._setScrollingContainerRef = function (ref) {\\n      _this._scrollingContainer = ref;\\n    };\\n\\n    _this._updateScrollPositionForScrollToCell = function () {\\n      var _this$props2 = _this.props,\\n          cellLayoutManager = _this$props2.cellLayoutManager,\\n          height = _this$props2.height,\\n          scrollToAlignment = _this$props2.scrollToAlignment,\\n          scrollToCell = _this$props2.scrollToCell,\\n          width = _this$props2.width;\\n      var _this$state = _this.state,\\n          scrollLeft = _this$state.scrollLeft,\\n          scrollTop = _this$state.scrollTop;\\n\\n\\n      if (scrollToCell >= 0) {\\n        var scrollPosition = cellLayoutManager.getScrollPositionForCell({\\n          align: scrollToAlignment,\\n          cellIndex: scrollToCell,\\n          height: height,\\n          scrollLeft: scrollLeft,\\n          scrollTop: scrollTop,\\n          width: width\\n        });\\n\\n        if (scrollPosition.scrollLeft !== scrollLeft || scrollPosition.scrollTop !== scrollTop) {\\n          _this._setScrollPosition(scrollPosition);\\n        }\\n      }\\n    };\\n\\n    _this._onScroll = function (event) {\\n      // In certain edge-cases React dispatches an onScroll event with an invalid target.scrollLeft / target.scrollTop.\\n      // This invalid event can be detected by comparing event.target to this component's scrollable DOM element.\\n      // See issue #404 for more information.\\n      if (event.target !== _this._scrollingContainer) {\\n        return;\\n      }\\n\\n      // Prevent pointer events from interrupting a smooth scroll\\n      _this._enablePointerEventsAfterDelay();\\n\\n      // When this component is shrunk drastically, React dispatches a series of back-to-back scroll events,\\n      // Gradually converging on a scrollTop that is within the bounds of the new, smaller height.\\n      // This causes a series of rapid renders that is slow for long lists.\\n      // We can avoid that by doing some simple bounds checking to ensure that scrollTop never exceeds the total height.\\n      var _this$props3 = _this.props,\\n          cellLayoutManager = _this$props3.cellLayoutManager,\\n          height = _this$props3.height,\\n          isScrollingChange = _this$props3.isScrollingChange,\\n          width = _this$props3.width;\\n\\n      var scrollbarSize = _this._scrollbarSize;\\n\\n      var _cellLayoutManager$ge = cellLayoutManager.getTotalSize(),\\n          totalHeight = _cellLayoutManager$ge.height,\\n          totalWidth = _cellLayoutManager$ge.width;\\n\\n      var scrollLeft = Math.max(0, Math.min(totalWidth - width + scrollbarSize, event.target.scrollLeft));\\n      var scrollTop = Math.max(0, Math.min(totalHeight - height + scrollbarSize, event.target.scrollTop));\\n\\n      // Certain devices (like Apple touchpad) rapid-fire duplicate events.\\n      // Don't force a re-render if this is the case.\\n      // The mouse may move faster then the animation frame does.\\n      // Use requestAnimationFrame to avoid over-updating.\\n      if (_this.state.scrollLeft !== scrollLeft || _this.state.scrollTop !== scrollTop) {\\n        // Browsers with cancelable scroll events (eg. Firefox) interrupt scrolling animations if scrollTop/scrollLeft is set.\\n        // Other browsers (eg. Safari) don't scroll as well without the help under certain conditions (DOM or style changes during scrolling).\\n        // All things considered, this seems to be the best current work around that I'm aware of.\\n        // For more information see https://github.com/bvaughn/react-virtualized/pull/124\\n        var scrollPositionChangeReason = event.cancelable ? SCROLL_POSITION_CHANGE_REASONS.OBSERVED : SCROLL_POSITION_CHANGE_REASONS.REQUESTED;\\n\\n        // Synchronously set :isScrolling the first time (since _setNextState will reschedule its animation frame each time it's called)\\n        if (!_this.state.isScrolling) {\\n          isScrollingChange(true);\\n        }\\n\\n        _this.setState({\\n          isScrolling: true,\\n          scrollLeft: scrollLeft,\\n          scrollPositionChangeReason: scrollPositionChangeReason,\\n          scrollTop: scrollTop\\n        });\\n      }\\n\\n      _this._invokeOnScrollMemoizer({\\n        scrollLeft: scrollLeft,\\n        scrollTop: scrollTop,\\n        totalWidth: totalWidth,\\n        totalHeight: totalHeight\\n      });\\n    };\\n\\n    _this._scrollbarSize = (0, _scrollbarSize2.default)();\\n    if (_this._scrollbarSize === undefined) {\\n      _this._scrollbarSizeMeasured = false;\\n      _this._scrollbarSize = 0;\\n    } else {\\n      _this._scrollbarSizeMeasured = true;\\n    }\\n    return _this;\\n  }\\n\\n  /**\\n   * Forced recompute of cell sizes and positions.\\n   * This function should be called if cell sizes have changed but nothing else has.\\n   * Since cell positions are calculated by callbacks, the collection view has no way of detecting when the underlying data has changed.\\n   */\\n\\n\\n  (0, _createClass3.default)(CollectionView, [{\\n    key: 'recomputeCellSizesAndPositions',\\n    value: function recomputeCellSizesAndPositions() {\\n      this._calculateSizeAndPositionDataOnNextUpdate = true;\\n      this.forceUpdate();\\n    }\\n\\n    /* ---------------------------- Component lifecycle methods ---------------------------- */\\n\\n    /**\\n     * @private\\n     * This method updates scrollLeft/scrollTop in state for the following conditions:\\n     * 1) Empty content (0 rows or columns)\\n     * 2) New scroll props overriding the current state\\n     * 3) Cells-count or cells-size has changed, making previous scroll offsets invalid\\n     */\\n\\n  }, {\\n    key: 'componentDidMount',\\n    value: function componentDidMount() {\\n      var _props = this.props,\\n          cellLayoutManager = _props.cellLayoutManager,\\n          scrollLeft = _props.scrollLeft,\\n          scrollToCell = _props.scrollToCell,\\n          scrollTop = _props.scrollTop;\\n\\n      // If this component was first rendered server-side, scrollbar size will be undefined.\\n      // In that event we need to remeasure.\\n\\n      if (!this._scrollbarSizeMeasured) {\\n        this._scrollbarSize = (0, _scrollbarSize2.default)();\\n        this._scrollbarSizeMeasured = true;\\n        this.setState({});\\n      }\\n\\n      if (scrollToCell >= 0) {\\n        this._updateScrollPositionForScrollToCell();\\n      } else if (scrollLeft >= 0 || scrollTop >= 0) {\\n        this._setScrollPosition({ scrollLeft: scrollLeft, scrollTop: scrollTop });\\n      }\\n\\n      // Update onSectionRendered callback.\\n      this._invokeOnSectionRenderedHelper();\\n\\n      var _cellLayoutManager$ge2 = cellLayoutManager.getTotalSize(),\\n          totalHeight = _cellLayoutManager$ge2.height,\\n          totalWidth = _cellLayoutManager$ge2.width;\\n\\n      // Initialize onScroll callback.\\n\\n\\n      this._invokeOnScrollMemoizer({\\n        scrollLeft: scrollLeft || 0,\\n        scrollTop: scrollTop || 0,\\n        totalHeight: totalHeight,\\n        totalWidth: totalWidth\\n      });\\n    }\\n  }, {\\n    key: 'componentDidUpdate',\\n    value: function componentDidUpdate(prevProps, prevState) {\\n      var _props2 = this.props,\\n          height = _props2.height,\\n          scrollToAlignment = _props2.scrollToAlignment,\\n          scrollToCell = _props2.scrollToCell,\\n          width = _props2.width;\\n      var _state = this.state,\\n          scrollLeft = _state.scrollLeft,\\n          scrollPositionChangeReason = _state.scrollPositionChangeReason,\\n          scrollTop = _state.scrollTop;\\n\\n      // Make sure requested changes to :scrollLeft or :scrollTop get applied.\\n      // Assigning to scrollLeft/scrollTop tells the browser to interrupt any running scroll animations,\\n      // And to discard any pending async changes to the scroll position that may have happened in the meantime (e.g. on a separate scrolling thread).\\n      // So we only set these when we require an adjustment of the scroll position.\\n      // See issue #2 for more information.\\n\\n      if (scrollPositionChangeReason === SCROLL_POSITION_CHANGE_REASONS.REQUESTED) {\\n        if (scrollLeft >= 0 && scrollLeft !== prevState.scrollLeft && scrollLeft !== this._scrollingContainer.scrollLeft) {\\n          this._scrollingContainer.scrollLeft = scrollLeft;\\n        }\\n        if (scrollTop >= 0 && scrollTop !== prevState.scrollTop && scrollTop !== this._scrollingContainer.scrollTop) {\\n          this._scrollingContainer.scrollTop = scrollTop;\\n        }\\n      }\\n\\n      // Update scroll offsets if the current :scrollToCell values requires it\\n      if (height !== prevProps.height || scrollToAlignment !== prevProps.scrollToAlignment || scrollToCell !== prevProps.scrollToCell || width !== prevProps.width) {\\n        this._updateScrollPositionForScrollToCell();\\n      }\\n\\n      // Update onRowsRendered callback if start/stop indices have changed\\n      this._invokeOnSectionRenderedHelper();\\n    }\\n  }, {\\n    key: 'componentWillUnmount',\\n    value: function componentWillUnmount() {\\n      if (this._disablePointerEventsTimeoutId) {\\n        clearTimeout(this._disablePointerEventsTimeoutId);\\n      }\\n    }\\n  }, {\\n    key: 'render',\\n    value: function render() {\\n      var _props3 = this.props,\\n          autoHeight = _props3.autoHeight,\\n          cellCount = _props3.cellCount,\\n          cellLayoutManager = _props3.cellLayoutManager,\\n          className = _props3.className,\\n          height = _props3.height,\\n          horizontalOverscanSize = _props3.horizontalOverscanSize,\\n          id = _props3.id,\\n          noContentRenderer = _props3.noContentRenderer,\\n          style = _props3.style,\\n          verticalOverscanSize = _props3.verticalOverscanSize,\\n          width = _props3.width;\\n      var _state2 = this.state,\\n          isScrolling = _state2.isScrolling,\\n          scrollLeft = _state2.scrollLeft,\\n          scrollTop = _state2.scrollTop;\\n\\n      // Memoization reset\\n\\n      if (this._lastRenderedCellCount !== cellCount || this._lastRenderedCellLayoutManager !== cellLayoutManager || this._calculateSizeAndPositionDataOnNextUpdate) {\\n        this._lastRenderedCellCount = cellCount;\\n        this._lastRenderedCellLayoutManager = cellLayoutManager;\\n        this._calculateSizeAndPositionDataOnNextUpdate = false;\\n\\n        cellLayoutManager.calculateSizeAndPositionData();\\n      }\\n\\n      var _cellLayoutManager$ge3 = cellLayoutManager.getTotalSize(),\\n          totalHeight = _cellLayoutManager$ge3.height,\\n          totalWidth = _cellLayoutManager$ge3.width;\\n\\n      // Safely expand the rendered area by the specified overscan amount\\n\\n\\n      var left = Math.max(0, scrollLeft - horizontalOverscanSize);\\n      var top = Math.max(0, scrollTop - verticalOverscanSize);\\n      var right = Math.min(totalWidth, scrollLeft + width + horizontalOverscanSize);\\n      var bottom = Math.min(totalHeight, scrollTop + height + verticalOverscanSize);\\n\\n      var childrenToDisplay = height > 0 && width > 0 ? cellLayoutManager.cellRenderers({\\n        height: bottom - top,\\n        isScrolling: isScrolling,\\n        width: right - left,\\n        x: left,\\n        y: top\\n      }) : [];\\n\\n      var collectionStyle = {\\n        boxSizing: 'border-box',\\n        direction: 'ltr',\\n        height: autoHeight ? 'auto' : height,\\n        position: 'relative',\\n        WebkitOverflowScrolling: 'touch',\\n        width: width,\\n        willChange: 'transform'\\n      };\\n\\n      // Force browser to hide scrollbars when we know they aren't necessary.\\n      // Otherwise once scrollbars appear they may not disappear again.\\n      // For more info see issue #116\\n      var verticalScrollBarSize = totalHeight > height ? this._scrollbarSize : 0;\\n      var horizontalScrollBarSize = totalWidth > width ? this._scrollbarSize : 0;\\n\\n      // Also explicitly init styles to 'auto' if scrollbars are required.\\n      // This works around an obscure edge case where external CSS styles have not yet been loaded,\\n      // But an initial scroll index of offset is set as an external prop.\\n      // Without this style, Grid would render the correct range of cells but would NOT update its internal offset.\\n      // This was originally reported via clauderic/react-infinite-calendar/issues/23\\n      collectionStyle.overflowX = totalWidth + verticalScrollBarSize <= width ? 'hidden' : 'auto';\\n      collectionStyle.overflowY = totalHeight + horizontalScrollBarSize <= height ? 'hidden' : 'auto';\\n\\n      return React.createElement(\\n        'div',\\n        {\\n          ref: this._setScrollingContainerRef,\\n          'aria-label': this.props['aria-label'],\\n          className: (0, _classnames2.default)('ReactVirtualized__Collection', className),\\n          id: id,\\n          onScroll: this._onScroll,\\n          role: 'grid',\\n          style: (0, _extends3.default)({}, collectionStyle, style),\\n          tabIndex: 0 },\\n        cellCount > 0 && React.createElement(\\n          'div',\\n          {\\n            className: 'ReactVirtualized__Collection__innerScrollContainer',\\n            style: {\\n              height: totalHeight,\\n              maxHeight: totalHeight,\\n              maxWidth: totalWidth,\\n              overflow: 'hidden',\\n              pointerEvents: isScrolling ? 'none' : '',\\n              width: totalWidth\\n            } },\\n          childrenToDisplay\\n        ),\\n        cellCount === 0 && noContentRenderer()\\n      );\\n    }\\n\\n    /* ---------------------------- Helper methods ---------------------------- */\\n\\n    /**\\n     * Sets an :isScrolling flag for a small window of time.\\n     * This flag is used to disable pointer events on the scrollable portion of the Collection.\\n     * This prevents jerky/stuttery mouse-wheel scrolling.\\n     */\\n\\n  }, {\\n    key: '_enablePointerEventsAfterDelay',\\n    value: function _enablePointerEventsAfterDelay() {\\n      var _this2 = this;\\n\\n      if (this._disablePointerEventsTimeoutId) {\\n        clearTimeout(this._disablePointerEventsTimeoutId);\\n      }\\n\\n      this._disablePointerEventsTimeoutId = setTimeout(function () {\\n        var isScrollingChange = _this2.props.isScrollingChange;\\n\\n\\n        isScrollingChange(false);\\n\\n        _this2._disablePointerEventsTimeoutId = null;\\n        _this2.setState({\\n          isScrolling: false\\n        });\\n      }, IS_SCROLLING_TIMEOUT);\\n    }\\n  }, {\\n    key: '_invokeOnScrollMemoizer',\\n    value: function _invokeOnScrollMemoizer(_ref2) {\\n      var _this3 = this;\\n\\n      var scrollLeft = _ref2.scrollLeft,\\n          scrollTop = _ref2.scrollTop,\\n          totalHeight = _ref2.totalHeight,\\n          totalWidth = _ref2.totalWidth;\\n\\n      this._onScrollMemoizer({\\n        callback: function callback(_ref3) {\\n          var scrollLeft = _ref3.scrollLeft,\\n              scrollTop = _ref3.scrollTop;\\n          var _props4 = _this3.props,\\n              height = _props4.height,\\n              onScroll = _props4.onScroll,\\n              width = _props4.width;\\n\\n\\n          onScroll({\\n            clientHeight: height,\\n            clientWidth: width,\\n            scrollHeight: totalHeight,\\n            scrollLeft: scrollLeft,\\n            scrollTop: scrollTop,\\n            scrollWidth: totalWidth\\n          });\\n        },\\n        indices: {\\n          scrollLeft: scrollLeft,\\n          scrollTop: scrollTop\\n        }\\n      });\\n    }\\n  }, {\\n    key: '_setScrollPosition',\\n    value: function _setScrollPosition(_ref4) {\\n      var scrollLeft = _ref4.scrollLeft,\\n          scrollTop = _ref4.scrollTop;\\n\\n      var newState = {\\n        scrollPositionChangeReason: SCROLL_POSITION_CHANGE_REASONS.REQUESTED\\n      };\\n\\n      if (scrollLeft >= 0) {\\n        newState.scrollLeft = scrollLeft;\\n      }\\n\\n      if (scrollTop >= 0) {\\n        newState.scrollTop = scrollTop;\\n      }\\n\\n      if (scrollLeft >= 0 && scrollLeft !== this.state.scrollLeft || scrollTop >= 0 && scrollTop !== this.state.scrollTop) {\\n        this.setState(newState);\\n      }\\n    }\\n  }], [{\\n    key: 'getDerivedStateFromProps',\\n    value: function getDerivedStateFromProps(nextProps, prevState) {\\n      if (nextProps.cellCount === 0 && (prevState.scrollLeft !== 0 || prevState.scrollTop !== 0)) {\\n        return {\\n          scrollLeft: 0,\\n          scrollTop: 0\\n        };\\n      } else if (nextProps.scrollLeft !== prevState.scrollLeft || nextProps.scrollTop !== prevState.scrollTop) {\\n        return {\\n          scrollLeft: nextProps.scrollLeft != null ? nextProps.scrollLeft : prevState.scrollLeft,\\n          scrollTop: nextProps.scrollTop != null ? nextProps.scrollTop : prevState.scrollTop\\n        };\\n      }\\n\\n      return null;\\n    }\\n  }]);\\n  return CollectionView;\\n}(React.PureComponent);\\n\\nCollectionView.defaultProps = {\\n  'aria-label': 'grid',\\n  horizontalOverscanSize: 0,\\n  noContentRenderer: function noContentRenderer() {\\n    return null;\\n  },\\n  onScroll: function onScroll() {\\n    return null;\\n  },\\n  onSectionRendered: function onSectionRendered() {\\n    return null;\\n  },\\n  scrollToAlignment: 'auto',\\n  scrollToCell: -1,\\n  style: {},\\n  verticalOverscanSize: 0\\n};\\nCollectionView.propTypes = process.env.NODE_ENV !== \\\"production\\\" ? {\\n  'aria-label': _propTypes2.default.string,\\n\\n  /**\\n   * Removes fixed height from the scrollingContainer so that the total height\\n   * of rows can stretch the window. Intended for use with WindowScroller\\n   */\\n  autoHeight: _propTypes2.default.bool,\\n\\n  /**\\n   * Number of cells in collection.\\n   */\\n  cellCount: _propTypes2.default.number.isRequired,\\n\\n  /**\\n   * Calculates cell sizes and positions and manages rendering the appropriate cells given a specified window.\\n   */\\n  cellLayoutManager: _propTypes2.default.object.isRequired,\\n\\n  /**\\n   * Optional custom CSS class name to attach to root Collection element.\\n   */\\n  className: _propTypes2.default.string,\\n\\n  /**\\n   * Height of Collection; this property determines the number of visible (vs virtualized) rows.\\n   */\\n  height: _propTypes2.default.number.isRequired,\\n\\n  /**\\n   * Optional custom id to attach to root Collection element.\\n   */\\n  id: _propTypes2.default.string,\\n\\n  /**\\n   * Enables the `Collection` to horiontally \\\"overscan\\\" its content similar to how `Grid` does.\\n   * This can reduce flicker around the edges when a user scrolls quickly.\\n   */\\n  horizontalOverscanSize: _propTypes2.default.number.isRequired,\\n\\n  isScrollingChange: _propTypes2.default.func,\\n\\n  /**\\n   * Optional renderer to be used in place of rows when either :rowCount or :cellCount is 0.\\n   */\\n  noContentRenderer: _propTypes2.default.func.isRequired,\\n\\n  /**\\n   * Callback invoked whenever the scroll offset changes within the inner scrollable region.\\n   * This callback can be used to sync scrolling between lists, tables, or grids.\\n   * ({ clientHeight, clientWidth, scrollHeight, scrollLeft, scrollTop, scrollWidth }): void\\n   */\\n  onScroll: _propTypes2.default.func.isRequired,\\n\\n  /**\\n   * Callback invoked with information about the section of the Collection that was just rendered.\\n   * This callback is passed a named :indices parameter which is an Array of the most recently rendered section indices.\\n   */\\n  onSectionRendered: _propTypes2.default.func.isRequired,\\n\\n  /**\\n   * Horizontal offset.\\n   */\\n  scrollLeft: _propTypes2.default.number,\\n\\n  /**\\n   * Controls scroll-to-cell behavior of the Grid.\\n   * The default (\\\"auto\\\") scrolls the least amount possible to ensure that the specified cell is fully visible.\\n   * Use \\\"start\\\" to align cells to the top/left of the Grid and \\\"end\\\" to align bottom/right.\\n   */\\n  scrollToAlignment: _propTypes2.default.oneOf(['auto', 'end', 'start', 'center']).isRequired,\\n\\n  /**\\n   * Cell index to ensure visible (by forcefully scrolling if necessary).\\n   */\\n  scrollToCell: _propTypes2.default.number.isRequired,\\n\\n  /**\\n   * Vertical offset.\\n   */\\n  scrollTop: _propTypes2.default.number,\\n\\n  /**\\n   * Optional custom inline style to attach to root Collection element.\\n   */\\n  style: _propTypes2.default.object,\\n\\n  /**\\n   * Enables the `Collection` to vertically \\\"overscan\\\" its content similar to how `Grid` does.\\n   * This can reduce flicker around the edges when a user scrolls quickly.\\n   */\\n  verticalOverscanSize: _propTypes2.default.number.isRequired,\\n\\n  /**\\n   * Width of Collection; this property determines the number of visible (vs virtualized) columns.\\n   */\\n  width: _propTypes2.default.number.isRequired\\n} : {};\\n\\n\\n(0, _reactLifecyclesCompat.polyfill)(CollectionView);\\n\\nexports.default = CollectionView;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"process\",\"require\",\"module\",\"exports\",\"shadow$shims\",\"_interopRequireDefault\",\"obj\",\"__esModule\",\"default\",\"Object\",\"defineProperty\",\"value\",\"_extends2\",\"_extends3\",\"_getPrototypeOf\",\"_getPrototypeOf2\",\"_classCallCheck2\",\"_classCallCheck3\",\"_createClass2\",\"_createClass3\",\"_possibleConstructorReturn2\",\"_possibleConstructorReturn3\",\"_inherits2\",\"_inherits3\",\"_classnames\",\"_classnames2\",\"_propTypes\",\"_propTypes2\",\"React\",\"_interopRequireWildcard\",\"newObj\",\"key\",\"prototype\",\"hasOwnProperty\",\"call\",\"_react\",\"_reactLifecyclesCompat\",\"_createCallbackMemoizer\",\"_createCallbackMemoizer2\",\"_scrollbarSize\",\"_scrollbarSize2\",\"CollectionView\",\"_React$PureComponent\",\"_ref\",\"_len\",\"arguments\",\"length\",\"args\",\"Array\",\"_key\",\"_this\",\"__proto__\",\"apply\",\"concat\",\"state\",\"isScrolling\",\"scrollLeft\",\"scrollTop\",\"_calculateSizeAndPositionDataOnNextUpdate\",\"_onSectionRenderedMemoizer\",\"_onScrollMemoizer\",\"_invokeOnSectionRenderedHelper\",\"_this._invokeOnSectionRenderedHelper\",\"_this$props\",\"props\",\"callback\",\"onSectionRendered\",\"indices\",\"cellLayoutManager\",\"getLastRenderedIndices\",\"_setScrollingContainerRef\",\"_this._setScrollingContainerRef\",\"ref\",\"_scrollingContainer\",\"_updateScrollPositionForScrollToCell\",\"_this._updateScrollPositionForScrollToCell\",\"_this$props2\",\"height\",\"scrollToAlignment\",\"scrollToCell\",\"width\",\"_this$state\",\"scrollPosition\",\"getScrollPositionForCell\",\"align\",\"cellIndex\",\"_setScrollPosition\",\"_onScroll\",\"_this._onScroll\",\"event\",\"target\",\"_enablePointerEventsAfterDelay\",\"_this$props3\",\"isScrollingChange\",\"scrollbarSize\",\"_cellLayoutManager$ge\",\"getTotalSize\",\"totalHeight\",\"totalWidth\",\"Math\",\"max\",\"min\",\"scrollPositionChangeReason\",\"cancelable\",\"OBSERVED\",\"REQUESTED\",\"setState\",\"_invokeOnScrollMemoizer\",\"undefined\",\"_scrollbarSizeMeasured\",\"recomputeCellSizesAndPositions\",\"forceUpdate\",\"componentDidMount\",\"_props\",\"_cellLayoutManager$ge2\",\"componentDidUpdate\",\"prevProps\",\"prevState\",\"_props2\",\"_state\",\"componentWillUnmount\",\"_disablePointerEventsTimeoutId\",\"clearTimeout\",\"render\",\"_props3\",\"autoHeight\",\"cellCount\",\"className\",\"horizontalOverscanSize\",\"id\",\"noContentRenderer\",\"style\",\"verticalOverscanSize\",\"_state2\",\"_lastRenderedCellCount\",\"_lastRenderedCellLayoutManager\",\"calculateSizeAndPositionData\",\"_cellLayoutManager$ge3\",\"left\",\"top\",\"right\",\"bottom\",\"childrenToDisplay\",\"cellRenderers\",\"x\",\"y\",\"collectionStyle\",\"boxSizing\",\"direction\",\"position\",\"WebkitOverflowScrolling\",\"willChange\",\"horizontalScrollBarSize\",\"overflowX\",\"verticalScrollBarSize\",\"overflowY\",\"createElement\",\"onScroll\",\"role\",\"tabIndex\",\"maxHeight\",\"maxWidth\",\"overflow\",\"pointerEvents\",\"_this2\",\"setTimeout\",\"IS_SCROLLING_TIMEOUT\",\"_ref2\",\"_this3\",\"_ref3\",\"_props4\",\"clientHeight\",\"clientWidth\",\"scrollHeight\",\"scrollWidth\",\"_ref4\",\"newState\",\"getDerivedStateFromProps\",\"nextProps\",\"PureComponent\",\"defaultProps\",\"propTypes\",\"string\",\"bool\",\"number\",\"isRequired\",\"object\",\"func\",\"oneOf\",\"polyfill\"]\n}\n"]