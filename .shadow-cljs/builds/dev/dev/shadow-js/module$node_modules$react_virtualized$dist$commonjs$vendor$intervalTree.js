["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/react-virtualized/dist/commonjs/vendor/intervalTree.js"],"~:js","shadow$provide.module$node_modules$react_virtualized$dist$commonjs$vendor$intervalTree=function(global,process,require,module,exports,shadow$shims){function IntervalTreeNode(mid,left,right,leftPoints,rightPoints){this.mid=mid;this.left=left;this.right=right;this.leftPoints=leftPoints;this.rightPoints=rightPoints;this.count=(left?left.count:0)+(right?right.count:0)+leftPoints.length}function copy(a,b){a.mid=b.mid;a.left=b.left;a.right=b.right;a.leftPoints=b.leftPoints;a.rightPoints=b.rightPoints;a.count=\nb.count}function rebuild(node,intervals){intervals=createIntervalTree(intervals);node.mid=intervals.mid;node.left=intervals.left;node.right=intervals.right;node.leftPoints=intervals.leftPoints;node.rightPoints=intervals.rightPoints;node.count=intervals.count}function rebuildWithoutInterval(node,interval){var intervals=node.intervals([]);interval=intervals.indexOf(interval);if(0>interval)return 0;intervals.splice(interval,1);rebuild(node,intervals);return 1}function reportLeftRange(arr,hi,cb){for(var i=\n0;i<arr.length&&arr[i][0]<=hi;++i){var r=cb(arr[i]);if(r)return r}}function reportRightRange(arr,lo,cb){for(var i=arr.length-1;0<=i&&arr[i][1]>=lo;--i){var r=cb(arr[i]);if(r)return r}}function reportRange(arr,cb){for(var i=0;i<arr.length;++i){var r=cb(arr[i]);if(r)return r}}function compareNumbers(a,b){return a-b}function compareBegin(a,b){var d=a[0]-b[0];return d?d:a[1]-b[1]}function compareEnd(a,b){var d=a[1]-b[1];return d?d:a[0]-b[0]}function createIntervalTree(intervals){if(0===intervals.length)return null;\nfor(var pts=[],i=0;i<intervals.length;++i)pts.push(intervals[i][0],intervals[i][1]);pts.sort(compareNumbers);pts=pts[pts.length>>1];var leftIntervals=[],rightIntervals=[],centerIntervals=[];for(i=0;i<intervals.length;++i){var s=intervals[i];s[1]<pts?leftIntervals.push(s):pts<s[0]?rightIntervals.push(s):centerIntervals.push(s)}intervals=centerIntervals.slice();centerIntervals.sort(compareBegin);intervals.sort(compareEnd);return new IntervalTreeNode(pts,createIntervalTree(leftIntervals),createIntervalTree(rightIntervals),\ncenterIntervals,intervals)}function IntervalTree(root){this.root=root}Object.defineProperty(exports,\"__esModule\",{value:!0});exports.default=function(intervals){return intervals&&0!==intervals.length?new IntervalTree(createIntervalTree(intervals)):new IntervalTree(null)};var _binarySearchBounds2=(global=require(\"module$node_modules$react_virtualized$dist$commonjs$vendor$binarySearchBounds\"))&&global.__esModule?global:{default:global};global=IntervalTreeNode.prototype;global.intervals=function(result){result.push.apply(result,\nthis.leftPoints);this.left&&this.left.intervals(result);this.right&&this.right.intervals(result);return result};global.insert=function(interval){var weight=this.count-this.leftPoints.length;this.count+=1;if(interval[1]<this.mid)this.left?4*(this.left.count+1)>3*(weight+1)?(weight=this.intervals([]),weight.push(interval),rebuild(this,weight)):this.left.insert(interval):this.left=createIntervalTree([interval]);else if(interval[0]>this.mid)this.right?4*(this.right.count+1)>3*(weight+1)?(weight=this.intervals([]),\nweight.push(interval),rebuild(this,weight)):this.right.insert(interval):this.right=createIntervalTree([interval]);else{weight=_binarySearchBounds2.default.ge(this.leftPoints,interval,compareBegin);var r=_binarySearchBounds2.default.ge(this.rightPoints,interval,compareEnd);this.leftPoints.splice(weight,0,interval);this.rightPoints.splice(r,0,interval)}};global.remove=function(interval){var weight=this.count-this.leftPoints;if(interval[1]<this.mid){if(!this.left)return 0;if(4*(this.right?this.right.count:\n0)>3*(weight-1))return rebuildWithoutInterval(this,interval);weight=this.left.remove(interval);if(2===weight)return this.left=null,--this.count,1;1===weight&&--this.count;return weight}if(interval[0]>this.mid){if(!this.right)return 0;if(4*(this.left?this.left.count:0)>3*(weight-1))return rebuildWithoutInterval(this,interval);weight=this.right.remove(interval);if(2===weight)return this.right=null,--this.count,1;1===weight&&--this.count;return weight}if(1===this.count)return this.leftPoints[0]===interval?\n2:0;if(1===this.leftPoints.length&&this.leftPoints[0]===interval){if(this.left&&this.right){interval=this;for(var n=this.left;n.right;)interval=n,n=n.right;if(interval===this)n.right=this.right;else{var l=this.left;weight=this.right;interval.count-=n.count;interval.right=n.left;n.left=l;n.right=weight}copy(this,n);this.count=(this.left?this.left.count:0)+(this.right?this.right.count:0)+this.leftPoints.length}else this.left?copy(this,this.left):copy(this,this.right);return 1}for(l=_binarySearchBounds2.default.ge(this.leftPoints,\ninterval,compareBegin);l<this.leftPoints.length&&this.leftPoints[l][0]===interval[0];++l)if(this.leftPoints[l]===interval)for(--this.count,this.leftPoints.splice(l,1),weight=_binarySearchBounds2.default.ge(this.rightPoints,interval,compareEnd);weight<this.rightPoints.length&&this.rightPoints[weight][1]===interval[1];++weight)if(this.rightPoints[weight]===interval)return this.rightPoints.splice(weight,1),1;return 0};global.queryPoint=function(x,cb){if(x<this.mid){if(this.left){var r=this.left.queryPoint(x,\ncb);if(r)return r}return reportLeftRange(this.leftPoints,x,cb)}return x>this.mid?this.right&&(r=this.right.queryPoint(x,cb))?r:reportRightRange(this.rightPoints,x,cb):reportRange(this.leftPoints,cb)};global.queryInterval=function(lo,hi,cb){if(lo<this.mid&&this.left){var r=this.left.queryInterval(lo,hi,cb);if(r)return r}return hi>this.mid&&this.right&&(r=this.right.queryInterval(lo,hi,cb))?r:hi<this.mid?reportLeftRange(this.leftPoints,hi,cb):lo>this.mid?reportRightRange(this.rightPoints,lo,cb):reportRange(this.leftPoints,\ncb)};global=IntervalTree.prototype;global.insert=function(interval){this.root?this.root.insert(interval):this.root=new IntervalTreeNode(interval[0],null,null,[interval],[interval])};global.remove=function(interval){return this.root?(interval=this.root.remove(interval),2===interval&&(this.root=null),0!==interval):!1};global.queryPoint=function(p,cb){if(this.root)return this.root.queryPoint(p,cb)};global.queryInterval=function(lo,hi,cb){if(lo<=hi&&this.root)return this.root.queryInterval(lo,hi,cb)};\nObject.defineProperty(global,\"count\",{get:function(){return this.root?this.root.count:0}});Object.defineProperty(global,\"intervals\",{get:function(){return this.root?this.root.intervals([]):[]}})}","~:source","shadow$provide[\"module$node_modules$react_virtualized$dist$commonjs$vendor$intervalTree\"] = function(global,process,require,module,exports,shadow$shims) {\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = createWrapper;\n\nvar _binarySearchBounds = require('./binarySearchBounds');\n\nvar _binarySearchBounds2 = _interopRequireDefault(_binarySearchBounds);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar NOT_FOUND = 0; /**\n                    * Binary Search Bounds\n                    * https://github.com/mikolalysenko/interval-tree-1d\n                    * Mikola Lysenko\n                    *\n                    * Inlined because of Content Security Policy issue caused by the use of `new Function(...)` syntax in an upstream dependency.\n                    * Issue reported here: https://github.com/mikolalysenko/binary-search-bounds/issues/5\n                    **/\n\nvar SUCCESS = 1;\nvar EMPTY = 2;\n\nfunction IntervalTreeNode(mid, left, right, leftPoints, rightPoints) {\n  this.mid = mid;\n  this.left = left;\n  this.right = right;\n  this.leftPoints = leftPoints;\n  this.rightPoints = rightPoints;\n  this.count = (left ? left.count : 0) + (right ? right.count : 0) + leftPoints.length;\n}\n\nvar proto = IntervalTreeNode.prototype;\n\nfunction copy(a, b) {\n  a.mid = b.mid;\n  a.left = b.left;\n  a.right = b.right;\n  a.leftPoints = b.leftPoints;\n  a.rightPoints = b.rightPoints;\n  a.count = b.count;\n}\n\nfunction rebuild(node, intervals) {\n  var ntree = createIntervalTree(intervals);\n  node.mid = ntree.mid;\n  node.left = ntree.left;\n  node.right = ntree.right;\n  node.leftPoints = ntree.leftPoints;\n  node.rightPoints = ntree.rightPoints;\n  node.count = ntree.count;\n}\n\nfunction rebuildWithInterval(node, interval) {\n  var intervals = node.intervals([]);\n  intervals.push(interval);\n  rebuild(node, intervals);\n}\n\nfunction rebuildWithoutInterval(node, interval) {\n  var intervals = node.intervals([]);\n  var idx = intervals.indexOf(interval);\n  if (idx < 0) {\n    return NOT_FOUND;\n  }\n  intervals.splice(idx, 1);\n  rebuild(node, intervals);\n  return SUCCESS;\n}\n\nproto.intervals = function (result) {\n  result.push.apply(result, this.leftPoints);\n  if (this.left) {\n    this.left.intervals(result);\n  }\n  if (this.right) {\n    this.right.intervals(result);\n  }\n  return result;\n};\n\nproto.insert = function (interval) {\n  var weight = this.count - this.leftPoints.length;\n  this.count += 1;\n  if (interval[1] < this.mid) {\n    if (this.left) {\n      if (4 * (this.left.count + 1) > 3 * (weight + 1)) {\n        rebuildWithInterval(this, interval);\n      } else {\n        this.left.insert(interval);\n      }\n    } else {\n      this.left = createIntervalTree([interval]);\n    }\n  } else if (interval[0] > this.mid) {\n    if (this.right) {\n      if (4 * (this.right.count + 1) > 3 * (weight + 1)) {\n        rebuildWithInterval(this, interval);\n      } else {\n        this.right.insert(interval);\n      }\n    } else {\n      this.right = createIntervalTree([interval]);\n    }\n  } else {\n    var l = _binarySearchBounds2.default.ge(this.leftPoints, interval, compareBegin);\n    var r = _binarySearchBounds2.default.ge(this.rightPoints, interval, compareEnd);\n    this.leftPoints.splice(l, 0, interval);\n    this.rightPoints.splice(r, 0, interval);\n  }\n};\n\nproto.remove = function (interval) {\n  var weight = this.count - this.leftPoints;\n  if (interval[1] < this.mid) {\n    if (!this.left) {\n      return NOT_FOUND;\n    }\n    var rw = this.right ? this.right.count : 0;\n    if (4 * rw > 3 * (weight - 1)) {\n      return rebuildWithoutInterval(this, interval);\n    }\n    var r = this.left.remove(interval);\n    if (r === EMPTY) {\n      this.left = null;\n      this.count -= 1;\n      return SUCCESS;\n    } else if (r === SUCCESS) {\n      this.count -= 1;\n    }\n    return r;\n  } else if (interval[0] > this.mid) {\n    if (!this.right) {\n      return NOT_FOUND;\n    }\n    var lw = this.left ? this.left.count : 0;\n    if (4 * lw > 3 * (weight - 1)) {\n      return rebuildWithoutInterval(this, interval);\n    }\n    var r = this.right.remove(interval);\n    if (r === EMPTY) {\n      this.right = null;\n      this.count -= 1;\n      return SUCCESS;\n    } else if (r === SUCCESS) {\n      this.count -= 1;\n    }\n    return r;\n  } else {\n    if (this.count === 1) {\n      if (this.leftPoints[0] === interval) {\n        return EMPTY;\n      } else {\n        return NOT_FOUND;\n      }\n    }\n    if (this.leftPoints.length === 1 && this.leftPoints[0] === interval) {\n      if (this.left && this.right) {\n        var p = this;\n        var n = this.left;\n        while (n.right) {\n          p = n;\n          n = n.right;\n        }\n        if (p === this) {\n          n.right = this.right;\n        } else {\n          var l = this.left;\n          var r = this.right;\n          p.count -= n.count;\n          p.right = n.left;\n          n.left = l;\n          n.right = r;\n        }\n        copy(this, n);\n        this.count = (this.left ? this.left.count : 0) + (this.right ? this.right.count : 0) + this.leftPoints.length;\n      } else if (this.left) {\n        copy(this, this.left);\n      } else {\n        copy(this, this.right);\n      }\n      return SUCCESS;\n    }\n    for (var l = _binarySearchBounds2.default.ge(this.leftPoints, interval, compareBegin); l < this.leftPoints.length; ++l) {\n      if (this.leftPoints[l][0] !== interval[0]) {\n        break;\n      }\n      if (this.leftPoints[l] === interval) {\n        this.count -= 1;\n        this.leftPoints.splice(l, 1);\n        for (var r = _binarySearchBounds2.default.ge(this.rightPoints, interval, compareEnd); r < this.rightPoints.length; ++r) {\n          if (this.rightPoints[r][1] !== interval[1]) {\n            break;\n          } else if (this.rightPoints[r] === interval) {\n            this.rightPoints.splice(r, 1);\n            return SUCCESS;\n          }\n        }\n      }\n    }\n    return NOT_FOUND;\n  }\n};\n\nfunction reportLeftRange(arr, hi, cb) {\n  for (var i = 0; i < arr.length && arr[i][0] <= hi; ++i) {\n    var r = cb(arr[i]);\n    if (r) {\n      return r;\n    }\n  }\n}\n\nfunction reportRightRange(arr, lo, cb) {\n  for (var i = arr.length - 1; i >= 0 && arr[i][1] >= lo; --i) {\n    var r = cb(arr[i]);\n    if (r) {\n      return r;\n    }\n  }\n}\n\nfunction reportRange(arr, cb) {\n  for (var i = 0; i < arr.length; ++i) {\n    var r = cb(arr[i]);\n    if (r) {\n      return r;\n    }\n  }\n}\n\nproto.queryPoint = function (x, cb) {\n  if (x < this.mid) {\n    if (this.left) {\n      var r = this.left.queryPoint(x, cb);\n      if (r) {\n        return r;\n      }\n    }\n    return reportLeftRange(this.leftPoints, x, cb);\n  } else if (x > this.mid) {\n    if (this.right) {\n      var r = this.right.queryPoint(x, cb);\n      if (r) {\n        return r;\n      }\n    }\n    return reportRightRange(this.rightPoints, x, cb);\n  } else {\n    return reportRange(this.leftPoints, cb);\n  }\n};\n\nproto.queryInterval = function (lo, hi, cb) {\n  if (lo < this.mid && this.left) {\n    var r = this.left.queryInterval(lo, hi, cb);\n    if (r) {\n      return r;\n    }\n  }\n  if (hi > this.mid && this.right) {\n    var r = this.right.queryInterval(lo, hi, cb);\n    if (r) {\n      return r;\n    }\n  }\n  if (hi < this.mid) {\n    return reportLeftRange(this.leftPoints, hi, cb);\n  } else if (lo > this.mid) {\n    return reportRightRange(this.rightPoints, lo, cb);\n  } else {\n    return reportRange(this.leftPoints, cb);\n  }\n};\n\nfunction compareNumbers(a, b) {\n  return a - b;\n}\n\nfunction compareBegin(a, b) {\n  var d = a[0] - b[0];\n  if (d) {\n    return d;\n  }\n  return a[1] - b[1];\n}\n\nfunction compareEnd(a, b) {\n  var d = a[1] - b[1];\n  if (d) {\n    return d;\n  }\n  return a[0] - b[0];\n}\n\nfunction createIntervalTree(intervals) {\n  if (intervals.length === 0) {\n    return null;\n  }\n  var pts = [];\n  for (var i = 0; i < intervals.length; ++i) {\n    pts.push(intervals[i][0], intervals[i][1]);\n  }\n  pts.sort(compareNumbers);\n\n  var mid = pts[pts.length >> 1];\n\n  var leftIntervals = [];\n  var rightIntervals = [];\n  var centerIntervals = [];\n  for (var i = 0; i < intervals.length; ++i) {\n    var s = intervals[i];\n    if (s[1] < mid) {\n      leftIntervals.push(s);\n    } else if (mid < s[0]) {\n      rightIntervals.push(s);\n    } else {\n      centerIntervals.push(s);\n    }\n  }\n\n  //Split center intervals\n  var leftPoints = centerIntervals;\n  var rightPoints = centerIntervals.slice();\n  leftPoints.sort(compareBegin);\n  rightPoints.sort(compareEnd);\n\n  return new IntervalTreeNode(mid, createIntervalTree(leftIntervals), createIntervalTree(rightIntervals), leftPoints, rightPoints);\n}\n\n//User friendly wrapper that makes it possible to support empty trees\nfunction IntervalTree(root) {\n  this.root = root;\n}\n\nvar tproto = IntervalTree.prototype;\n\ntproto.insert = function (interval) {\n  if (this.root) {\n    this.root.insert(interval);\n  } else {\n    this.root = new IntervalTreeNode(interval[0], null, null, [interval], [interval]);\n  }\n};\n\ntproto.remove = function (interval) {\n  if (this.root) {\n    var r = this.root.remove(interval);\n    if (r === EMPTY) {\n      this.root = null;\n    }\n    return r !== NOT_FOUND;\n  }\n  return false;\n};\n\ntproto.queryPoint = function (p, cb) {\n  if (this.root) {\n    return this.root.queryPoint(p, cb);\n  }\n};\n\ntproto.queryInterval = function (lo, hi, cb) {\n  if (lo <= hi && this.root) {\n    return this.root.queryInterval(lo, hi, cb);\n  }\n};\n\nObject.defineProperty(tproto, 'count', {\n  get: function get() {\n    if (this.root) {\n      return this.root.count;\n    }\n    return 0;\n  }\n});\n\nObject.defineProperty(tproto, 'intervals', {\n  get: function get() {\n    if (this.root) {\n      return this.root.intervals([]);\n    }\n    return [];\n  }\n});\n\nfunction createWrapper(intervals) {\n  if (!intervals || intervals.length === 0) {\n    return new IntervalTree(null);\n  }\n  return new IntervalTree(createIntervalTree(intervals));\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$react_virtualized$dist$commonjs$vendor$binarySearchBounds"]],"~:properties",["^5",["right","__esModule","root","count","intervals","value","queryInterval","remove","leftPoints","insert","queryPoint","mid","get","default","left","rightPoints"]],"~:compiled-at",1537791607696,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$react_virtualized$dist$commonjs$vendor$intervalTree.js\",\n\"lineCount\":13,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/react-virtualized/dist/commonjs/vendor/intervalTree.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$react_virtualized$dist$commonjs$vendor$intervalTree\\\"] = function(global,process,require,module,exports,shadow$shims) {\\n'use strict';\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.default = createWrapper;\\n\\nvar _binarySearchBounds = require('./binarySearchBounds');\\n\\nvar _binarySearchBounds2 = _interopRequireDefault(_binarySearchBounds);\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\\n\\nvar NOT_FOUND = 0; /**\\n                    * Binary Search Bounds\\n                    * https://github.com/mikolalysenko/interval-tree-1d\\n                    * Mikola Lysenko\\n                    *\\n                    * Inlined because of Content Security Policy issue caused by the use of `new Function(...)` syntax in an upstream dependency.\\n                    * Issue reported here: https://github.com/mikolalysenko/binary-search-bounds/issues/5\\n                    **/\\n\\nvar SUCCESS = 1;\\nvar EMPTY = 2;\\n\\nfunction IntervalTreeNode(mid, left, right, leftPoints, rightPoints) {\\n  this.mid = mid;\\n  this.left = left;\\n  this.right = right;\\n  this.leftPoints = leftPoints;\\n  this.rightPoints = rightPoints;\\n  this.count = (left ? left.count : 0) + (right ? right.count : 0) + leftPoints.length;\\n}\\n\\nvar proto = IntervalTreeNode.prototype;\\n\\nfunction copy(a, b) {\\n  a.mid = b.mid;\\n  a.left = b.left;\\n  a.right = b.right;\\n  a.leftPoints = b.leftPoints;\\n  a.rightPoints = b.rightPoints;\\n  a.count = b.count;\\n}\\n\\nfunction rebuild(node, intervals) {\\n  var ntree = createIntervalTree(intervals);\\n  node.mid = ntree.mid;\\n  node.left = ntree.left;\\n  node.right = ntree.right;\\n  node.leftPoints = ntree.leftPoints;\\n  node.rightPoints = ntree.rightPoints;\\n  node.count = ntree.count;\\n}\\n\\nfunction rebuildWithInterval(node, interval) {\\n  var intervals = node.intervals([]);\\n  intervals.push(interval);\\n  rebuild(node, intervals);\\n}\\n\\nfunction rebuildWithoutInterval(node, interval) {\\n  var intervals = node.intervals([]);\\n  var idx = intervals.indexOf(interval);\\n  if (idx < 0) {\\n    return NOT_FOUND;\\n  }\\n  intervals.splice(idx, 1);\\n  rebuild(node, intervals);\\n  return SUCCESS;\\n}\\n\\nproto.intervals = function (result) {\\n  result.push.apply(result, this.leftPoints);\\n  if (this.left) {\\n    this.left.intervals(result);\\n  }\\n  if (this.right) {\\n    this.right.intervals(result);\\n  }\\n  return result;\\n};\\n\\nproto.insert = function (interval) {\\n  var weight = this.count - this.leftPoints.length;\\n  this.count += 1;\\n  if (interval[1] < this.mid) {\\n    if (this.left) {\\n      if (4 * (this.left.count + 1) > 3 * (weight + 1)) {\\n        rebuildWithInterval(this, interval);\\n      } else {\\n        this.left.insert(interval);\\n      }\\n    } else {\\n      this.left = createIntervalTree([interval]);\\n    }\\n  } else if (interval[0] > this.mid) {\\n    if (this.right) {\\n      if (4 * (this.right.count + 1) > 3 * (weight + 1)) {\\n        rebuildWithInterval(this, interval);\\n      } else {\\n        this.right.insert(interval);\\n      }\\n    } else {\\n      this.right = createIntervalTree([interval]);\\n    }\\n  } else {\\n    var l = _binarySearchBounds2.default.ge(this.leftPoints, interval, compareBegin);\\n    var r = _binarySearchBounds2.default.ge(this.rightPoints, interval, compareEnd);\\n    this.leftPoints.splice(l, 0, interval);\\n    this.rightPoints.splice(r, 0, interval);\\n  }\\n};\\n\\nproto.remove = function (interval) {\\n  var weight = this.count - this.leftPoints;\\n  if (interval[1] < this.mid) {\\n    if (!this.left) {\\n      return NOT_FOUND;\\n    }\\n    var rw = this.right ? this.right.count : 0;\\n    if (4 * rw > 3 * (weight - 1)) {\\n      return rebuildWithoutInterval(this, interval);\\n    }\\n    var r = this.left.remove(interval);\\n    if (r === EMPTY) {\\n      this.left = null;\\n      this.count -= 1;\\n      return SUCCESS;\\n    } else if (r === SUCCESS) {\\n      this.count -= 1;\\n    }\\n    return r;\\n  } else if (interval[0] > this.mid) {\\n    if (!this.right) {\\n      return NOT_FOUND;\\n    }\\n    var lw = this.left ? this.left.count : 0;\\n    if (4 * lw > 3 * (weight - 1)) {\\n      return rebuildWithoutInterval(this, interval);\\n    }\\n    var r = this.right.remove(interval);\\n    if (r === EMPTY) {\\n      this.right = null;\\n      this.count -= 1;\\n      return SUCCESS;\\n    } else if (r === SUCCESS) {\\n      this.count -= 1;\\n    }\\n    return r;\\n  } else {\\n    if (this.count === 1) {\\n      if (this.leftPoints[0] === interval) {\\n        return EMPTY;\\n      } else {\\n        return NOT_FOUND;\\n      }\\n    }\\n    if (this.leftPoints.length === 1 && this.leftPoints[0] === interval) {\\n      if (this.left && this.right) {\\n        var p = this;\\n        var n = this.left;\\n        while (n.right) {\\n          p = n;\\n          n = n.right;\\n        }\\n        if (p === this) {\\n          n.right = this.right;\\n        } else {\\n          var l = this.left;\\n          var r = this.right;\\n          p.count -= n.count;\\n          p.right = n.left;\\n          n.left = l;\\n          n.right = r;\\n        }\\n        copy(this, n);\\n        this.count = (this.left ? this.left.count : 0) + (this.right ? this.right.count : 0) + this.leftPoints.length;\\n      } else if (this.left) {\\n        copy(this, this.left);\\n      } else {\\n        copy(this, this.right);\\n      }\\n      return SUCCESS;\\n    }\\n    for (var l = _binarySearchBounds2.default.ge(this.leftPoints, interval, compareBegin); l < this.leftPoints.length; ++l) {\\n      if (this.leftPoints[l][0] !== interval[0]) {\\n        break;\\n      }\\n      if (this.leftPoints[l] === interval) {\\n        this.count -= 1;\\n        this.leftPoints.splice(l, 1);\\n        for (var r = _binarySearchBounds2.default.ge(this.rightPoints, interval, compareEnd); r < this.rightPoints.length; ++r) {\\n          if (this.rightPoints[r][1] !== interval[1]) {\\n            break;\\n          } else if (this.rightPoints[r] === interval) {\\n            this.rightPoints.splice(r, 1);\\n            return SUCCESS;\\n          }\\n        }\\n      }\\n    }\\n    return NOT_FOUND;\\n  }\\n};\\n\\nfunction reportLeftRange(arr, hi, cb) {\\n  for (var i = 0; i < arr.length && arr[i][0] <= hi; ++i) {\\n    var r = cb(arr[i]);\\n    if (r) {\\n      return r;\\n    }\\n  }\\n}\\n\\nfunction reportRightRange(arr, lo, cb) {\\n  for (var i = arr.length - 1; i >= 0 && arr[i][1] >= lo; --i) {\\n    var r = cb(arr[i]);\\n    if (r) {\\n      return r;\\n    }\\n  }\\n}\\n\\nfunction reportRange(arr, cb) {\\n  for (var i = 0; i < arr.length; ++i) {\\n    var r = cb(arr[i]);\\n    if (r) {\\n      return r;\\n    }\\n  }\\n}\\n\\nproto.queryPoint = function (x, cb) {\\n  if (x < this.mid) {\\n    if (this.left) {\\n      var r = this.left.queryPoint(x, cb);\\n      if (r) {\\n        return r;\\n      }\\n    }\\n    return reportLeftRange(this.leftPoints, x, cb);\\n  } else if (x > this.mid) {\\n    if (this.right) {\\n      var r = this.right.queryPoint(x, cb);\\n      if (r) {\\n        return r;\\n      }\\n    }\\n    return reportRightRange(this.rightPoints, x, cb);\\n  } else {\\n    return reportRange(this.leftPoints, cb);\\n  }\\n};\\n\\nproto.queryInterval = function (lo, hi, cb) {\\n  if (lo < this.mid && this.left) {\\n    var r = this.left.queryInterval(lo, hi, cb);\\n    if (r) {\\n      return r;\\n    }\\n  }\\n  if (hi > this.mid && this.right) {\\n    var r = this.right.queryInterval(lo, hi, cb);\\n    if (r) {\\n      return r;\\n    }\\n  }\\n  if (hi < this.mid) {\\n    return reportLeftRange(this.leftPoints, hi, cb);\\n  } else if (lo > this.mid) {\\n    return reportRightRange(this.rightPoints, lo, cb);\\n  } else {\\n    return reportRange(this.leftPoints, cb);\\n  }\\n};\\n\\nfunction compareNumbers(a, b) {\\n  return a - b;\\n}\\n\\nfunction compareBegin(a, b) {\\n  var d = a[0] - b[0];\\n  if (d) {\\n    return d;\\n  }\\n  return a[1] - b[1];\\n}\\n\\nfunction compareEnd(a, b) {\\n  var d = a[1] - b[1];\\n  if (d) {\\n    return d;\\n  }\\n  return a[0] - b[0];\\n}\\n\\nfunction createIntervalTree(intervals) {\\n  if (intervals.length === 0) {\\n    return null;\\n  }\\n  var pts = [];\\n  for (var i = 0; i < intervals.length; ++i) {\\n    pts.push(intervals[i][0], intervals[i][1]);\\n  }\\n  pts.sort(compareNumbers);\\n\\n  var mid = pts[pts.length >> 1];\\n\\n  var leftIntervals = [];\\n  var rightIntervals = [];\\n  var centerIntervals = [];\\n  for (var i = 0; i < intervals.length; ++i) {\\n    var s = intervals[i];\\n    if (s[1] < mid) {\\n      leftIntervals.push(s);\\n    } else if (mid < s[0]) {\\n      rightIntervals.push(s);\\n    } else {\\n      centerIntervals.push(s);\\n    }\\n  }\\n\\n  //Split center intervals\\n  var leftPoints = centerIntervals;\\n  var rightPoints = centerIntervals.slice();\\n  leftPoints.sort(compareBegin);\\n  rightPoints.sort(compareEnd);\\n\\n  return new IntervalTreeNode(mid, createIntervalTree(leftIntervals), createIntervalTree(rightIntervals), leftPoints, rightPoints);\\n}\\n\\n//User friendly wrapper that makes it possible to support empty trees\\nfunction IntervalTree(root) {\\n  this.root = root;\\n}\\n\\nvar tproto = IntervalTree.prototype;\\n\\ntproto.insert = function (interval) {\\n  if (this.root) {\\n    this.root.insert(interval);\\n  } else {\\n    this.root = new IntervalTreeNode(interval[0], null, null, [interval], [interval]);\\n  }\\n};\\n\\ntproto.remove = function (interval) {\\n  if (this.root) {\\n    var r = this.root.remove(interval);\\n    if (r === EMPTY) {\\n      this.root = null;\\n    }\\n    return r !== NOT_FOUND;\\n  }\\n  return false;\\n};\\n\\ntproto.queryPoint = function (p, cb) {\\n  if (this.root) {\\n    return this.root.queryPoint(p, cb);\\n  }\\n};\\n\\ntproto.queryInterval = function (lo, hi, cb) {\\n  if (lo <= hi && this.root) {\\n    return this.root.queryInterval(lo, hi, cb);\\n  }\\n};\\n\\nObject.defineProperty(tproto, 'count', {\\n  get: function get() {\\n    if (this.root) {\\n      return this.root.count;\\n    }\\n    return 0;\\n  }\\n});\\n\\nObject.defineProperty(tproto, 'intervals', {\\n  get: function get() {\\n    if (this.root) {\\n      return this.root.intervals([]);\\n    }\\n    return [];\\n  }\\n});\\n\\nfunction createWrapper(intervals) {\\n  if (!intervals || intervals.length === 0) {\\n    return new IntervalTree(null);\\n  }\\n  return new IntervalTree(createIntervalTree(intervals));\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"process\",\"require\",\"module\",\"exports\",\"shadow$shims\",\"IntervalTreeNode\",\"mid\",\"left\",\"right\",\"leftPoints\",\"rightPoints\",\"count\",\"length\",\"copy\",\"a\",\"b\",\"rebuild\",\"node\",\"intervals\",\"ntree\",\"createIntervalTree\",\"rebuildWithoutInterval\",\"interval\",\"idx\",\"indexOf\",\"NOT_FOUND\",\"splice\",\"SUCCESS\",\"reportLeftRange\",\"arr\",\"hi\",\"cb\",\"i\",\"r\",\"reportRightRange\",\"lo\",\"reportRange\",\"compareNumbers\",\"compareBegin\",\"d\",\"compareEnd\",\"pts\",\"push\",\"sort\",\"leftIntervals\",\"rightIntervals\",\"centerIntervals\",\"s\",\"slice\",\"IntervalTree\",\"root\",\"Object\",\"defineProperty\",\"value\",\"default\",\"createWrapper\",\"_binarySearchBounds2\",\"_binarySearchBounds\",\"__esModule\",\"proto\",\"prototype\",\"proto.intervals\",\"result\",\"apply\",\"insert\",\"proto.insert\",\"weight\",\"l\",\"ge\",\"remove\",\"proto.remove\",\"rw\",\"EMPTY\",\"lw\",\"p\",\"n\",\"queryPoint\",\"proto.queryPoint\",\"x\",\"queryInterval\",\"proto.queryInterval\",\"tproto\",\"tproto.insert\",\"tproto.remove\",\"tproto.queryPoint\",\"tproto.queryInterval\",\"get\"]\n}\n"]