["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/react-virtualized/dist/commonjs/Grid/utils/calculateSizeAndPositionDataAndUpdateScrollOffset.js"],"~:js","shadow$provide.module$node_modules$react_virtualized$dist$commonjs$Grid$utils$calculateSizeAndPositionDataAndUpdateScrollOffset=function(global,process,require,module,exports,shadow$shims){Object.defineProperty(exports,\"__esModule\",{value:!0});exports.default=function(_ref){var cellSize=_ref.cellSize,computeMetadataCallback=_ref.computeMetadataCallback,computeMetadataCallbackProps=_ref.computeMetadataCallbackProps,nextCellSize=_ref.nextCellSize,nextScrollToIndex=_ref.nextScrollToIndex,scrollToIndex=\n_ref.scrollToIndex,updateScrollOffsetForScrollToIndex=_ref.updateScrollOffsetForScrollToIndex;if(_ref.cellCount!==_ref.nextCellsCount||(\"number\"===typeof cellSize||\"number\"===typeof nextCellSize)&&cellSize!==nextCellSize)computeMetadataCallback(computeMetadataCallbackProps),0<=scrollToIndex&&scrollToIndex===nextScrollToIndex&&updateScrollOffsetForScrollToIndex()}}","~:source","shadow$provide[\"module$node_modules$react_virtualized$dist$commonjs$Grid$utils$calculateSizeAndPositionDataAndUpdateScrollOffset\"] = function(global,process,require,module,exports,shadow$shims) {\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = calculateSizeAndPositionDataAndUpdateScrollOffset;\nfunction calculateSizeAndPositionDataAndUpdateScrollOffset(_ref) {\n  var cellCount = _ref.cellCount,\n      cellSize = _ref.cellSize,\n      computeMetadataCallback = _ref.computeMetadataCallback,\n      computeMetadataCallbackProps = _ref.computeMetadataCallbackProps,\n      nextCellsCount = _ref.nextCellsCount,\n      nextCellSize = _ref.nextCellSize,\n      nextScrollToIndex = _ref.nextScrollToIndex,\n      scrollToIndex = _ref.scrollToIndex,\n      updateScrollOffsetForScrollToIndex = _ref.updateScrollOffsetForScrollToIndex;\n\n  // Don't compare cell sizes if they are functions because inline functions would cause infinite loops.\n  // In that event users should use the manual recompute methods to inform of changes.\n  if (cellCount !== nextCellsCount || (typeof cellSize === 'number' || typeof nextCellSize === 'number') && cellSize !== nextCellSize) {\n    computeMetadataCallback(computeMetadataCallbackProps);\n\n    // Updated cell metadata may have hidden the previous scrolled-to item.\n    // In this case we should also update the scrollTop to ensure it stays visible.\n    if (scrollToIndex >= 0 && scrollToIndex === nextScrollToIndex) {\n      updateScrollOffsetForScrollToIndex();\n    }\n  }\n}\n\n/**\n * Helper method that determines when to recalculate row or column metadata.\n */\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["__esModule","value","default"]],"~:compiled-at",1537791607595,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$react_virtualized$dist$commonjs$Grid$utils$calculateSizeAndPositionDataAndUpdateScrollOffset.js\",\n\"lineCount\":2,\n\"mappings\":\"AAAAA,cAAA,iHAAA,CAAqI,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,OAAhB,CAAwBC,MAAxB,CAA+BC,OAA/B,CAAuCC,YAAvC,CAAqD,CAGlMC,MAAAC,eAAA,CAAsBH,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CI,MAAO,CAAA,CADoC,CAA7C,CAGAJ,QAAAK,QAAA,CACAC,QAA0D,CAACC,IAAD,CAAO,CAAA,IAE3DC,SAAWD,IAAAC,SAFgD,CAG3DC,wBAA0BF,IAAAE,wBAHiC,CAI3DC,6BAA+BH,IAAAG,6BAJ4B,CAM3DC,aAAeJ,IAAAI,aAN4C,CAO3DC,kBAAoBL,IAAAK,kBAPuC,CAQ3DC;AAAgBN,IAAAM,cAR2C,CAS3DC,mCAAqCP,IAAAO,mCAIzC,IAZgBP,IAAAQ,UAYhB,GARqBR,IAAAS,eAQrB,GAAyD,QAAzD,GAAqC,MAAOR,SAA5C,EAA6F,QAA7F,GAAqE,MAAOG,aAA5E,GAA0GH,QAA1G,GAAuHG,YAAvH,CACEF,uBAAA,CAAwBC,4BAAxB,CAIA,CAAqB,CAArB,EAAIG,aAAJ,EAA0BA,aAA1B,GAA4CD,iBAA5C,EACEE,kCAAA,EAnB2D,CAPiI;\",\n\"sources\":[\"node_modules/react-virtualized/dist/commonjs/Grid/utils/calculateSizeAndPositionDataAndUpdateScrollOffset.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$react_virtualized$dist$commonjs$Grid$utils$calculateSizeAndPositionDataAndUpdateScrollOffset\\\"] = function(global,process,require,module,exports,shadow$shims) {\\n'use strict';\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.default = calculateSizeAndPositionDataAndUpdateScrollOffset;\\nfunction calculateSizeAndPositionDataAndUpdateScrollOffset(_ref) {\\n  var cellCount = _ref.cellCount,\\n      cellSize = _ref.cellSize,\\n      computeMetadataCallback = _ref.computeMetadataCallback,\\n      computeMetadataCallbackProps = _ref.computeMetadataCallbackProps,\\n      nextCellsCount = _ref.nextCellsCount,\\n      nextCellSize = _ref.nextCellSize,\\n      nextScrollToIndex = _ref.nextScrollToIndex,\\n      scrollToIndex = _ref.scrollToIndex,\\n      updateScrollOffsetForScrollToIndex = _ref.updateScrollOffsetForScrollToIndex;\\n\\n  // Don't compare cell sizes if they are functions because inline functions would cause infinite loops.\\n  // In that event users should use the manual recompute methods to inform of changes.\\n  if (cellCount !== nextCellsCount || (typeof cellSize === 'number' || typeof nextCellSize === 'number') && cellSize !== nextCellSize) {\\n    computeMetadataCallback(computeMetadataCallbackProps);\\n\\n    // Updated cell metadata may have hidden the previous scrolled-to item.\\n    // In this case we should also update the scrollTop to ensure it stays visible.\\n    if (scrollToIndex >= 0 && scrollToIndex === nextScrollToIndex) {\\n      updateScrollOffsetForScrollToIndex();\\n    }\\n  }\\n}\\n\\n/**\\n * Helper method that determines when to recalculate row or column metadata.\\n */\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"process\",\"require\",\"module\",\"exports\",\"shadow$shims\",\"Object\",\"defineProperty\",\"value\",\"default\",\"calculateSizeAndPositionDataAndUpdateScrollOffset\",\"_ref\",\"cellSize\",\"computeMetadataCallback\",\"computeMetadataCallbackProps\",\"nextCellSize\",\"nextScrollToIndex\",\"scrollToIndex\",\"updateScrollOffsetForScrollToIndex\",\"cellCount\",\"nextCellsCount\"]\n}\n"]